{
  "v": "5.7.11",
  "ip": 0,
  "op": 126,
  "fr": 25,
  "w": 512,
  "h": 512,
  "nm": "Comp 4",
  "assets": [],
  "layers": [
    {
      "ind": 1,
      "ty": 4,
      "nm": "Layer 3",
      "sr": 1.0,
      "ks": {
        "o": { "a": 0, "k": 100.0 },
        "r": { "a": 0, "k": 0.0 },
        "p": { "a": 0, "k": [196.506, 231.999, 0.0], "l": 2 },
        "a": { "a": 0, "k": [-59.494, -24.001, 0.0], "l": 2 },
        "s": {
          "k": [
            {
              "i": { "x": [0.667, 0.667, 0.667], "y": [1.0, 1.0, 1.0] },
              "o": { "x": [0.333, 0.333, 0.333], "y": [0.0, 0.0, 0.0] },
              "t": 25,
              "s": [0, 0, 100]
            },
            { "t": 36, "s": [100, 100, 100] }
          ],
          "x": "var $bm_rt;\nvar fx = effect('\u015dlosilo pli pura');\nvar doAnticipation = fx(1).value;\nvar doInterpolation = fx(2).value;\nvar doFollowThrough = fx(3).value;\nvar damping = $bm_div(fx(15).value, 10);\nvar elasticity = $bm_div(fx(13).value, 10);\nvar bounce = fx(17).value;\nvar anticipationDuration = fx(5).value;\nvar anticipationQuantity = $bm_div(fx(6).value, 100);\nvar slowIn = $bm_div(fx(9).value, 100);\nvar slowOut = $bm_div(fx(10).value, 100);\nvar spatialMode = fx(21).value;\nvar spatialDoInterpolation = fx(20).value;\nvar moBlurPrecision = fx(32).value;\nvar elasticityRandom = fx(14).value;\nvar dampingRandom = fx(16).value;\nvar softBody = fx(28).value;\nvar flexibility = $bm_div(fx(29).value, 100);\nvar doOverlap = fx(23).value;\nvar overlapDuration = fx(24).value;\nvar overlapRandom = fx(25).value;\nvar threshold = $bm_div($bm_div(1, moBlurPrecision), 1000);\nvar zeroValue;\nif ($bm_isInstanceOfArray(value)) {\n    if (value.length == 2)\n        zeroValue = [\n            0,\n            0\n        ];\n    else if (value.length == 3)\n        zeroValue = [\n            0,\n            0,\n            0\n        ];\n    else if (value.length == 4)\n        zeroValue = [\n            0,\n            0,\n            0,\n            0\n        ];\n} else\n    zeroValue = 0;\nvar isThisSpatial = isSpatial(thisProperty);\nvar isThisPosition = thisProperty === $bm_transform.position;\nvar simulate = false;\nif (isThisSpatial) {\n    doInterpolation = doInterpolation && spatialDoInterpolation;\n    if (isThisPosition && thisProperty.numKeys > 0) {\n        doOverlap = false;\n        simulate = false;\n    } else {\n        simulate = spatialMode == 2;\n        doOverlap = overlapDuration != 0 && doOverlap && simulate;\n    }\n} else {\n    doOverlap = false;\n}\nif (!doOverlap) {\n    overlapDuration = 0;\n}\nif (simulate && softBody && isThisSpatial && !isThisPosition && (doFollowThrough || doOverlap)) {\n    var distanceRatio = $bm_div(length(valueAtTime(0), $bm_transform.anchorPoint), $bm_div(thisLayer.width, 2));\n    distanceRatio = $bm_div($bm_sum(1, $bm_mul(distanceRatio, flexibility)), 2);\n    if (doFollowThrough) {\n        elasticity = $bm_div(elasticity, distanceRatio);\n        damping = $bm_div(damping, distanceRatio);\n    }\n    if (doOverlap) {\n        overlapDuration = $bm_mul(overlapDuration, distanceRatio);\n    }\n}\nseedRandom(0, true);\nif (doFollowThrough) {\n    if (elasticityRandom > 0)\n        elasticity = addNoise(elasticity, elasticityRandom);\n    if (dampingRandom > 0)\n        damping = addNoise(damping, dampingRandom);\n}\nif (doOverlap) {\n    if (doOverlap && overlapRandom > 0)\n        overlapDuration = addNoise(overlapDuration, overlapRandom);\n}\nvar result = value;\nfunction isSpatial(prop) {\n    if (!(prop.value instanceof Array))\n        return false;\n    if (prop.value.length != 2 && prop.value.length != 3)\n        return false;\n    try {\n        if (typeof prop.speed !== 'undefined')\n            return true;\n    } catch (e) {\n        return false;\n    }\n}\nfunction addNoise(val, quantity) {\n    var randomValue = random(0.9, 1.1);\n    var noiseValue = noise($bm_mul(valueAtTime(0), randomValue));\n    noiseValue = $bm_mul(noiseValue, $bm_div(quantity, 100));\n    return $bm_mul(val, $bm_sum(noiseValue, 1));\n}\nfunction isAfterLastKey() {\n    if (numKeys == 0)\n        return false;\n    var nKey = nearestKey(time);\n    return nKey.time <= time && nKey.index == numKeys;\n}\nfunction isStill(t, threshold) {\n    var d = $bm_sub(valueAtTime(t), valueAtTime($bm_sum(t, framesToTime(1))));\n    if ($bm_isInstanceOfArray(d)) {\n        for (var i = 0; i < d.length; i++) {\n            d[i] = Math.abs(d[i]);\n            if (d[i] >= threshold) {\n                return false;\n            }\n        }\n        return true;\n    } else {\n        d = Math.abs(d);\n        return d < threshold;\n    }\n}\nfunction bezierInterpolation(t, tMin, tMax, value1, value2, bezierPoints) {\n    if (arguments.length !== 5 && arguments.length !== 6)\n        return t;\n    var a = $bm_sub(value2, value1);\n    var b = $bm_sub(tMax, tMin);\n    if (b == 0)\n        return t;\n    var c = clamp($bm_div($bm_sub(t, tMin), b), 0, 1);\n    if (!(bezierPoints instanceof Array) || bezierPoints.length !== 4)\n        bezierPoints = [\n            0.33,\n            0,\n            0.66,\n            1\n        ];\n    return $bm_sum($bm_mul(a, h(c, bezierPoints)), value1);\n    function h(f, g) {\n        var x = $bm_mul(3, g[0]);\n        var j = $bm_sub($bm_mul(3, $bm_sub(g[2], g[0])), x);\n        var k = $bm_sub($bm_sub(1, x), j);\n        var l = $bm_mul(3, g[1]);\n        var m = $bm_sub($bm_mul(3, $bm_sub(g[3], g[1])), l);\n        var n = $bm_sub($bm_sub(1, l), m);\n        var d = f;\n        for (var i = 0; i < 5; i++) {\n            var z = $bm_sub($bm_mul(d, $bm_sum(x, $bm_mul(d, $bm_sum(j, $bm_mul(d, k))))), f);\n            if (Math.abs(z) < 0.001)\n                break;\n            d = $bm_sub(d, $bm_div(z, $bm_sum(x, $bm_mul(d, $bm_sum($bm_mul(2, j), $bm_mul($bm_mul(3, k), d))))));\n        }\n        return $bm_mul(d, $bm_sum(l, $bm_mul(d, $bm_sum(m, $bm_mul(d, n)))));\n    }\n}\nfunction getPropWorldSpeed(t, prop) {\n    return length(getPropWorldVelocity(t, prop));\n}\nfunction getPrevKey(t) {\n    if (numKeys == 0)\n        return null;\n    var nKey = nearestKey(t);\n    if (nKey.time <= t)\n        return nKey;\n    if (nKey.index > 1)\n        return key($bm_sub(nKey.index, 1));\n    return null;\n}\nfunction getNextKey(t) {\n    if (numKeys == 0)\n        return null;\n    var nKey = nearestKey(t);\n    if (nKey.time >= t)\n        return nKey;\n    if (nKey.index < numKeys)\n        return key($bm_sum(nKey.index, 1));\n    return null;\n}\nfunction getPropWorldVelocity(t, prop) {\n    return $bm_mul($bm_sub(getPropWorldValue($bm_sum(t, 0.005), prop), getPropWorldValue($bm_sub(t, 0.005), prop)), 100);\n}\nfunction getLayerWorldPos(t, l) {\n    return l.toWorld(l.anchorPoint, t);\n}\nfunction getPropWorldValue(t, prop) {\n    if (isPosition(prop))\n        return getLayerWorldPos(t, thisLayer);\n    return thisLayer.toWorld(prop.valueAtTime(t), t);\n}\nfunction isPosition(prop) {\n    return prop === $bm_transform.position;\n}\nfunction isKeyTop(k, axis) {\n    var prevSpeed = velocityAtTime($bm_sub(k.time, threshold));\n    var nextSpeed = velocityAtTime($bm_sum(k.time, threshold));\n    if ($bm_isInstanceOfArray(value)) {\n        prevSpeed = prevSpeed[axis];\n        nextSpeed = nextSpeed[axis];\n    }\n    if (Math.abs(prevSpeed) < 0.01 || Math.abs(nextSpeed) < 0.01)\n        return true;\n    return $bm_mul(prevSpeed, nextSpeed) < 0;\n}\nfunction anticipate() {\n    var anticipation = zeroValue;\n    if (isAfterLastKey())\n        return anticipation;\n    if (numKeys < 2)\n        return anticipation;\n    var nextKey = getNextKey(time);\n    var aKey = nextKey;\n    if (!isStill(aKey.time - 0.1, 0.1)) {\n        aKey = getPrevKey(time);\n        if (!isStill(aKey.time - 0.1, 0.1))\n            return anticipation;\n    }\n    if (aKey.index == numKeys)\n        return anticipation;\n    var anticipationMiddle = aKey.time;\n    var anticipationStart = $bm_sub(anticipationMiddle, anticipationDuration);\n    var anticipationEnd = key(aKey.index + 1).time;\n    var startValue = anticipation;\n    var midValue = $bm_mul($bm_sum($bm_neg(valueAtTime($bm_sum(anticipationMiddle, anticipationDuration))), aKey.value), anticipationQuantity);\n    var endValue = anticipation;\n    if (time < anticipationStart) {\n        return anticipation;\n    } else if (time < anticipationMiddle) {\n        if ($bm_isInstanceOfArray(value)) {\n            for (var i = 0; i < value.length; i++) {\n                anticipation[i] = bezierInterpolation(time, anticipationStart, anticipationMiddle, startValue[i], midValue[i], [\n                    slowOut,\n                    0,\n                    slowIn,\n                    1\n                ]);\n            }\n            return anticipation;\n        } else {\n            return bezierInterpolation(time, anticipationStart, anticipationMiddle, startValue, midValue, [\n                slowOut,\n                0,\n                slowIn,\n                1\n            ]);\n        }\n    } else if (time <= anticipationEnd) {\n        if ($bm_isInstanceOfArray(value)) {\n            for (var i = 0; i < value.length; i++) {\n                anticipation[i] = bezierInterpolation(time, anticipationMiddle, anticipationEnd, midValue[i], endValue[i], [\n                    slowOut,\n                    0,\n                    slowIn,\n                    1\n                ]);\n            }\n            return anticipation;\n        } else {\n            return bezierInterpolation(time, anticipationMiddle, anticipationEnd, midValue, endValue, [\n                slowOut,\n                0,\n                slowIn,\n                1\n            ]);\n        }\n    } else {\n        return anticipation;\n    }\n}\nfunction followThroughAtTime(t) {\n    var fThrough = zeroValue;\n    if (elasticity == 0)\n        return fThrough;\n    var propSpeed;\n    if (!simulate) {\n        if (numKeys < 2)\n            return fThrough;\n        if (nearestKey(t).index == 1)\n            return fThrough;\n        propSpeed = length(velocityAtTime(t));\n        if (propSpeed >= threshold)\n            return fThrough;\n    } else {\n        propSpeed = getPropWorldSpeed(t, thisProperty);\n        if (propSpeed >= threshold)\n            return fThrough;\n    }\n    var fThroughStart = 0;\n    var fThroughTime = 0;\n    if (simulate) {\n        var speedI = getPropWorldSpeed(t, thisProperty);\n        var i = t;\n        while (speedI < threshold && i > 0) {\n            i = $bm_sub(i, $bm_div(thisComp.frameDuration, moBlurPrecision));\n            speedI = getPropWorldSpeed(i, thisProperty);\n        }\n        fThroughStart = i;\n    } else {\n        var fThroughKey = getPrevKey(t);\n        fThroughStart = fThroughKey.time;\n    }\n    if (fThroughStart == 0)\n        return fThrough;\n    fThroughTime = $bm_sub(t, fThroughStart);\n    if (simulate)\n        fThrough = $bm_div(getPropWorldVelocity($bm_sub(fThroughStart, thisComp.frameDuration), thisProperty), 2);\n    else\n        fThrough = $bm_div(velocityAtTime($bm_sub(fThroughStart, thisComp.frameDuration)), 2);\n    if (bounce) {\n        var cycleDamp = Math.exp($bm_mul($bm_mul(fThroughTime, damping), 0.1));\n        var damp = $bm_div(Math.exp($bm_mul(fThroughTime, damping)), $bm_div(elasticity, 2));\n        var cycleDuration = $bm_div(1, $bm_mul(elasticity, 2));\n        cycleDuration = Math.round(timeToFrames(cycleDuration));\n        cycleDuration = framesToTime(cycleDuration);\n        var midDuration = $bm_div(cycleDuration, 2);\n        var maxValue = $bm_mul(fThrough, midDuration);\n        var cycvarime = fThroughTime;\n        var numEndCycles = 1;\n        while (cycvarime > cycleDuration) {\n            cycvarime = $bm_sub(cycvarime, cycleDuration);\n            cycleDuration = $bm_div(cycleDuration, cycleDamp);\n            cycleDuration = Math.round(timeToFrames(cycleDuration));\n            if (cycleDuration < 2) {\n                cycleDuration = 2;\n                numEndCycles++;\n            }\n            cycleDuration = framesToTime(cycleDuration);\n            midDuration = $bm_div(cycleDuration, 2);\n            maxValue = $bm_div($bm_mul(fThrough, midDuration), damp);\n            if (numEndCycles > 100 / damping && maxValue < threshold)\n                return zeroValue;\n        }\n        if (cycvarime < midDuration)\n            fThrough = bezierInterpolation(cycvarime, 0, midDuration, 0, maxValue, [\n                0,\n                0.1,\n                slowIn,\n                1\n            ]);\n        else\n            fThrough = bezierInterpolation(cycvarime, midDuration, cycleDuration, maxValue, 0, [\n                $bm_sub(1, slowIn),\n                0,\n                1,\n                0.9\n            ]);\n    } else {\n        var damp = Math.exp($bm_mul(fThroughTime, damping));\n        var sinus = $bm_mul($bm_mul($bm_mul(elasticity, fThroughTime), 2), Math.PI);\n        sinus = Math.sin(sinus);\n        sinus = $bm_mul($bm_div(0.3, elasticity), sinus);\n        sinus = $bm_div(sinus, damp);\n        if (Math.abs(sinus) < $bm_div(threshold, 100))\n            return 0;\n        fThrough = $bm_mul(fThrough, sinus);\n        if (threshold > 0) {\n            fThrough = $bm_mul(fThrough, $bm_sub(1, $bm_div(propSpeed, threshold)));\n        }\n    }\n    if (bounce) {\n        var prevValue = valueAtTime($bm_sub(fThroughStart, thisComp.frameDuration));\n        var startValue = valueAtTime(fThroughStart);\n        if ($bm_isInstanceOfArray(value)) {\n            for (var i = 0; i < prevValue.length; i++) {\n                if (prevValue[i] > startValue[i])\n                    fThrough[i] = Math.abs(fThrough[i]);\n                if (prevValue[i] < startValue[i])\n                    fThrough[i] = $bm_neg(Math.abs(fThrough[i]));\n            }\n        } else {\n            if (prevValue > startValue)\n                fThrough = Math.abs(fThrough);\n            if (prevValue < startValue)\n                fThrough = $bm_neg(Math.abs(fThrough));\n        }\n    }\n    if (simulate) {\n        if (!isThisPosition) {\n            fThrough = $bm_sum(fThrough, getLayerWorldPos(time, thisLayer));\n            fThrough = $bm_sub(thisLayer.fromWorld(fThrough), thisLayer.anchorPoint);\n        } else if (thisLayer.hasParent) {\n            fThrough = $bm_sum(fThrough, getLayerWorldPos(time, thisLayer.parent));\n            fThrough = $bm_sub(thisLayer.parent.fromWorld(fThrough), thisLayer.parent.anchorPoint);\n        }\n    }\n    return fThrough;\n}\nfunction followThrough() {\n    var propSpeed = length(velocity);\n    if (propSpeed < threshold)\n        return followThroughAtTime($bm_sub(time, overlapDuration));\n    var fThrough = zeroValue;\n    var t = time;\n    while (t > 0) {\n        t = $bm_sub(t, thisComp.frameDuration);\n        if (simulate)\n            propSpeed = getPropWorldSpeed($bm_sub(t, overlapDuration), thisProperty);\n        else\n            propSpeed = length(velocityAtTime(t));\n        if (propSpeed < threshold) {\n            fThrough = followThroughAtTime($bm_sub(t, overlapDuration));\n            break;\n        }\n    }\n    return linear(time, t, $bm_sum(t, $bm_mul(anticipationDuration, 2)), fThrough, zeroValue);\n}\nfunction smartSmooth(axis) {\n    var startKey = nearestKey(time);\n    var endKey = startKey;\n    if (time == startKey.time)\n        return 0;\n    if (time < startKey.time && startKey.index == 1)\n        return 0;\n    if (time > startKey.time && startKey.index == numKeys)\n        return 0;\n    if (time < startKey.time)\n        startKey = key($bm_sub(startKey.index, 1));\n    if (time > startKey.time)\n        endKey = key($bm_sum(startKey.index, 1));\n    var sI = 0.66;\n    var sO = 0.33;\n    var sIV = 1;\n    var sOV = 0;\n    var sVal = startKey.value;\n    var eVal = endKey.value;\n    if ($bm_isInstanceOfArray(value)) {\n        sVal = sVal[axis];\n        eVal = eVal[axis];\n    }\n    var sTime = startKey.time;\n    var eTime = endKey.time;\n    if (isKeyTop(startKey, axis))\n        sO = slowOut;\n    else {\n        var prevKey = key($bm_sub(startKey.index, 1));\n        var pVal = prevKey.value;\n        if ($bm_isInstanceOfArray(value))\n            pVal = pVal[axis];\n        sOV = $bm_div($bm_sub(sVal, pVal), $bm_sub(eVal, pVal));\n    }\n    if (isKeyTop(endKey, axis)) {\n        sI = slowIn;\n        if (endKey.index != numKeys) {\n            var nextKey = key($bm_sum(endKey.index, 1));\n            var nVal = nextKey.value;\n            if ($bm_isInstanceOfArray(value))\n                nVal = nVal[axis];\n            if (Math.abs(nVal - eVal) < 0.01 && doFollowThrough)\n                sI = 1;\n        }\n    } else {\n        var nextKey = key($bm_sum(endKey.index, 1));\n        var nVal = nextKey.value;\n        if ($bm_isInstanceOfArray(value))\n            nVal = nVal[axis];\n        sIV = $bm_div($bm_sub(eVal, sVal), $bm_sub(nVal, sVal));\n    }\n    if (endKey.index == numKeys && doFollowThrough) {\n        sI = 1;\n    }\n    var val = value;\n    if ($bm_isInstanceOfArray(value))\n        val = val[axis];\n    return $bm_sub(bezierInterpolation(time, sTime, eTime, sVal, eVal, [\n        sO,\n        sOV,\n        sI,\n        sIV\n    ]), val);\n}\nfunction overlap() {\n    var ol = zeroValue;\n    if (isThisPosition && !hasParent)\n        return zeroValue;\n    ol = $bm_sub(getPropWorldValue($bm_sub(time, overlapDuration), thisProperty), getPropWorldValue(time, thisProperty));\n    var motionRatio = $bm_div($bm_div(length(zeroValue, ol), thisLayer.width), 2);\n    if (isThisPosition) {\n        var originalDistance = length(valueAtTime(0));\n        motionRatio = $bm_div(length(zeroValue, ol), thisComp.width);\n    }\n    ol = $bm_sum(ol, getPropWorldValue(time, thisProperty));\n    ol = $bm_sum(ol, $bm_mul($bm_mul($bm_sub(getPropWorldValue($bm_sub(time, overlapDuration), thisLayer.anchorPoint), ol), motionRatio), flexibility));\n    ol = thisLayer.fromWorld(ol);\n    if (!isThisPosition)\n        ol = $bm_sub(ol, value);\n    else {\n        ol = linear(flexibility, 0, 100, $bm_div(ol, 2), 0);\n        var prevParentWorldPos = getLayerWorldPos($bm_sub(time, overlapDuration), parent);\n        ol = $bm_sum(ol, $bm_mul($bm_mul($bm_mul(thisLayer.fromWorld(prevParentWorldPos), motionRatio), flexibility), 5));\n    }\n    return ol;\n}\nvar okToGo = false;\nif (simulate && fx.enabled)\n    okToGo = true;\nelse if (numKeys > 1 && fx.enabled)\n    okToGo = true;\nif (okToGo) {\n    var smartSmoothResult = zeroValue;\n    if (doInterpolation) {\n        if ($bm_isInstanceOfArray(value)) {\n            if (value.length == 2)\n                smartSmoothResult = [\n                    smartSmooth(0),\n                    smartSmooth(1)\n                ];\n            else if (value.length == 3)\n                smartSmoothResult = [\n                    smartSmooth(0),\n                    smartSmooth(1),\n                    smartSmooth(2)\n                ];\n            else if (value.length == 4)\n                smartSmoothResult = [\n                    smartSmooth(0),\n                    smartSmooth(1),\n                    smartSmooth(2),\n                    smartSmooth(3)\n                ];\n        } else {\n            smartSmoothResult = smartSmooth(0);\n        }\n    }\n    if (doAnticipation)\n        result = $bm_sum(result, anticipate());\n    result = $bm_sum(result, smartSmoothResult);\n    if (doFollowThrough)\n        result = $bm_sum(result, followThrough());\n    if (doOverlap)\n        result = $bm_sum(result, overlap());\n}\n$bm_rt = result;",
          "a": 1,
          "l": 2
        }
      },
      "shapes": [
        {
          "ty": "gr",
          "nm": "Group 1",
          "bm": 0,
          "mn": "ADBE Vector Group",
          "it": [
            {
              "ty": "gr",
              "nm": "Group 7",
              "bm": 0,
              "mn": "ADBE Vector Group",
              "it": [
                {
                  "ty": "gr",
                  "nm": "Group 1",
                  "bm": 0,
                  "mn": "ADBE Vector Group",
                  "it": [
                    {
                      "ty": "sh",
                      "nm": "Path 1",
                      "mn": "ADBE Vector Shape - Group",
                      "ind": 0,
                      "ks": {
                        "k": {
                          "i": [
                            [-0.255, 1.411],
                            [1.294, -1.068],
                            [1.457, 0.831],
                            [-1.12, 0.895]
                          ],
                          "o": [
                            [0.54, 1.588],
                            [-1.294, 1.068],
                            [1.432, 0.062],
                            [1.12, -0.895]
                          ],
                          "v": [
                            [-50.124, -125.871],
                            [-51.417, -121.319],
                            [-56.131, -120.913],
                            [-52.234, -122.445]
                          ],
                          "c": true
                        },
                        "a": 0
                      }
                    },
                    {
                      "ty": "fl",
                      "nm": "Fill 1",
                      "bm": 0,
                      "mn": "ADBE Vector Graphic - Fill",
                      "c": { "a": 0, "k": [1.0, 1.0, 1.0, 1.0] },
                      "o": { "a": 0, "k": 100.0 },
                      "r": 1
                    },
                    {
                      "ty": "tr",
                      "o": { "a": 0, "k": 100.0 },
                      "r": { "a": 0, "k": 0.0 },
                      "p": { "a": 0, "k": [0.0, 0.0] },
                      "a": { "a": 0, "k": [0.0, 0.0] },
                      "s": { "a": 0, "k": [100.0, 100.0] },
                      "nm": "Transform",
                      "sk": { "a": 0, "k": 0.0 },
                      "sa": { "a": 0, "k": 0.0 }
                    }
                  ]
                },
                {
                  "ty": "gr",
                  "nm": "Group 2",
                  "bm": 0,
                  "mn": "ADBE Vector Group",
                  "it": [
                    {
                      "ty": "sh",
                      "nm": "Path 1",
                      "mn": "ADBE Vector Shape - Group",
                      "ind": 0,
                      "ks": {
                        "k": {
                          "i": [
                            [0.061, -1.447],
                            [1.447, 0.061],
                            [-0.061, 1.447],
                            [-1.447, -0.061]
                          ],
                          "o": [
                            [-0.061, 1.447],
                            [-1.447, -0.061],
                            [0.061, -1.447],
                            [1.447, 0.061]
                          ],
                          "v": [
                            [-54.966, -127.627],
                            [-57.696, -125.118],
                            [-60.206, -127.848],
                            [-57.475, -130.357]
                          ],
                          "c": true
                        },
                        "a": 0
                      }
                    },
                    {
                      "ty": "fl",
                      "nm": "Fill 1",
                      "bm": 0,
                      "mn": "ADBE Vector Graphic - Fill",
                      "c": { "a": 0, "k": [1.0, 1.0, 1.0, 1.0] },
                      "o": { "a": 0, "k": 100.0 },
                      "r": 1
                    },
                    {
                      "ty": "tr",
                      "o": { "a": 0, "k": 100.0 },
                      "r": { "a": 0, "k": 0.0 },
                      "p": { "a": 0, "k": [0.0, 0.0] },
                      "a": { "a": 0, "k": [0.0, 0.0] },
                      "s": { "a": 0, "k": [100.0, 100.0] },
                      "nm": "Transform",
                      "sk": { "a": 0, "k": 0.0 },
                      "sa": { "a": 0, "k": 0.0 }
                    }
                  ]
                },
                {
                  "ty": "gr",
                  "nm": "Group 3",
                  "bm": 0,
                  "mn": "ADBE Vector Group",
                  "it": [
                    {
                      "ty": "sh",
                      "nm": "Path 1",
                      "mn": "ADBE Vector Shape - Group",
                      "ind": 0,
                      "ks": {
                        "k": {
                          "i": [
                            [0.179, -4.229],
                            [4.229, 0.179],
                            [-0.179, 4.229],
                            [-4.229, -0.179]
                          ],
                          "o": [
                            [-0.179, 4.229],
                            [-4.229, -0.179],
                            [0.179, -4.229],
                            [4.229, 0.179]
                          ],
                          "v": [
                            [-47.618, -125.277],
                            [-55.599, -117.943],
                            [-62.933, -125.924],
                            [-54.952, -133.258]
                          ],
                          "c": true
                        },
                        "a": 0
                      }
                    },
                    {
                      "ty": "st",
                      "nm": "Stroke 1",
                      "bm": 0,
                      "mn": "ADBE Vector Graphic - Stroke",
                      "lc": 2,
                      "lj": 2,
                      "o": { "a": 0, "k": 100.0 },
                      "w": { "a": 0, "k": 0.598 },
                      "c": { "a": 0, "k": [0.0, 0.0, 0.0, 1.0] }
                    },
                    {
                      "ty": "fl",
                      "nm": "Fill 1",
                      "bm": 0,
                      "mn": "ADBE Vector Graphic - Fill",
                      "c": { "a": 0, "k": [0.0, 0.0, 0.0, 1.0] },
                      "o": { "a": 0, "k": 100.0 },
                      "r": 1
                    },
                    {
                      "ty": "tr",
                      "o": { "a": 0, "k": 100.0 },
                      "r": { "a": 0, "k": 0.0 },
                      "p": { "a": 0, "k": [0.0, 0.0] },
                      "a": { "a": 0, "k": [0.0, 0.0] },
                      "s": { "a": 0, "k": [100.0, 100.0] },
                      "nm": "Transform",
                      "sk": { "a": 0, "k": 0.0 },
                      "sa": { "a": 0, "k": 0.0 }
                    }
                  ]
                },
                {
                  "ty": "tr",
                  "o": { "a": 0, "k": 100.0 },
                  "r": { "a": 0, "k": 0.0 },
                  "p": { "a": 0, "k": [-55.275, -125.601] },
                  "a": { "a": 0, "k": [-55.275, -125.601] },
                  "s": {
                    "k": [
                      {
                        "i": { "x": [0.667, 0.667], "y": [1.0, 1.0] },
                        "o": { "x": [0.333, 0.333], "y": [0.0, 0.0] },
                        "t": 53,
                        "s": [100, 100]
                      },
                      { "t": 62, "s": [162, 162] }
                    ],
                    "x": "var $bm_rt;\nvar fx = effect('\u015dlosilo pli pura 2');\nvar doAnticipation = fx(1).value;\nvar doInterpolation = fx(2).value;\nvar doFollowThrough = fx(3).value;\nvar damping = $bm_div(fx(15).value, 10);\nvar elasticity = $bm_div(fx(13).value, 10);\nvar bounce = fx(17).value;\nvar anticipationDuration = fx(5).value;\nvar anticipationQuantity = $bm_div(fx(6).value, 100);\nvar slowIn = $bm_div(fx(9).value, 100);\nvar slowOut = $bm_div(fx(10).value, 100);\nvar spatialMode = fx(21).value;\nvar spatialDoInterpolation = fx(20).value;\nvar moBlurPrecision = fx(32).value;\nvar elasticityRandom = fx(14).value;\nvar dampingRandom = fx(16).value;\nvar softBody = fx(28).value;\nvar flexibility = $bm_div(fx(29).value, 100);\nvar doOverlap = fx(23).value;\nvar overlapDuration = fx(24).value;\nvar overlapRandom = fx(25).value;\nvar threshold = $bm_div($bm_div(1, moBlurPrecision), 1000);\nvar zeroValue;\nif ($bm_isInstanceOfArray(value)) {\n    if (value.length == 2)\n        zeroValue = [\n            0,\n            0\n        ];\n    else if (value.length == 3)\n        zeroValue = [\n            0,\n            0,\n            0\n        ];\n    else if (value.length == 4)\n        zeroValue = [\n            0,\n            0,\n            0,\n            0\n        ];\n} else\n    zeroValue = 0;\nvar isThisSpatial = isSpatial(thisProperty);\nvar isThisPosition = thisProperty === $bm_transform.position;\nvar simulate = false;\nif (isThisSpatial) {\n    doInterpolation = doInterpolation && spatialDoInterpolation;\n    if (isThisPosition && thisProperty.numKeys > 0) {\n        doOverlap = false;\n        simulate = false;\n    } else {\n        simulate = spatialMode == 2;\n        doOverlap = overlapDuration != 0 && doOverlap && simulate;\n    }\n} else {\n    doOverlap = false;\n}\nif (!doOverlap) {\n    overlapDuration = 0;\n}\nif (simulate && softBody && isThisSpatial && !isThisPosition && (doFollowThrough || doOverlap)) {\n    var distanceRatio = $bm_div(length(valueAtTime(0), $bm_transform.anchorPoint), $bm_div(thisLayer.width, 2));\n    distanceRatio = $bm_div($bm_sum(1, $bm_mul(distanceRatio, flexibility)), 2);\n    if (doFollowThrough) {\n        elasticity = $bm_div(elasticity, distanceRatio);\n        damping = $bm_div(damping, distanceRatio);\n    }\n    if (doOverlap) {\n        overlapDuration = $bm_mul(overlapDuration, distanceRatio);\n    }\n}\nseedRandom(0, true);\nif (doFollowThrough) {\n    if (elasticityRandom > 0)\n        elasticity = addNoise(elasticity, elasticityRandom);\n    if (dampingRandom > 0)\n        damping = addNoise(damping, dampingRandom);\n}\nif (doOverlap) {\n    if (doOverlap && overlapRandom > 0)\n        overlapDuration = addNoise(overlapDuration, overlapRandom);\n}\nvar result = value;\nfunction isSpatial(prop) {\n    if (!(prop.value instanceof Array))\n        return false;\n    if (prop.value.length != 2 && prop.value.length != 3)\n        return false;\n    try {\n        if (typeof prop.speed !== 'undefined')\n            return true;\n    } catch (e) {\n        return false;\n    }\n}\nfunction addNoise(val, quantity) {\n    var randomValue = random(0.9, 1.1);\n    var noiseValue = noise($bm_mul(valueAtTime(0), randomValue));\n    noiseValue = $bm_mul(noiseValue, $bm_div(quantity, 100));\n    return $bm_mul(val, $bm_sum(noiseValue, 1));\n}\nfunction isAfterLastKey() {\n    if (numKeys == 0)\n        return false;\n    var nKey = nearestKey(time);\n    return nKey.time <= time && nKey.index == numKeys;\n}\nfunction isStill(t, threshold) {\n    var d = $bm_sub(valueAtTime(t), valueAtTime($bm_sum(t, framesToTime(1))));\n    if ($bm_isInstanceOfArray(d)) {\n        for (var i = 0; i < d.length; i++) {\n            d[i] = Math.abs(d[i]);\n            if (d[i] >= threshold) {\n                return false;\n            }\n        }\n        return true;\n    } else {\n        d = Math.abs(d);\n        return d < threshold;\n    }\n}\nfunction bezierInterpolation(t, tMin, tMax, value1, value2, bezierPoints) {\n    if (arguments.length !== 5 && arguments.length !== 6)\n        return t;\n    var a = $bm_sub(value2, value1);\n    var b = $bm_sub(tMax, tMin);\n    if (b == 0)\n        return t;\n    var c = clamp($bm_div($bm_sub(t, tMin), b), 0, 1);\n    if (!(bezierPoints instanceof Array) || bezierPoints.length !== 4)\n        bezierPoints = [\n            0.33,\n            0,\n            0.66,\n            1\n        ];\n    return $bm_sum($bm_mul(a, h(c, bezierPoints)), value1);\n    function h(f, g) {\n        var x = $bm_mul(3, g[0]);\n        var j = $bm_sub($bm_mul(3, $bm_sub(g[2], g[0])), x);\n        var k = $bm_sub($bm_sub(1, x), j);\n        var l = $bm_mul(3, g[1]);\n        var m = $bm_sub($bm_mul(3, $bm_sub(g[3], g[1])), l);\n        var n = $bm_sub($bm_sub(1, l), m);\n        var d = f;\n        for (var i = 0; i < 5; i++) {\n            var z = $bm_sub($bm_mul(d, $bm_sum(x, $bm_mul(d, $bm_sum(j, $bm_mul(d, k))))), f);\n            if (Math.abs(z) < 0.001)\n                break;\n            d = $bm_sub(d, $bm_div(z, $bm_sum(x, $bm_mul(d, $bm_sum($bm_mul(2, j), $bm_mul($bm_mul(3, k), d))))));\n        }\n        return $bm_mul(d, $bm_sum(l, $bm_mul(d, $bm_sum(m, $bm_mul(d, n)))));\n    }\n}\nfunction getPropWorldSpeed(t, prop) {\n    return length(getPropWorldVelocity(t, prop));\n}\nfunction getPrevKey(t) {\n    if (numKeys == 0)\n        return null;\n    var nKey = nearestKey(t);\n    if (nKey.time <= t)\n        return nKey;\n    if (nKey.index > 1)\n        return key($bm_sub(nKey.index, 1));\n    return null;\n}\nfunction getNextKey(t) {\n    if (numKeys == 0)\n        return null;\n    var nKey = nearestKey(t);\n    if (nKey.time >= t)\n        return nKey;\n    if (nKey.index < numKeys)\n        return key($bm_sum(nKey.index, 1));\n    return null;\n}\nfunction getPropWorldVelocity(t, prop) {\n    return $bm_mul($bm_sub(getPropWorldValue($bm_sum(t, 0.005), prop), getPropWorldValue($bm_sub(t, 0.005), prop)), 100);\n}\nfunction getLayerWorldPos(t, l) {\n    return l.toWorld(l.anchorPoint, t);\n}\nfunction getPropWorldValue(t, prop) {\n    if (isPosition(prop))\n        return getLayerWorldPos(t, thisLayer);\n    return thisLayer.toWorld(prop.valueAtTime(t), t);\n}\nfunction isPosition(prop) {\n    return prop === $bm_transform.position;\n}\nfunction isKeyTop(k, axis) {\n    var prevSpeed = velocityAtTime($bm_sub(k.time, threshold));\n    var nextSpeed = velocityAtTime($bm_sum(k.time, threshold));\n    if ($bm_isInstanceOfArray(value)) {\n        prevSpeed = prevSpeed[axis];\n        nextSpeed = nextSpeed[axis];\n    }\n    if (Math.abs(prevSpeed) < 0.01 || Math.abs(nextSpeed) < 0.01)\n        return true;\n    return $bm_mul(prevSpeed, nextSpeed) < 0;\n}\nfunction anticipate() {\n    var anticipation = zeroValue;\n    if (isAfterLastKey())\n        return anticipation;\n    if (numKeys < 2)\n        return anticipation;\n    var nextKey = getNextKey(time);\n    var aKey = nextKey;\n    if (!isStill(aKey.time - 0.1, 0.1)) {\n        aKey = getPrevKey(time);\n        if (!isStill(aKey.time - 0.1, 0.1))\n            return anticipation;\n    }\n    if (aKey.index == numKeys)\n        return anticipation;\n    var anticipationMiddle = aKey.time;\n    var anticipationStart = $bm_sub(anticipationMiddle, anticipationDuration);\n    var anticipationEnd = key(aKey.index + 1).time;\n    var startValue = anticipation;\n    var midValue = $bm_mul($bm_sum($bm_neg(valueAtTime($bm_sum(anticipationMiddle, anticipationDuration))), aKey.value), anticipationQuantity);\n    var endValue = anticipation;\n    if (time < anticipationStart) {\n        return anticipation;\n    } else if (time < anticipationMiddle) {\n        if ($bm_isInstanceOfArray(value)) {\n            for (var i = 0; i < value.length; i++) {\n                anticipation[i] = bezierInterpolation(time, anticipationStart, anticipationMiddle, startValue[i], midValue[i], [\n                    slowOut,\n                    0,\n                    slowIn,\n                    1\n                ]);\n            }\n            return anticipation;\n        } else {\n            return bezierInterpolation(time, anticipationStart, anticipationMiddle, startValue, midValue, [\n                slowOut,\n                0,\n                slowIn,\n                1\n            ]);\n        }\n    } else if (time <= anticipationEnd) {\n        if ($bm_isInstanceOfArray(value)) {\n            for (var i = 0; i < value.length; i++) {\n                anticipation[i] = bezierInterpolation(time, anticipationMiddle, anticipationEnd, midValue[i], endValue[i], [\n                    slowOut,\n                    0,\n                    slowIn,\n                    1\n                ]);\n            }\n            return anticipation;\n        } else {\n            return bezierInterpolation(time, anticipationMiddle, anticipationEnd, midValue, endValue, [\n                slowOut,\n                0,\n                slowIn,\n                1\n            ]);\n        }\n    } else {\n        return anticipation;\n    }\n}\nfunction followThroughAtTime(t) {\n    var fThrough = zeroValue;\n    if (elasticity == 0)\n        return fThrough;\n    var propSpeed;\n    if (!simulate) {\n        if (numKeys < 2)\n            return fThrough;\n        if (nearestKey(t).index == 1)\n            return fThrough;\n        propSpeed = length(velocityAtTime(t));\n        if (propSpeed >= threshold)\n            return fThrough;\n    } else {\n        propSpeed = getPropWorldSpeed(t, thisProperty);\n        if (propSpeed >= threshold)\n            return fThrough;\n    }\n    var fThroughStart = 0;\n    var fThroughTime = 0;\n    if (simulate) {\n        var speedI = getPropWorldSpeed(t, thisProperty);\n        var i = t;\n        while (speedI < threshold && i > 0) {\n            i = $bm_sub(i, $bm_div(thisComp.frameDuration, moBlurPrecision));\n            speedI = getPropWorldSpeed(i, thisProperty);\n        }\n        fThroughStart = i;\n    } else {\n        var fThroughKey = getPrevKey(t);\n        fThroughStart = fThroughKey.time;\n    }\n    if (fThroughStart == 0)\n        return fThrough;\n    fThroughTime = $bm_sub(t, fThroughStart);\n    if (simulate)\n        fThrough = $bm_div(getPropWorldVelocity($bm_sub(fThroughStart, thisComp.frameDuration), thisProperty), 2);\n    else\n        fThrough = $bm_div(velocityAtTime($bm_sub(fThroughStart, thisComp.frameDuration)), 2);\n    if (bounce) {\n        var cycleDamp = Math.exp($bm_mul($bm_mul(fThroughTime, damping), 0.1));\n        var damp = $bm_div(Math.exp($bm_mul(fThroughTime, damping)), $bm_div(elasticity, 2));\n        var cycleDuration = $bm_div(1, $bm_mul(elasticity, 2));\n        cycleDuration = Math.round(timeToFrames(cycleDuration));\n        cycleDuration = framesToTime(cycleDuration);\n        var midDuration = $bm_div(cycleDuration, 2);\n        var maxValue = $bm_mul(fThrough, midDuration);\n        var cycvarime = fThroughTime;\n        var numEndCycles = 1;\n        while (cycvarime > cycleDuration) {\n            cycvarime = $bm_sub(cycvarime, cycleDuration);\n            cycleDuration = $bm_div(cycleDuration, cycleDamp);\n            cycleDuration = Math.round(timeToFrames(cycleDuration));\n            if (cycleDuration < 2) {\n                cycleDuration = 2;\n                numEndCycles++;\n            }\n            cycleDuration = framesToTime(cycleDuration);\n            midDuration = $bm_div(cycleDuration, 2);\n            maxValue = $bm_div($bm_mul(fThrough, midDuration), damp);\n            if (numEndCycles > 100 / damping && maxValue < threshold)\n                return zeroValue;\n        }\n        if (cycvarime < midDuration)\n            fThrough = bezierInterpolation(cycvarime, 0, midDuration, 0, maxValue, [\n                0,\n                0.1,\n                slowIn,\n                1\n            ]);\n        else\n            fThrough = bezierInterpolation(cycvarime, midDuration, cycleDuration, maxValue, 0, [\n                $bm_sub(1, slowIn),\n                0,\n                1,\n                0.9\n            ]);\n    } else {\n        var damp = Math.exp($bm_mul(fThroughTime, damping));\n        var sinus = $bm_mul($bm_mul($bm_mul(elasticity, fThroughTime), 2), Math.PI);\n        sinus = Math.sin(sinus);\n        sinus = $bm_mul($bm_div(0.3, elasticity), sinus);\n        sinus = $bm_div(sinus, damp);\n        if (Math.abs(sinus) < $bm_div(threshold, 100))\n            return 0;\n        fThrough = $bm_mul(fThrough, sinus);\n        if (threshold > 0) {\n            fThrough = $bm_mul(fThrough, $bm_sub(1, $bm_div(propSpeed, threshold)));\n        }\n    }\n    if (bounce) {\n        var prevValue = valueAtTime($bm_sub(fThroughStart, thisComp.frameDuration));\n        var startValue = valueAtTime(fThroughStart);\n        if ($bm_isInstanceOfArray(value)) {\n            for (var i = 0; i < prevValue.length; i++) {\n                if (prevValue[i] > startValue[i])\n                    fThrough[i] = Math.abs(fThrough[i]);\n                if (prevValue[i] < startValue[i])\n                    fThrough[i] = $bm_neg(Math.abs(fThrough[i]));\n            }\n        } else {\n            if (prevValue > startValue)\n                fThrough = Math.abs(fThrough);\n            if (prevValue < startValue)\n                fThrough = $bm_neg(Math.abs(fThrough));\n        }\n    }\n    if (simulate) {\n        if (!isThisPosition) {\n            fThrough = $bm_sum(fThrough, getLayerWorldPos(time, thisLayer));\n            fThrough = $bm_sub(thisLayer.fromWorld(fThrough), thisLayer.anchorPoint);\n        } else if (thisLayer.hasParent) {\n            fThrough = $bm_sum(fThrough, getLayerWorldPos(time, thisLayer.parent));\n            fThrough = $bm_sub(thisLayer.parent.fromWorld(fThrough), thisLayer.parent.anchorPoint);\n        }\n    }\n    return fThrough;\n}\nfunction followThrough() {\n    var propSpeed = length(velocity);\n    if (propSpeed < threshold)\n        return followThroughAtTime($bm_sub(time, overlapDuration));\n    var fThrough = zeroValue;\n    var t = time;\n    while (t > 0) {\n        t = $bm_sub(t, thisComp.frameDuration);\n        if (simulate)\n            propSpeed = getPropWorldSpeed($bm_sub(t, overlapDuration), thisProperty);\n        else\n            propSpeed = length(velocityAtTime(t));\n        if (propSpeed < threshold) {\n            fThrough = followThroughAtTime($bm_sub(t, overlapDuration));\n            break;\n        }\n    }\n    return linear(time, t, $bm_sum(t, $bm_mul(anticipationDuration, 2)), fThrough, zeroValue);\n}\nfunction smartSmooth(axis) {\n    var startKey = nearestKey(time);\n    var endKey = startKey;\n    if (time == startKey.time)\n        return 0;\n    if (time < startKey.time && startKey.index == 1)\n        return 0;\n    if (time > startKey.time && startKey.index == numKeys)\n        return 0;\n    if (time < startKey.time)\n        startKey = key($bm_sub(startKey.index, 1));\n    if (time > startKey.time)\n        endKey = key($bm_sum(startKey.index, 1));\n    var sI = 0.66;\n    var sO = 0.33;\n    var sIV = 1;\n    var sOV = 0;\n    var sVal = startKey.value;\n    var eVal = endKey.value;\n    if ($bm_isInstanceOfArray(value)) {\n        sVal = sVal[axis];\n        eVal = eVal[axis];\n    }\n    var sTime = startKey.time;\n    var eTime = endKey.time;\n    if (isKeyTop(startKey, axis))\n        sO = slowOut;\n    else {\n        var prevKey = key($bm_sub(startKey.index, 1));\n        var pVal = prevKey.value;\n        if ($bm_isInstanceOfArray(value))\n            pVal = pVal[axis];\n        sOV = $bm_div($bm_sub(sVal, pVal), $bm_sub(eVal, pVal));\n    }\n    if (isKeyTop(endKey, axis)) {\n        sI = slowIn;\n        if (endKey.index != numKeys) {\n            var nextKey = key($bm_sum(endKey.index, 1));\n            var nVal = nextKey.value;\n            if ($bm_isInstanceOfArray(value))\n                nVal = nVal[axis];\n            if (Math.abs(nVal - eVal) < 0.01 && doFollowThrough)\n                sI = 1;\n        }\n    } else {\n        var nextKey = key($bm_sum(endKey.index, 1));\n        var nVal = nextKey.value;\n        if ($bm_isInstanceOfArray(value))\n            nVal = nVal[axis];\n        sIV = $bm_div($bm_sub(eVal, sVal), $bm_sub(nVal, sVal));\n    }\n    if (endKey.index == numKeys && doFollowThrough) {\n        sI = 1;\n    }\n    var val = value;\n    if ($bm_isInstanceOfArray(value))\n        val = val[axis];\n    return $bm_sub(bezierInterpolation(time, sTime, eTime, sVal, eVal, [\n        sO,\n        sOV,\n        sI,\n        sIV\n    ]), val);\n}\nfunction overlap() {\n    var ol = zeroValue;\n    if (isThisPosition && !hasParent)\n        return zeroValue;\n    ol = $bm_sub(getPropWorldValue($bm_sub(time, overlapDuration), thisProperty), getPropWorldValue(time, thisProperty));\n    var motionRatio = $bm_div($bm_div(length(zeroValue, ol), thisLayer.width), 2);\n    if (isThisPosition) {\n        var originalDistance = length(valueAtTime(0));\n        motionRatio = $bm_div(length(zeroValue, ol), thisComp.width);\n    }\n    ol = $bm_sum(ol, getPropWorldValue(time, thisProperty));\n    ol = $bm_sum(ol, $bm_mul($bm_mul($bm_sub(getPropWorldValue($bm_sub(time, overlapDuration), thisLayer.anchorPoint), ol), motionRatio), flexibility));\n    ol = thisLayer.fromWorld(ol);\n    if (!isThisPosition)\n        ol = $bm_sub(ol, value);\n    else {\n        ol = linear(flexibility, 0, 100, $bm_div(ol, 2), 0);\n        var prevParentWorldPos = getLayerWorldPos($bm_sub(time, overlapDuration), parent);\n        ol = $bm_sum(ol, $bm_mul($bm_mul($bm_mul(thisLayer.fromWorld(prevParentWorldPos), motionRatio), flexibility), 5));\n    }\n    return ol;\n}\nvar okToGo = false;\nif (simulate && fx.enabled)\n    okToGo = true;\nelse if (numKeys > 1 && fx.enabled)\n    okToGo = true;\nif (okToGo) {\n    var smartSmoothResult = zeroValue;\n    if (doInterpolation) {\n        if ($bm_isInstanceOfArray(value)) {\n            if (value.length == 2)\n                smartSmoothResult = [\n                    smartSmooth(0),\n                    smartSmooth(1)\n                ];\n            else if (value.length == 3)\n                smartSmoothResult = [\n                    smartSmooth(0),\n                    smartSmooth(1),\n                    smartSmooth(2)\n                ];\n            else if (value.length == 4)\n                smartSmoothResult = [\n                    smartSmooth(0),\n                    smartSmooth(1),\n                    smartSmooth(2),\n                    smartSmooth(3)\n                ];\n        } else {\n            smartSmoothResult = smartSmooth(0);\n        }\n    }\n    if (doAnticipation)\n        result = $bm_sum(result, anticipate());\n    result = $bm_sum(result, smartSmoothResult);\n    if (doFollowThrough)\n        result = $bm_sum(result, followThrough());\n    if (doOverlap)\n        result = $bm_sum(result, overlap());\n}\n$bm_rt = result;",
                    "a": 1
                  },
                  "nm": "Transform",
                  "sk": {
                    "a": 0,
                    "k": 0.0,
                    "x": "var $bm_rt;\nvar fx = effect('\u015dlosilo pli pura 2');\nvar doAnticipation = fx(1).value;\nvar doInterpolation = fx(2).value;\nvar doFollowThrough = fx(3).value;\nvar damping = $bm_div(fx(15).value, 10);\nvar elasticity = $bm_div(fx(13).value, 10);\nvar bounce = fx(17).value;\nvar anticipationDuration = fx(5).value;\nvar anticipationQuantity = $bm_div(fx(6).value, 100);\nvar slowIn = $bm_div(fx(9).value, 100);\nvar slowOut = $bm_div(fx(10).value, 100);\nvar spatialMode = fx(21).value;\nvar spatialDoInterpolation = fx(20).value;\nvar moBlurPrecision = fx(32).value;\nvar elasticityRandom = fx(14).value;\nvar dampingRandom = fx(16).value;\nvar softBody = fx(28).value;\nvar flexibility = $bm_div(fx(29).value, 100);\nvar doOverlap = fx(23).value;\nvar overlapDuration = fx(24).value;\nvar overlapRandom = fx(25).value;\nvar threshold = $bm_div($bm_div(1, moBlurPrecision), 1000);\nvar zeroValue;\nif ($bm_isInstanceOfArray(value)) {\n    if (value.length == 2)\n        zeroValue = [\n            0,\n            0\n        ];\n    else if (value.length == 3)\n        zeroValue = [\n            0,\n            0,\n            0\n        ];\n    else if (value.length == 4)\n        zeroValue = [\n            0,\n            0,\n            0,\n            0\n        ];\n} else\n    zeroValue = 0;\nvar isThisSpatial = isSpatial(thisProperty);\nvar isThisPosition = thisProperty === $bm_transform.position;\nvar simulate = false;\nif (isThisSpatial) {\n    doInterpolation = doInterpolation && spatialDoInterpolation;\n    if (isThisPosition && thisProperty.numKeys > 0) {\n        doOverlap = false;\n        simulate = false;\n    } else {\n        simulate = spatialMode == 2;\n        doOverlap = overlapDuration != 0 && doOverlap && simulate;\n    }\n} else {\n    doOverlap = false;\n}\nif (!doOverlap) {\n    overlapDuration = 0;\n}\nif (simulate && softBody && isThisSpatial && !isThisPosition && (doFollowThrough || doOverlap)) {\n    var distanceRatio = $bm_div(length(valueAtTime(0), $bm_transform.anchorPoint), $bm_div(thisLayer.width, 2));\n    distanceRatio = $bm_div($bm_sum(1, $bm_mul(distanceRatio, flexibility)), 2);\n    if (doFollowThrough) {\n        elasticity = $bm_div(elasticity, distanceRatio);\n        damping = $bm_div(damping, distanceRatio);\n    }\n    if (doOverlap) {\n        overlapDuration = $bm_mul(overlapDuration, distanceRatio);\n    }\n}\nseedRandom(0, true);\nif (doFollowThrough) {\n    if (elasticityRandom > 0)\n        elasticity = addNoise(elasticity, elasticityRandom);\n    if (dampingRandom > 0)\n        damping = addNoise(damping, dampingRandom);\n}\nif (doOverlap) {\n    if (doOverlap && overlapRandom > 0)\n        overlapDuration = addNoise(overlapDuration, overlapRandom);\n}\nvar result = value;\nfunction isSpatial(prop) {\n    if (!(prop.value instanceof Array))\n        return false;\n    if (prop.value.length != 2 && prop.value.length != 3)\n        return false;\n    try {\n        if (typeof prop.speed !== 'undefined')\n            return true;\n    } catch (e) {\n        return false;\n    }\n}\nfunction addNoise(val, quantity) {\n    var randomValue = random(0.9, 1.1);\n    var noiseValue = noise($bm_mul(valueAtTime(0), randomValue));\n    noiseValue = $bm_mul(noiseValue, $bm_div(quantity, 100));\n    return $bm_mul(val, $bm_sum(noiseValue, 1));\n}\nfunction isAfterLastKey() {\n    if (numKeys == 0)\n        return false;\n    var nKey = nearestKey(time);\n    return nKey.time <= time && nKey.index == numKeys;\n}\nfunction isStill(t, threshold) {\n    var d = $bm_sub(valueAtTime(t), valueAtTime($bm_sum(t, framesToTime(1))));\n    if ($bm_isInstanceOfArray(d)) {\n        for (var i = 0; i < d.length; i++) {\n            d[i] = Math.abs(d[i]);\n            if (d[i] >= threshold) {\n                return false;\n            }\n        }\n        return true;\n    } else {\n        d = Math.abs(d);\n        return d < threshold;\n    }\n}\nfunction bezierInterpolation(t, tMin, tMax, value1, value2, bezierPoints) {\n    if (arguments.length !== 5 && arguments.length !== 6)\n        return t;\n    var a = $bm_sub(value2, value1);\n    var b = $bm_sub(tMax, tMin);\n    if (b == 0)\n        return t;\n    var c = clamp($bm_div($bm_sub(t, tMin), b), 0, 1);\n    if (!(bezierPoints instanceof Array) || bezierPoints.length !== 4)\n        bezierPoints = [\n            0.33,\n            0,\n            0.66,\n            1\n        ];\n    return $bm_sum($bm_mul(a, h(c, bezierPoints)), value1);\n    function h(f, g) {\n        var x = $bm_mul(3, g[0]);\n        var j = $bm_sub($bm_mul(3, $bm_sub(g[2], g[0])), x);\n        var k = $bm_sub($bm_sub(1, x), j);\n        var l = $bm_mul(3, g[1]);\n        var m = $bm_sub($bm_mul(3, $bm_sub(g[3], g[1])), l);\n        var n = $bm_sub($bm_sub(1, l), m);\n        var d = f;\n        for (var i = 0; i < 5; i++) {\n            var z = $bm_sub($bm_mul(d, $bm_sum(x, $bm_mul(d, $bm_sum(j, $bm_mul(d, k))))), f);\n            if (Math.abs(z) < 0.001)\n                break;\n            d = $bm_sub(d, $bm_div(z, $bm_sum(x, $bm_mul(d, $bm_sum($bm_mul(2, j), $bm_mul($bm_mul(3, k), d))))));\n        }\n        return $bm_mul(d, $bm_sum(l, $bm_mul(d, $bm_sum(m, $bm_mul(d, n)))));\n    }\n}\nfunction getPropWorldSpeed(t, prop) {\n    return length(getPropWorldVelocity(t, prop));\n}\nfunction getPrevKey(t) {\n    if (numKeys == 0)\n        return null;\n    var nKey = nearestKey(t);\n    if (nKey.time <= t)\n        return nKey;\n    if (nKey.index > 1)\n        return key($bm_sub(nKey.index, 1));\n    return null;\n}\nfunction getNextKey(t) {\n    if (numKeys == 0)\n        return null;\n    var nKey = nearestKey(t);\n    if (nKey.time >= t)\n        return nKey;\n    if (nKey.index < numKeys)\n        return key($bm_sum(nKey.index, 1));\n    return null;\n}\nfunction getPropWorldVelocity(t, prop) {\n    return $bm_mul($bm_sub(getPropWorldValue($bm_sum(t, 0.005), prop), getPropWorldValue($bm_sub(t, 0.005), prop)), 100);\n}\nfunction getLayerWorldPos(t, l) {\n    return l.toWorld(l.anchorPoint, t);\n}\nfunction getPropWorldValue(t, prop) {\n    if (isPosition(prop))\n        return getLayerWorldPos(t, thisLayer);\n    return thisLayer.toWorld(prop.valueAtTime(t), t);\n}\nfunction isPosition(prop) {\n    return prop === $bm_transform.position;\n}\nfunction isKeyTop(k, axis) {\n    var prevSpeed = velocityAtTime($bm_sub(k.time, threshold));\n    var nextSpeed = velocityAtTime($bm_sum(k.time, threshold));\n    if ($bm_isInstanceOfArray(value)) {\n        prevSpeed = prevSpeed[axis];\n        nextSpeed = nextSpeed[axis];\n    }\n    if (Math.abs(prevSpeed) < 0.01 || Math.abs(nextSpeed) < 0.01)\n        return true;\n    return $bm_mul(prevSpeed, nextSpeed) < 0;\n}\nfunction anticipate() {\n    var anticipation = zeroValue;\n    if (isAfterLastKey())\n        return anticipation;\n    if (numKeys < 2)\n        return anticipation;\n    var nextKey = getNextKey(time);\n    var aKey = nextKey;\n    if (!isStill(aKey.time - 0.1, 0.1)) {\n        aKey = getPrevKey(time);\n        if (!isStill(aKey.time - 0.1, 0.1))\n            return anticipation;\n    }\n    if (aKey.index == numKeys)\n        return anticipation;\n    var anticipationMiddle = aKey.time;\n    var anticipationStart = $bm_sub(anticipationMiddle, anticipationDuration);\n    var anticipationEnd = key(aKey.index + 1).time;\n    var startValue = anticipation;\n    var midValue = $bm_mul($bm_sum($bm_neg(valueAtTime($bm_sum(anticipationMiddle, anticipationDuration))), aKey.value), anticipationQuantity);\n    var endValue = anticipation;\n    if (time < anticipationStart) {\n        return anticipation;\n    } else if (time < anticipationMiddle) {\n        if ($bm_isInstanceOfArray(value)) {\n            for (var i = 0; i < value.length; i++) {\n                anticipation[i] = bezierInterpolation(time, anticipationStart, anticipationMiddle, startValue[i], midValue[i], [\n                    slowOut,\n                    0,\n                    slowIn,\n                    1\n                ]);\n            }\n            return anticipation;\n        } else {\n            return bezierInterpolation(time, anticipationStart, anticipationMiddle, startValue, midValue, [\n                slowOut,\n                0,\n                slowIn,\n                1\n            ]);\n        }\n    } else if (time <= anticipationEnd) {\n        if ($bm_isInstanceOfArray(value)) {\n            for (var i = 0; i < value.length; i++) {\n                anticipation[i] = bezierInterpolation(time, anticipationMiddle, anticipationEnd, midValue[i], endValue[i], [\n                    slowOut,\n                    0,\n                    slowIn,\n                    1\n                ]);\n            }\n            return anticipation;\n        } else {\n            return bezierInterpolation(time, anticipationMiddle, anticipationEnd, midValue, endValue, [\n                slowOut,\n                0,\n                slowIn,\n                1\n            ]);\n        }\n    } else {\n        return anticipation;\n    }\n}\nfunction followThroughAtTime(t) {\n    var fThrough = zeroValue;\n    if (elasticity == 0)\n        return fThrough;\n    var propSpeed;\n    if (!simulate) {\n        if (numKeys < 2)\n            return fThrough;\n        if (nearestKey(t).index == 1)\n            return fThrough;\n        propSpeed = length(velocityAtTime(t));\n        if (propSpeed >= threshold)\n            return fThrough;\n    } else {\n        propSpeed = getPropWorldSpeed(t, thisProperty);\n        if (propSpeed >= threshold)\n            return fThrough;\n    }\n    var fThroughStart = 0;\n    var fThroughTime = 0;\n    if (simulate) {\n        var speedI = getPropWorldSpeed(t, thisProperty);\n        var i = t;\n        while (speedI < threshold && i > 0) {\n            i = $bm_sub(i, $bm_div(thisComp.frameDuration, moBlurPrecision));\n            speedI = getPropWorldSpeed(i, thisProperty);\n        }\n        fThroughStart = i;\n    } else {\n        var fThroughKey = getPrevKey(t);\n        fThroughStart = fThroughKey.time;\n    }\n    if (fThroughStart == 0)\n        return fThrough;\n    fThroughTime = $bm_sub(t, fThroughStart);\n    if (simulate)\n        fThrough = $bm_div(getPropWorldVelocity($bm_sub(fThroughStart, thisComp.frameDuration), thisProperty), 2);\n    else\n        fThrough = $bm_div(velocityAtTime($bm_sub(fThroughStart, thisComp.frameDuration)), 2);\n    if (bounce) {\n        var cycleDamp = Math.exp($bm_mul($bm_mul(fThroughTime, damping), 0.1));\n        var damp = $bm_div(Math.exp($bm_mul(fThroughTime, damping)), $bm_div(elasticity, 2));\n        var cycleDuration = $bm_div(1, $bm_mul(elasticity, 2));\n        cycleDuration = Math.round(timeToFrames(cycleDuration));\n        cycleDuration = framesToTime(cycleDuration);\n        var midDuration = $bm_div(cycleDuration, 2);\n        var maxValue = $bm_mul(fThrough, midDuration);\n        var cycvarime = fThroughTime;\n        var numEndCycles = 1;\n        while (cycvarime > cycleDuration) {\n            cycvarime = $bm_sub(cycvarime, cycleDuration);\n            cycleDuration = $bm_div(cycleDuration, cycleDamp);\n            cycleDuration = Math.round(timeToFrames(cycleDuration));\n            if (cycleDuration < 2) {\n                cycleDuration = 2;\n                numEndCycles++;\n            }\n            cycleDuration = framesToTime(cycleDuration);\n            midDuration = $bm_div(cycleDuration, 2);\n            maxValue = $bm_div($bm_mul(fThrough, midDuration), damp);\n            if (numEndCycles > 100 / damping && maxValue < threshold)\n                return zeroValue;\n        }\n        if (cycvarime < midDuration)\n            fThrough = bezierInterpolation(cycvarime, 0, midDuration, 0, maxValue, [\n                0,\n                0.1,\n                slowIn,\n                1\n            ]);\n        else\n            fThrough = bezierInterpolation(cycvarime, midDuration, cycleDuration, maxValue, 0, [\n                $bm_sub(1, slowIn),\n                0,\n                1,\n                0.9\n            ]);\n    } else {\n        var damp = Math.exp($bm_mul(fThroughTime, damping));\n        var sinus = $bm_mul($bm_mul($bm_mul(elasticity, fThroughTime), 2), Math.PI);\n        sinus = Math.sin(sinus);\n        sinus = $bm_mul($bm_div(0.3, elasticity), sinus);\n        sinus = $bm_div(sinus, damp);\n        if (Math.abs(sinus) < $bm_div(threshold, 100))\n            return 0;\n        fThrough = $bm_mul(fThrough, sinus);\n        if (threshold > 0) {\n            fThrough = $bm_mul(fThrough, $bm_sub(1, $bm_div(propSpeed, threshold)));\n        }\n    }\n    if (bounce) {\n        var prevValue = valueAtTime($bm_sub(fThroughStart, thisComp.frameDuration));\n        var startValue = valueAtTime(fThroughStart);\n        if ($bm_isInstanceOfArray(value)) {\n            for (var i = 0; i < prevValue.length; i++) {\n                if (prevValue[i] > startValue[i])\n                    fThrough[i] = Math.abs(fThrough[i]);\n                if (prevValue[i] < startValue[i])\n                    fThrough[i] = $bm_neg(Math.abs(fThrough[i]));\n            }\n        } else {\n            if (prevValue > startValue)\n                fThrough = Math.abs(fThrough);\n            if (prevValue < startValue)\n                fThrough = $bm_neg(Math.abs(fThrough));\n        }\n    }\n    if (simulate) {\n        if (!isThisPosition) {\n            fThrough = $bm_sum(fThrough, getLayerWorldPos(time, thisLayer));\n            fThrough = $bm_sub(thisLayer.fromWorld(fThrough), thisLayer.anchorPoint);\n        } else if (thisLayer.hasParent) {\n            fThrough = $bm_sum(fThrough, getLayerWorldPos(time, thisLayer.parent));\n            fThrough = $bm_sub(thisLayer.parent.fromWorld(fThrough), thisLayer.parent.anchorPoint);\n        }\n    }\n    return fThrough;\n}\nfunction followThrough() {\n    var propSpeed = length(velocity);\n    if (propSpeed < threshold)\n        return followThroughAtTime($bm_sub(time, overlapDuration));\n    var fThrough = zeroValue;\n    var t = time;\n    while (t > 0) {\n        t = $bm_sub(t, thisComp.frameDuration);\n        if (simulate)\n            propSpeed = getPropWorldSpeed($bm_sub(t, overlapDuration), thisProperty);\n        else\n            propSpeed = length(velocityAtTime(t));\n        if (propSpeed < threshold) {\n            fThrough = followThroughAtTime($bm_sub(t, overlapDuration));\n            break;\n        }\n    }\n    return linear(time, t, $bm_sum(t, $bm_mul(anticipationDuration, 2)), fThrough, zeroValue);\n}\nfunction smartSmooth(axis) {\n    var startKey = nearestKey(time);\n    var endKey = startKey;\n    if (time == startKey.time)\n        return 0;\n    if (time < startKey.time && startKey.index == 1)\n        return 0;\n    if (time > startKey.time && startKey.index == numKeys)\n        return 0;\n    if (time < startKey.time)\n        startKey = key($bm_sub(startKey.index, 1));\n    if (time > startKey.time)\n        endKey = key($bm_sum(startKey.index, 1));\n    var sI = 0.66;\n    var sO = 0.33;\n    var sIV = 1;\n    var sOV = 0;\n    var sVal = startKey.value;\n    var eVal = endKey.value;\n    if ($bm_isInstanceOfArray(value)) {\n        sVal = sVal[axis];\n        eVal = eVal[axis];\n    }\n    var sTime = startKey.time;\n    var eTime = endKey.time;\n    if (isKeyTop(startKey, axis))\n        sO = slowOut;\n    else {\n        var prevKey = key($bm_sub(startKey.index, 1));\n        var pVal = prevKey.value;\n        if ($bm_isInstanceOfArray(value))\n            pVal = pVal[axis];\n        sOV = $bm_div($bm_sub(sVal, pVal), $bm_sub(eVal, pVal));\n    }\n    if (isKeyTop(endKey, axis)) {\n        sI = slowIn;\n        if (endKey.index != numKeys) {\n            var nextKey = key($bm_sum(endKey.index, 1));\n            var nVal = nextKey.value;\n            if ($bm_isInstanceOfArray(value))\n                nVal = nVal[axis];\n            if (Math.abs(nVal - eVal) < 0.01 && doFollowThrough)\n                sI = 1;\n        }\n    } else {\n        var nextKey = key($bm_sum(endKey.index, 1));\n        var nVal = nextKey.value;\n        if ($bm_isInstanceOfArray(value))\n            nVal = nVal[axis];\n        sIV = $bm_div($bm_sub(eVal, sVal), $bm_sub(nVal, sVal));\n    }\n    if (endKey.index == numKeys && doFollowThrough) {\n        sI = 1;\n    }\n    var val = value;\n    if ($bm_isInstanceOfArray(value))\n        val = val[axis];\n    return $bm_sub(bezierInterpolation(time, sTime, eTime, sVal, eVal, [\n        sO,\n        sOV,\n        sI,\n        sIV\n    ]), val);\n}\nfunction overlap() {\n    var ol = zeroValue;\n    if (isThisPosition && !hasParent)\n        return zeroValue;\n    ol = $bm_sub(getPropWorldValue($bm_sub(time, overlapDuration), thisProperty), getPropWorldValue(time, thisProperty));\n    var motionRatio = $bm_div($bm_div(length(zeroValue, ol), thisLayer.width), 2);\n    if (isThisPosition) {\n        var originalDistance = length(valueAtTime(0));\n        motionRatio = $bm_div(length(zeroValue, ol), thisComp.width);\n    }\n    ol = $bm_sum(ol, getPropWorldValue(time, thisProperty));\n    ol = $bm_sum(ol, $bm_mul($bm_mul($bm_sub(getPropWorldValue($bm_sub(time, overlapDuration), thisLayer.anchorPoint), ol), motionRatio), flexibility));\n    ol = thisLayer.fromWorld(ol);\n    if (!isThisPosition)\n        ol = $bm_sub(ol, value);\n    else {\n        ol = linear(flexibility, 0, 100, $bm_div(ol, 2), 0);\n        var prevParentWorldPos = getLayerWorldPos($bm_sub(time, overlapDuration), parent);\n        ol = $bm_sum(ol, $bm_mul($bm_mul($bm_mul(thisLayer.fromWorld(prevParentWorldPos), motionRatio), flexibility), 5));\n    }\n    return ol;\n}\nvar okToGo = false;\nif (simulate && fx.enabled)\n    okToGo = true;\nelse if (numKeys > 1 && fx.enabled)\n    okToGo = true;\nif (okToGo) {\n    var smartSmoothResult = zeroValue;\n    if (doInterpolation) {\n        if ($bm_isInstanceOfArray(value)) {\n            if (value.length == 2)\n                smartSmoothResult = [\n                    smartSmooth(0),\n                    smartSmooth(1)\n                ];\n            else if (value.length == 3)\n                smartSmoothResult = [\n                    smartSmooth(0),\n                    smartSmooth(1),\n                    smartSmooth(2)\n                ];\n            else if (value.length == 4)\n                smartSmoothResult = [\n                    smartSmooth(0),\n                    smartSmooth(1),\n                    smartSmooth(2),\n                    smartSmooth(3)\n                ];\n        } else {\n            smartSmoothResult = smartSmooth(0);\n        }\n    }\n    if (doAnticipation)\n        result = $bm_sum(result, anticipate());\n    result = $bm_sum(result, smartSmoothResult);\n    if (doFollowThrough)\n        result = $bm_sum(result, followThrough());\n    if (doOverlap)\n        result = $bm_sum(result, overlap());\n}\n$bm_rt = result;"
                  },
                  "sa": { "a": 0, "k": 0.0 }
                }
              ]
            },
            {
              "ty": "gr",
              "nm": "Group 4",
              "bm": 0,
              "mn": "ADBE Vector Group",
              "it": [
                {
                  "ty": "sh",
                  "nm": "Path 1",
                  "mn": "ADBE Vector Shape - Group",
                  "ind": 0,
                  "ks": {
                    "k": {
                      "i": [
                        [-0.255, 1.411],
                        [1.294, -1.068],
                        [1.457, 0.831],
                        [-1.12, 0.895]
                      ],
                      "o": [
                        [0.54, 1.588],
                        [-1.294, 1.068],
                        [1.432, 0.062],
                        [1.12, -0.895]
                      ],
                      "v": [
                        [-80.414, -125.111],
                        [-81.706, -120.559],
                        [-86.421, -120.153],
                        [-82.524, -121.686]
                      ],
                      "c": true
                    },
                    "a": 0
                  }
                },
                {
                  "ty": "fl",
                  "nm": "Fill 1",
                  "bm": 0,
                  "mn": "ADBE Vector Graphic - Fill",
                  "c": { "a": 0, "k": [1.0, 1.0, 1.0, 1.0] },
                  "o": { "a": 0, "k": 100.0 },
                  "r": 1
                },
                {
                  "ty": "tr",
                  "o": { "a": 0, "k": 100.0 },
                  "r": { "a": 0, "k": 0.0 },
                  "p": { "a": 0, "k": [0.0, 0.0] },
                  "a": { "a": 0, "k": [0.0, 0.0] },
                  "s": { "a": 0, "k": [100.0, 100.0] },
                  "nm": "Transform",
                  "sk": { "a": 0, "k": 0.0 },
                  "sa": { "a": 0, "k": 0.0 }
                }
              ]
            },
            {
              "ty": "gr",
              "nm": "Group 5",
              "bm": 0,
              "mn": "ADBE Vector Group",
              "it": [
                {
                  "ty": "sh",
                  "nm": "Path 1",
                  "mn": "ADBE Vector Shape - Group",
                  "ind": 0,
                  "ks": {
                    "k": {
                      "i": [
                        [0.061, -1.447],
                        [1.447, 0.061],
                        [-0.061, 1.447],
                        [-1.447, -0.061]
                      ],
                      "o": [
                        [-0.061, 1.447],
                        [-1.447, -0.061],
                        [0.061, -1.447],
                        [1.447, 0.061]
                      ],
                      "v": [
                        [-85.256, -126.868],
                        [-87.986, -124.358],
                        [-90.495, -127.089],
                        [-87.765, -129.598]
                      ],
                      "c": true
                    },
                    "a": 0
                  }
                },
                {
                  "ty": "fl",
                  "nm": "Fill 1",
                  "bm": 0,
                  "mn": "ADBE Vector Graphic - Fill",
                  "c": { "a": 0, "k": [1.0, 1.0, 1.0, 1.0] },
                  "o": { "a": 0, "k": 100.0 },
                  "r": 1
                },
                {
                  "ty": "tr",
                  "o": { "a": 0, "k": 100.0 },
                  "r": { "a": 0, "k": 0.0 },
                  "p": { "a": 0, "k": [0.0, 0.0] },
                  "a": { "a": 0, "k": [0.0, 0.0] },
                  "s": { "a": 0, "k": [100.0, 100.0] },
                  "nm": "Transform",
                  "sk": { "a": 0, "k": 0.0 },
                  "sa": { "a": 0, "k": 0.0 }
                }
              ]
            },
            {
              "ty": "gr",
              "nm": "Group 6",
              "bm": 0,
              "mn": "ADBE Vector Group",
              "it": [
                {
                  "ty": "sh",
                  "nm": "Path 1",
                  "mn": "ADBE Vector Shape - Group",
                  "ind": 0,
                  "ks": {
                    "k": {
                      "i": [
                        [0.179, -4.229],
                        [4.229, 0.179],
                        [-0.179, 4.229],
                        [-4.229, -0.179]
                      ],
                      "o": [
                        [-0.179, 4.229],
                        [-4.229, -0.179],
                        [0.179, -4.229],
                        [4.229, 0.179]
                      ],
                      "v": [
                        [-77.908, -124.518],
                        [-85.889, -117.184],
                        [-93.223, -125.165],
                        [-85.242, -132.499]
                      ],
                      "c": true
                    },
                    "a": 0
                  }
                },
                {
                  "ty": "st",
                  "nm": "Stroke 1",
                  "bm": 0,
                  "mn": "ADBE Vector Graphic - Stroke",
                  "lc": 2,
                  "lj": 2,
                  "o": { "a": 0, "k": 100.0 },
                  "w": { "a": 0, "k": 0.598 },
                  "c": { "a": 0, "k": [0.0, 0.0, 0.0, 1.0] }
                },
                {
                  "ty": "fl",
                  "nm": "Fill 1",
                  "bm": 0,
                  "mn": "ADBE Vector Graphic - Fill",
                  "c": { "a": 0, "k": [0.0, 0.0, 0.0, 1.0] },
                  "o": { "a": 0, "k": 100.0 },
                  "r": 1
                },
                {
                  "ty": "tr",
                  "o": { "a": 0, "k": 100.0 },
                  "r": { "a": 0, "k": 0.0 },
                  "p": { "a": 0, "k": [0.0, 0.0] },
                  "a": { "a": 0, "k": [0.0, 0.0] },
                  "s": { "a": 0, "k": [100.0, 100.0] },
                  "nm": "Transform",
                  "sk": { "a": 0, "k": 0.0 },
                  "sa": { "a": 0, "k": 0.0 }
                }
              ]
            },
            {
              "ty": "tr",
              "o": { "a": 0, "k": 100.0 },
              "r": { "a": 0, "k": 0.0 },
              "p": {
                "k": [
                  {
                    "i": { "x": 0.667, "y": 1.0 },
                    "o": { "x": 0.333, "y": 0.0 },
                    "t": 36,
                    "s": [-61, -124],
                    "ti": [1.333, 0],
                    "to": [-1.333, 0]
                  },
                  { "t": 44, "s": [-69, -124] }
                ],
                "a": 1
              },
              "a": { "a": 0, "k": [-69.0, -124.0] },
              "s": { "a": 0, "k": [100.0, 100.0] },
              "nm": "Transform",
              "sk": { "a": 0, "k": 0.0 },
              "sa": { "a": 0, "k": 0.0 }
            }
          ]
        },
        {
          "ty": "gr",
          "nm": "Group 2",
          "bm": 0,
          "mn": "ADBE Vector Group",
          "it": [
            {
              "ty": "gr",
              "nm": "Group 1",
              "bm": 0,
              "mn": "ADBE Vector Group",
              "it": [
                {
                  "ty": "gr",
                  "nm": "Group 1",
                  "bm": 0,
                  "mn": "ADBE Vector Group",
                  "it": [
                    {
                      "ty": "sh",
                      "nm": "Path 1",
                      "mn": "ADBE Vector Shape - Group",
                      "ind": 0,
                      "ks": {
                        "k": {
                          "i": [
                            [1.65, -1.114],
                            [0.147, 2.23],
                            [-2.176, 0.512],
                            [-0.124, -1.987]
                          ],
                          "o": [
                            [-2.224, -0.222],
                            [-0.147, -2.23],
                            [1.776, 0.9],
                            [0.124, 1.987]
                          ],
                          "v": [
                            [0.203, -75.69],
                            [-4.083, -80.124],
                            [-0.414, -85.082],
                            [2.433, -80.452]
                          ],
                          "c": true
                        },
                        "a": 0
                      }
                    },
                    {
                      "ty": "st",
                      "nm": "Stroke 1",
                      "bm": 0,
                      "mn": "ADBE Vector Graphic - Stroke",
                      "lc": 2,
                      "lj": 2,
                      "o": { "a": 0, "k": 100.0 },
                      "w": { "a": 0, "k": 0.684 },
                      "c": { "a": 0, "k": [0.0, 0.0, 0.0, 1.0] }
                    },
                    {
                      "ty": "fl",
                      "nm": "Fill 1",
                      "bm": 0,
                      "mn": "ADBE Vector Graphic - Fill",
                      "c": { "a": 0, "k": [1.0, 1.0, 1.0, 1.0] },
                      "o": { "a": 0, "k": 100.0 },
                      "r": 1
                    },
                    {
                      "ty": "tr",
                      "o": { "a": 0, "k": 100.0 },
                      "r": { "a": 0, "k": 0.0 },
                      "p": { "a": 0, "k": [0.0, 0.0] },
                      "a": { "a": 0, "k": [0.0, 0.0] },
                      "s": { "a": 0, "k": [100.0, 100.0] },
                      "nm": "Transform",
                      "sk": { "a": 0, "k": 0.0 },
                      "sa": { "a": 0, "k": 0.0 }
                    }
                  ]
                },
                {
                  "ty": "gr",
                  "nm": "Group 2",
                  "bm": 0,
                  "mn": "ADBE Vector Group",
                  "it": [
                    {
                      "ty": "sh",
                      "nm": "Path 1",
                      "mn": "ADBE Vector Shape - Group",
                      "ind": 0,
                      "ks": {
                        "k": {
                          "i": [
                            [0.0, 0.0],
                            [0.0, 0.0],
                            [-1.9, -0.009],
                            [0.0, 0.0],
                            [-0.006, 1.922],
                            [0.0, 0.0]
                          ],
                          "o": [
                            [0.0, 0.0],
                            [0.019, 1.9],
                            [0.0, 0.0],
                            [1.922, 0.009],
                            [0.0, 0.0],
                            [0.0, 0.0]
                          ],
                          "v": [
                            [-7.228, -98.217],
                            [-6.928, -68.292],
                            [-3.469, -64.851],
                            [-3.469, -64.851],
                            [0.024, -68.316],
                            [0.112, -96.766]
                          ],
                          "c": false
                        },
                        "a": 0
                      }
                    },
                    {
                      "ty": "fl",
                      "nm": "Fill 1",
                      "bm": 0,
                      "mn": "ADBE Vector Graphic - Fill",
                      "c": { "a": 0, "k": [0.0, 0.0, 0.0, 1.0] },
                      "o": { "a": 0, "k": 100.0 },
                      "r": 1
                    },
                    {
                      "ty": "tr",
                      "o": { "a": 0, "k": 100.0 },
                      "r": { "a": 0, "k": 0.0 },
                      "p": { "a": 0, "k": [0.0, 0.0] },
                      "a": { "a": 0, "k": [0.0, 0.0] },
                      "s": { "a": 0, "k": [100.0, 100.0] },
                      "nm": "Transform",
                      "sk": { "a": 0, "k": 0.0 },
                      "sa": { "a": 0, "k": 0.0 }
                    }
                  ]
                },
                {
                  "ty": "gr",
                  "nm": "Group 3",
                  "bm": 0,
                  "mn": "ADBE Vector Group",
                  "it": [
                    {
                      "ty": "sh",
                      "nm": "Path 1",
                      "mn": "ADBE Vector Shape - Group",
                      "ind": 0,
                      "ks": {
                        "k": {
                          "i": [
                            [-2.93, 0.026],
                            [-5.568, -1.388],
                            [-0.784, -2.875],
                            [1.697, -1.388],
                            [2.165, -0.342],
                            [5.859, 3.263],
                            [-0.743, 3.254]
                          ],
                          "o": [
                            [5.738, -0.051],
                            [2.891, 0.721],
                            [0.577, 2.115],
                            [-1.697, 1.388],
                            [-6.624, 1.047],
                            [-2.413, -1.344],
                            [0.826, -3.616]
                          ],
                          "v": [
                            [-21.53, -88.633],
                            [-4.48, -86.616],
                            [2.459, -81.697],
                            [0.255, -75.884],
                            [-5.806, -73.54],
                            [-25.253, -76.992],
                            [-30.523, -84.47]
                          ],
                          "c": true
                        },
                        "a": 0
                      }
                    },
                    {
                      "ty": "st",
                      "nm": "Stroke 1",
                      "bm": 0,
                      "mn": "ADBE Vector Graphic - Stroke",
                      "lc": 2,
                      "lj": 2,
                      "o": { "a": 0, "k": 100.0 },
                      "w": { "a": 0, "k": 0.684 },
                      "c": { "a": 0, "k": [0.0, 0.0, 0.0, 1.0] }
                    },
                    {
                      "ty": "fl",
                      "nm": "Fill 1",
                      "bm": 0,
                      "mn": "ADBE Vector Graphic - Fill",
                      "c": { "a": 0, "k": [1.0, 1.0, 1.0, 1.0] },
                      "o": { "a": 0, "k": 100.0 },
                      "r": 1
                    },
                    {
                      "ty": "tr",
                      "o": { "a": 0, "k": 100.0 },
                      "r": { "a": 0, "k": 0.0 },
                      "p": { "a": 0, "k": [0.0, 0.0] },
                      "a": { "a": 0, "k": [0.0, 0.0] },
                      "s": { "a": 0, "k": [100.0, 100.0] },
                      "nm": "Transform",
                      "sk": { "a": 0, "k": 0.0 },
                      "sa": { "a": 0, "k": 0.0 }
                    }
                  ]
                },
                {
                  "ty": "gr",
                  "nm": "Group 4",
                  "bm": 0,
                  "mn": "ADBE Vector Group",
                  "it": [
                    {
                      "ty": "sh",
                      "nm": "Path 1",
                      "mn": "ADBE Vector Shape - Group",
                      "ind": 0,
                      "ks": {
                        "k": {
                          "i": [
                            [8.109, -4.774],
                            [4.978, 8.457],
                            [-8.109, 4.774],
                            [-4.978, -8.457]
                          ],
                          "o": [
                            [-8.109, 4.774],
                            [-4.978, -8.457],
                            [8.109, -4.774],
                            [4.978, 8.457]
                          ],
                          "v": [
                            [10.075, -104.672],
                            [-13.623, -111.341],
                            [-7.954, -135.297],
                            [15.743, -128.629]
                          ],
                          "c": true
                        },
                        "a": 0
                      }
                    },
                    {
                      "ty": "st",
                      "nm": "Stroke 1",
                      "bm": 0,
                      "mn": "ADBE Vector Graphic - Stroke",
                      "lc": 2,
                      "lj": 2,
                      "o": { "a": 0, "k": 100.0 },
                      "w": { "a": 0, "k": 0.684 },
                      "c": { "a": 0, "k": [0.0, 0.0, 0.0, 1.0] }
                    },
                    {
                      "ty": "fl",
                      "nm": "Fill 1",
                      "bm": 0,
                      "mn": "ADBE Vector Graphic - Fill",
                      "c": { "a": 0, "k": [1.0, 1.0, 1.0, 1.0] },
                      "o": { "a": 0, "k": 100.0 },
                      "r": 1
                    },
                    {
                      "ty": "tr",
                      "o": { "a": 0, "k": 100.0 },
                      "r": { "a": 0, "k": 0.0 },
                      "p": { "a": 0, "k": [0.0, 0.0] },
                      "a": { "a": 0, "k": [0.0, 0.0] },
                      "s": { "a": 0, "k": [100.0, 100.0] },
                      "nm": "Transform",
                      "sk": { "a": 0, "k": 0.0 },
                      "sa": { "a": 0, "k": 0.0 }
                    }
                  ]
                },
                {
                  "ty": "gr",
                  "nm": "Group 5",
                  "bm": 0,
                  "mn": "ADBE Vector Group",
                  "it": [
                    {
                      "ty": "sh",
                      "nm": "Path 1",
                      "mn": "ADBE Vector Shape - Group",
                      "ind": 0,
                      "ks": {
                        "k": {
                          "i": [
                            [10.949, -6.445],
                            [6.58, 11.177],
                            [-10.949, 6.445],
                            [-6.58, -11.177]
                          ],
                          "o": [
                            [-10.949, 6.445],
                            [-6.58, -11.177],
                            [10.949, -6.445],
                            [6.58, 11.177]
                          ],
                          "v": [
                            [12.352, -99.877],
                            [-19.385, -108.444],
                            [-11.474, -140.351],
                            [20.263, -131.784]
                          ],
                          "c": true
                        },
                        "a": 0
                      }
                    },
                    {
                      "ty": "st",
                      "nm": "Stroke 1",
                      "bm": 0,
                      "mn": "ADBE Vector Graphic - Stroke",
                      "lc": 2,
                      "lj": 2,
                      "o": { "a": 0, "k": 100.0 },
                      "w": { "a": 0, "k": 0.684 },
                      "c": { "a": 0, "k": [0.0, 0.0, 0.0, 1.0] }
                    },
                    {
                      "ty": "fl",
                      "nm": "Fill 1",
                      "bm": 0,
                      "mn": "ADBE Vector Graphic - Fill",
                      "c": { "a": 0, "k": [1.0, 1.0, 1.0, 1.0] },
                      "o": { "a": 0, "k": 100.0 },
                      "r": 1
                    },
                    {
                      "ty": "tr",
                      "o": { "a": 0, "k": 100.0 },
                      "r": { "a": 0, "k": 0.0 },
                      "p": { "a": 0, "k": [0.0, 0.0] },
                      "a": { "a": 0, "k": [0.0, 0.0] },
                      "s": { "a": 0, "k": [100.0, 100.0] },
                      "nm": "Transform",
                      "sk": { "a": 0, "k": 0.0 },
                      "sa": { "a": 0, "k": 0.0 }
                    }
                  ]
                },
                {
                  "ty": "tr",
                  "o": { "a": 0, "k": 100.0 },
                  "r": { "a": 0, "k": 0.0 },
                  "p": { "a": 0, "k": [0.0, 0.0] },
                  "a": { "a": 0, "k": [0.0, 0.0] },
                  "s": { "a": 0, "k": [100.0, 100.0] },
                  "nm": "Transform",
                  "sk": { "a": 0, "k": 0.0 },
                  "sa": { "a": 0, "k": 0.0 }
                }
              ]
            },
            {
              "ty": "tr",
              "o": { "a": 0, "k": 100.0 },
              "r": {
                "a": 1,
                "k": [
                  {
                    "i": { "x": [0.667], "y": [1] },
                    "o": { "x": [0.333], "y": [0] },
                    "t": 44,
                    "s": [0.0]
                  },
                  { "t": 53, "s": [-72.0] }
                ]
              },
              "p": { "a": 0, "k": [-31.527, -84.395] },
              "a": { "a": 0, "k": [-31.527, -84.395] },
              "s": { "a": 0, "k": [100.0, 100.0] },
              "nm": "Transform",
              "sk": { "a": 0, "k": 0.0 },
              "sa": { "a": 0, "k": 0.0 }
            }
          ]
        },
        {
          "ty": "gr",
          "nm": "Group 3",
          "bm": 0,
          "mn": "ADBE Vector Group",
          "it": [
            {
              "ty": "gr",
              "nm": "Group 1",
              "bm": 0,
              "mn": "ADBE Vector Group",
              "it": [
                {
                  "ty": "gr",
                  "nm": "Group 1",
                  "bm": 0,
                  "mn": "ADBE Vector Group",
                  "it": [
                    {
                      "ty": "gr",
                      "nm": "Group 1",
                      "bm": 0,
                      "mn": "ADBE Vector Group",
                      "it": [
                        {
                          "ty": "sh",
                          "nm": "Path 1",
                          "mn": "ADBE Vector Shape - Group",
                          "ind": 0,
                          "ks": {
                            "k": {
                              "i": [
                                [0.0, 0.0],
                                [0.592, 4.468],
                                [-2.442, 3.788]
                              ],
                              "o": [
                                [-3.345, -3.021],
                                [-0.592, -4.468],
                                [0.0, 0.0]
                              ],
                              "v": [
                                [-109.724, -131.378],
                                [-115.886, -143.1],
                                [-112.99, -156.023]
                              ],
                              "c": false
                            },
                            "a": 0
                          }
                        },
                        {
                          "ty": "st",
                          "nm": "Stroke 1",
                          "bm": 0,
                          "mn": "ADBE Vector Graphic - Stroke",
                          "lc": 2,
                          "lj": 2,
                          "o": { "a": 0, "k": 100.0 },
                          "w": { "a": 0, "k": 0.684 },
                          "c": { "a": 0, "k": [0.0, 0.0, 0.0, 1.0] }
                        },
                        {
                          "ty": "tr",
                          "o": { "a": 0, "k": 100.0 },
                          "r": { "a": 0, "k": 0.0 },
                          "p": { "a": 0, "k": [0.0, 0.0] },
                          "a": { "a": 0, "k": [0.0, 0.0] },
                          "s": { "a": 0, "k": [100.0, 100.0] },
                          "nm": "Transform",
                          "sk": { "a": 0, "k": 0.0 },
                          "sa": { "a": 0, "k": 0.0 }
                        }
                      ]
                    },
                    {
                      "ty": "gr",
                      "nm": "Group 2",
                      "bm": 0,
                      "mn": "ADBE Vector Group",
                      "it": [
                        {
                          "ty": "sh",
                          "nm": "Path 1",
                          "mn": "ADBE Vector Shape - Group",
                          "ind": 0,
                          "ks": {
                            "k": {
                              "i": [
                                [0.0, -2.442],
                                [2.442, 0.0],
                                [0.0, 2.442],
                                [-2.442, 0.0]
                              ],
                              "o": [
                                [0.0, 2.442],
                                [-2.442, 0.0],
                                [0.0, -2.442],
                                [2.442, 0.0]
                              ],
                              "v": [
                                [-106.732, -160.506],
                                [-111.154, -156.084],
                                [-115.575, -160.506],
                                [-111.154, -164.927]
                              ],
                              "c": true
                            },
                            "a": 0
                          }
                        },
                        {
                          "ty": "fl",
                          "nm": "Fill 1",
                          "bm": 0,
                          "mn": "ADBE Vector Graphic - Fill",
                          "c": { "a": 0, "k": [0.0, 0.0, 0.0, 1.0] },
                          "o": { "a": 0, "k": 100.0 },
                          "r": 1
                        },
                        {
                          "ty": "tr",
                          "o": { "a": 0, "k": 100.0 },
                          "r": { "a": 0, "k": 0.0 },
                          "p": { "a": 0, "k": [0.0, 0.0] },
                          "a": { "a": 0, "k": [0.0, 0.0] },
                          "s": { "a": 0, "k": [100.0, 100.0] },
                          "nm": "Transform",
                          "sk": { "a": 0, "k": 0.0 },
                          "sa": { "a": 0, "k": 0.0 }
                        }
                      ]
                    },
                    {
                      "ty": "tr",
                      "o": { "a": 0, "k": 100.0 },
                      "r": {
                        "a": 1,
                        "k": [
                          {
                            "i": { "x": [0.667], "y": [1] },
                            "o": { "x": [0.333], "y": [0] },
                            "t": 36,
                            "s": [0.0]
                          },
                          {
                            "i": { "x": [0.667], "y": [1] },
                            "o": { "x": [0.333], "y": [0] },
                            "t": 54.25,
                            "s": [-10.0]
                          },
                          {
                            "i": { "x": [0.667], "y": [1] },
                            "o": { "x": [0.333], "y": [0] },
                            "t": 72.499,
                            "s": [0.0]
                          },
                          {
                            "i": { "x": [0.667], "y": [1] },
                            "o": { "x": [0.333], "y": [0] },
                            "t": 90.75,
                            "s": [-10.0]
                          },
                          { "t": 109, "s": [0.0] }
                        ]
                      },
                      "p": { "a": 0, "k": [-109.75, -131.25] },
                      "a": { "a": 0, "k": [-109.75, -131.25] },
                      "s": { "a": 0, "k": [100.0, 100.0] },
                      "nm": "Transform",
                      "sk": { "a": 0, "k": 0.0 },
                      "sa": { "a": 0, "k": 0.0 }
                    }
                  ]
                },
                {
                  "ty": "gr",
                  "nm": "Group 2",
                  "bm": 0,
                  "mn": "ADBE Vector Group",
                  "it": [
                    {
                      "ty": "gr",
                      "nm": "Group 1",
                      "bm": 0,
                      "mn": "ADBE Vector Group",
                      "it": [
                        {
                          "ty": "sh",
                          "nm": "Path 1",
                          "mn": "ADBE Vector Shape - Group",
                          "ind": 0,
                          "ks": {
                            "k": {
                              "i": [
                                [0.0, 0.0],
                                [-6.285, 0.0],
                                [0.0, 6.285]
                              ],
                              "o": [
                                [0.0, 6.285],
                                [6.285, 0.0],
                                [0.0, 0.0]
                              ],
                              "v": [
                                [-81.924, -106.62],
                                [-70.544, -95.24],
                                [-59.164, -106.62]
                              ],
                              "c": true
                            },
                            "a": 0
                          }
                        },
                        {
                          "ty": "fl",
                          "nm": "Fill 1",
                          "bm": 0,
                          "mn": "ADBE Vector Graphic - Fill",
                          "c": { "a": 0, "k": [0.0, 0.0, 0.0, 1.0] },
                          "o": { "a": 0, "k": 100.0 },
                          "r": 1
                        },
                        {
                          "ty": "tr",
                          "o": { "a": 0, "k": 100.0 },
                          "r": { "a": 0, "k": 0.0 },
                          "p": { "a": 0, "k": [-70.342, -100.926] },
                          "a": { "a": 0, "k": [-70.342, -100.926] },
                          "s": {
                            "k": [
                              {
                                "i": { "x": [0.667, 0.667], "y": [1.0, 1.0] },
                                "o": { "x": [0.333, 0.333], "y": [0.0, 0.0] },
                                "t": 33,
                                "s": [100, 100]
                              },
                              {
                                "i": { "x": [0.667, 0.667], "y": [1.0, 1.0] },
                                "o": { "x": [0.333, 0.333], "y": [0.0, 0.0] },
                                "t": 40,
                                "s": [57.182, 37.495]
                              },
                              {
                                "i": { "x": [0.667, 0.667], "y": [1.0, 1.0] },
                                "o": { "x": [0.333, 0.333], "y": [0.0, 0.0] },
                                "t": 47,
                                "s": [100, 100]
                              },
                              {
                                "i": { "x": [0.667, 0.667], "y": [1.0, 1.0] },
                                "o": { "x": [0.333, 0.333], "y": [0.0, 0.0] },
                                "t": 55,
                                "s": [57.182, 37.495]
                              },
                              {
                                "i": { "x": [0.667, 0.667], "y": [1.0, 1.0] },
                                "o": { "x": [0.333, 0.333], "y": [0.0, 0.0] },
                                "t": 62,
                                "s": [100, 100]
                              },
                              {
                                "i": { "x": [0.667, 0.667], "y": [1.0, 1.0] },
                                "o": { "x": [0.333, 0.333], "y": [0.0, 0.0] },
                                "t": 70,
                                "s": [57.182, 37.495]
                              },
                              {
                                "i": { "x": [0.667, 0.667], "y": [1.0, 1.0] },
                                "o": { "x": [0.333, 0.333], "y": [0.0, 0.0] },
                                "t": 77,
                                "s": [100, 100]
                              },
                              {
                                "i": { "x": [0.667, 0.667], "y": [1.0, 1.0] },
                                "o": { "x": [0.333, 0.333], "y": [0.0, 0.0] },
                                "t": 84,
                                "s": [57.182, 37.495]
                              },
                              {
                                "i": { "x": [0.667, 0.667], "y": [1.0, 1.0] },
                                "o": { "x": [0.333, 0.333], "y": [0.0, 0.0] },
                                "t": 92,
                                "s": [100, 100]
                              },
                              {
                                "i": { "x": [0.667, 0.667], "y": [1.0, 1.0] },
                                "o": { "x": [0.333, 0.333], "y": [0.0, 0.0] },
                                "t": 99,
                                "s": [57.182, 37.495]
                              },
                              { "t": 107, "s": [100, 100] }
                            ],
                            "a": 1
                          },
                          "nm": "Transform",
                          "sk": { "a": 0, "k": 0.0 },
                          "sa": { "a": 0, "k": 0.0 }
                        }
                      ]
                    },
                    {
                      "ty": "gr",
                      "nm": "Group 2",
                      "bm": 0,
                      "mn": "ADBE Vector Group",
                      "it": [
                        {
                          "ty": "gr",
                          "nm": "Group 1",
                          "bm": 0,
                          "mn": "ADBE Vector Group",
                          "it": [
                            {
                              "ty": "sh",
                              "nm": "Path 1",
                              "mn": "ADBE Vector Shape - Group",
                              "ind": 0,
                              "ks": {
                                "k": {
                                  "i": [
                                    [-1.552, 1.744],
                                    [-3.772, 0.81],
                                    [-3.858, 0.004],
                                    [-3.852, 0.004],
                                    [-2.802, -0.924],
                                    [-1.663, -3.068],
                                    [4.18, -2.892],
                                    [2.42, -0.551],
                                    [10.051, 1.643],
                                    [2.897, 1.506],
                                    [0.675, 0.728],
                                    [0.269, 0.921],
                                    [-0.132, 1.155]
                                  ],
                                  "o": [
                                    [2.565, -2.882],
                                    [3.772, -0.81],
                                    [3.852, -0.004],
                                    [2.951, -0.003],
                                    [3.314, 1.093],
                                    [2.267, 4.181],
                                    [-2.041, 1.412],
                                    [-9.93, 2.26],
                                    [-3.196, -0.522],
                                    [-0.881, -0.458],
                                    [-0.643, -0.694],
                                    [-0.326, -1.116],
                                    [0.267, -2.342]
                                  ],
                                  "v": [
                                    [-94.643, -130.65],
                                    [-84.613, -136.029],
                                    [-73.092, -136.85],
                                    [-61.534, -136.861],
                                    [-52.771, -135.934],
                                    [-44.928, -129.378],
                                    [-46.841, -117.842],
                                    [-53.749, -115.191],
                                    [-84.099, -114.254],
                                    [-93.461, -116.944],
                                    [-95.795, -118.527],
                                    [-97.33, -120.948],
                                    [-97.618, -124.394]
                                  ],
                                  "c": true
                                },
                                "a": 0
                              }
                            },
                            {
                              "ty": "st",
                              "nm": "Stroke 1",
                              "bm": 0,
                              "mn": "ADBE Vector Graphic - Stroke",
                              "lc": 2,
                              "lj": 2,
                              "o": { "a": 0, "k": 100.0 },
                              "w": { "a": 0, "k": 0.684 },
                              "c": { "a": 0, "k": [0.0, 0.0, 0.0, 1.0] }
                            },
                            {
                              "ty": "fl",
                              "nm": "Fill 1",
                              "bm": 0,
                              "mn": "ADBE Vector Graphic - Fill",
                              "c": { "a": 0, "k": [1.0, 1.0, 1.0, 1.0] },
                              "o": { "a": 0, "k": 100.0 },
                              "r": 1
                            },
                            {
                              "ty": "tr",
                              "o": { "a": 0, "k": 100.0 },
                              "r": { "a": 0, "k": 0.0 },
                              "p": { "a": 0, "k": [0.0, 0.0] },
                              "a": { "a": 0, "k": [0.0, 0.0] },
                              "s": { "a": 0, "k": [100.0, 100.0] },
                              "nm": "Transform",
                              "sk": { "a": 0, "k": 0.0 },
                              "sa": { "a": 0, "k": 0.0 }
                            }
                          ]
                        },
                        {
                          "ty": "tr",
                          "o": { "a": 0, "k": 100.0 },
                          "r": { "a": 0, "k": 0.0 },
                          "p": { "a": 0, "k": [0.0, 0.0] },
                          "a": { "a": 0, "k": [0.0, 0.0] },
                          "s": { "a": 0, "k": [100.0, 100.0] },
                          "nm": "Transform",
                          "sk": { "a": 0, "k": 0.0 },
                          "sa": { "a": 0, "k": 0.0 }
                        }
                      ]
                    },
                    {
                      "ty": "gr",
                      "nm": "Group 3",
                      "bm": 0,
                      "mn": "ADBE Vector Group",
                      "it": [
                        {
                          "ty": "sh",
                          "nm": "Path 1",
                          "mn": "ADBE Vector Shape - Group",
                          "ind": 0,
                          "ks": {
                            "k": {
                              "i": [
                                [12.972, 11.418],
                                [9.535, -0.606],
                                [0.0, 0.0],
                                [2.067, -16.374],
                                [0.0, 0.0],
                                [-12.108, -1.257],
                                [-12.008, 2.493],
                                [-0.062, 10.04]
                              ],
                              "o": [
                                [-6.681, -5.881],
                                [0.0, 0.0],
                                [-16.471, 1.047],
                                [0.0, 0.0],
                                [-1.524, 12.078],
                                [11.625, 1.207],
                                [10.054, -2.087],
                                [0.0, 0.0]
                              ],
                              "v": [
                                [-47.48, -147.683],
                                [-72.568, -156.352],
                                [-72.569, -156.352],
                                [-104.511, -126.333],
                                [-106.407, -111.316],
                                [-87.093, -87.05],
                                [-51.64, -89.009],
                                [-34.508, -110.032]
                              ],
                              "c": true
                            },
                            "a": 0
                          }
                        },
                        {
                          "ty": "st",
                          "nm": "Stroke 1",
                          "bm": 0,
                          "mn": "ADBE Vector Graphic - Stroke",
                          "lc": 2,
                          "lj": 2,
                          "o": { "a": 0, "k": 100.0 },
                          "w": { "a": 0, "k": 0.684 },
                          "c": { "a": 0, "k": [0.0, 0.0, 0.0, 1.0] }
                        },
                        {
                          "ty": "fl",
                          "nm": "Fill 1",
                          "bm": 0,
                          "mn": "ADBE Vector Graphic - Fill",
                          "c": { "a": 0, "k": [1.0, 1.0, 1.0, 1.0] },
                          "o": { "a": 0, "k": 100.0 },
                          "r": 1
                        },
                        {
                          "ty": "tr",
                          "o": { "a": 0, "k": 100.0 },
                          "r": { "a": 0, "k": 0.0 },
                          "p": { "a": 0, "k": [0.0, 0.0] },
                          "a": { "a": 0, "k": [0.0, 0.0] },
                          "s": { "a": 0, "k": [100.0, 100.0] },
                          "nm": "Transform",
                          "sk": { "a": 0, "k": 0.0 },
                          "sa": { "a": 0, "k": 0.0 }
                        }
                      ]
                    },
                    {
                      "ty": "gr",
                      "nm": "Group 4",
                      "bm": 0,
                      "mn": "ADBE Vector Group",
                      "it": [
                        {
                          "ty": "sh",
                          "nm": "Path 1",
                          "mn": "ADBE Vector Shape - Group",
                          "ind": 0,
                          "ks": {
                            "k": {
                              "i": [
                                [0.0, 0.0],
                                [-1.319, 4.793],
                                [-4.878, 0.961]
                              ],
                              "o": [
                                [-3.699, -3.322],
                                [1.319, -4.793],
                                [0.0, 0.0]
                              ],
                              "v": [
                                [-105.526, -118.084],
                                [-109.511, -131.675],
                                [-99.132, -141.312]
                              ],
                              "c": false
                            },
                            "a": 0
                          }
                        },
                        {
                          "ty": "st",
                          "nm": "Stroke 1",
                          "bm": 0,
                          "mn": "ADBE Vector Graphic - Stroke",
                          "lc": 2,
                          "lj": 2,
                          "o": { "a": 0, "k": 100.0 },
                          "w": { "a": 0, "k": 0.684 },
                          "c": { "a": 0, "k": [0.0, 0.0, 0.0, 1.0] }
                        },
                        {
                          "ty": "fl",
                          "nm": "Fill 1",
                          "bm": 0,
                          "mn": "ADBE Vector Graphic - Fill",
                          "c": { "a": 0, "k": [1.0, 1.0, 1.0, 1.0] },
                          "o": { "a": 0, "k": 100.0 },
                          "r": 1
                        },
                        {
                          "ty": "tr",
                          "o": { "a": 0, "k": 100.0 },
                          "r": { "a": 0, "k": 0.0 },
                          "p": { "a": 0, "k": [0.0, 0.0] },
                          "a": { "a": 0, "k": [0.0, 0.0] },
                          "s": { "a": 0, "k": [100.0, 100.0] },
                          "nm": "Transform",
                          "sk": { "a": 0, "k": 0.0 },
                          "sa": { "a": 0, "k": 0.0 }
                        }
                      ]
                    },
                    {
                      "ty": "tr",
                      "o": { "a": 0, "k": 100.0 },
                      "r": { "a": 0, "k": 0.0 },
                      "p": { "a": 0, "k": [0.0, 0.0] },
                      "a": { "a": 0, "k": [0.0, 0.0] },
                      "s": { "a": 0, "k": [100.0, 100.0] },
                      "nm": "Transform",
                      "sk": { "a": 0, "k": 0.0 },
                      "sa": { "a": 0, "k": 0.0 }
                    }
                  ]
                },
                {
                  "ty": "tr",
                  "o": { "a": 0, "k": 100.0 },
                  "r": { "a": 0, "k": 0.0 },
                  "p": { "a": 0, "k": [0.0, 0.0] },
                  "a": { "a": 0, "k": [0.0, 0.0] },
                  "s": { "a": 0, "k": [100.0, 100.0] },
                  "nm": "Transform",
                  "sk": { "a": 0, "k": 0.0 },
                  "sa": { "a": 0, "k": 0.0 }
                }
              ]
            },
            {
              "ty": "tr",
              "o": { "a": 0, "k": 100.0 },
              "r": { "a": 0, "k": 0.0 },
              "p": {
                "k": [
                  {
                    "i": { "x": 0.667, "y": 1.0 },
                    "o": { "x": 0.333, "y": 0.0 },
                    "t": 36,
                    "s": [-64, -125],
                    "ti": [1.333, 0],
                    "to": [-1.333, 0]
                  },
                  { "t": 44, "s": [-72, -125] }
                ],
                "a": 1
              },
              "a": { "a": 0, "k": [-72.0, -125.0] },
              "s": { "a": 0, "k": [100.0, 100.0] },
              "nm": "Transform",
              "sk": { "a": 0, "k": 0.0 },
              "sa": { "a": 0, "k": 0.0 }
            }
          ]
        },
        {
          "ty": "gr",
          "nm": "Group 4",
          "bm": 0,
          "mn": "ADBE Vector Group",
          "it": [
            {
              "ty": "gr",
              "nm": "Group 1",
              "bm": 0,
              "mn": "ADBE Vector Group",
              "it": [
                {
                  "ty": "sh",
                  "nm": "Path 1",
                  "mn": "ADBE Vector Shape - Group",
                  "ind": 0,
                  "ks": {
                    "k": {
                      "i": [
                        [4.873, 0.184],
                        [-1.489, 5.572],
                        [-3.571, 1.742],
                        [-5.653, 1.088],
                        [-2.708, -0.673],
                        [-0.071, -2.79],
                        [2.341, -1.755],
                        [3.689, -2.102]
                      ],
                      "o": [
                        [-4.546, -0.172],
                        [1.127, -4.217],
                        [5.174, -2.523],
                        [2.74, -0.527],
                        [2.708, 0.673],
                        [0.075, 2.925],
                        [-3.397, 2.547],
                        [-4.237, 2.414]
                      ],
                      "v": [
                        [-131.331, -57.616],
                        [-142.377, -67.742],
                        [-132.353, -76.552],
                        [-115.798, -81.275],
                        [-107.505, -81.655],
                        [-102.192, -75.959],
                        [-106.937, -68.988],
                        [-117.581, -62.006]
                      ],
                      "c": true
                    },
                    "a": 0
                  }
                },
                {
                  "ty": "st",
                  "nm": "Stroke 1",
                  "bm": 0,
                  "mn": "ADBE Vector Graphic - Stroke",
                  "lc": 2,
                  "lj": 2,
                  "o": { "a": 0, "k": 100.0 },
                  "w": { "a": 0, "k": 0.684 },
                  "c": { "a": 0, "k": [0.0, 0.0, 0.0, 1.0] }
                },
                {
                  "ty": "fl",
                  "nm": "Fill 1",
                  "bm": 0,
                  "mn": "ADBE Vector Graphic - Fill",
                  "c": { "a": 0, "k": [1.0, 1.0, 1.0, 1.0] },
                  "o": { "a": 0, "k": 100.0 },
                  "r": 1
                },
                {
                  "ty": "tr",
                  "o": { "a": 0, "k": 100.0 },
                  "r": { "a": 0, "k": 0.0 },
                  "p": { "a": 0, "k": [0.0, 0.0] },
                  "a": { "a": 0, "k": [0.0, 0.0] },
                  "s": { "a": 0, "k": [100.0, 100.0] },
                  "nm": "Transform",
                  "sk": { "a": 0, "k": 0.0 },
                  "sa": { "a": 0, "k": 0.0 }
                }
              ]
            },
            {
              "ty": "tr",
              "o": { "a": 0, "k": 100.0 },
              "r": {
                "a": 1,
                "k": [
                  {
                    "i": { "x": [0.667], "y": [1] },
                    "o": { "x": [0.333], "y": [0] },
                    "t": 36,
                    "s": [0.0]
                  },
                  {
                    "i": { "x": [0.667], "y": [1] },
                    "o": { "x": [0.333], "y": [0] },
                    "t": 45.125,
                    "s": [55.0]
                  },
                  {
                    "i": { "x": [0.667], "y": [1] },
                    "o": { "x": [0.333], "y": [0] },
                    "t": 54.25,
                    "s": [0.0]
                  },
                  {
                    "i": { "x": [0.667], "y": [1] },
                    "o": { "x": [0.333], "y": [0] },
                    "t": 63.375,
                    "s": [55.0]
                  },
                  {
                    "i": { "x": [0.667], "y": [1] },
                    "o": { "x": [0.333], "y": [0] },
                    "t": 72,
                    "s": [0.0]
                  },
                  {
                    "i": { "x": [0.667], "y": [1] },
                    "o": { "x": [0.333], "y": [0] },
                    "t": 81.625,
                    "s": [55.0]
                  },
                  {
                    "i": { "x": [0.667], "y": [1] },
                    "o": { "x": [0.333], "y": [0] },
                    "t": 90.75,
                    "s": [0.0]
                  },
                  {
                    "i": { "x": [0.667], "y": [1] },
                    "o": { "x": [0.333], "y": [0] },
                    "t": 99.875,
                    "s": [55.0]
                  },
                  { "t": 109, "s": [0.0] }
                ]
              },
              "p": { "a": 0, "k": [-102.976, -79.981] },
              "a": { "a": 0, "k": [-102.976, -79.981] },
              "s": { "a": 0, "k": [100.0, 100.0] },
              "nm": "Transform",
              "sk": { "a": 0, "k": 0.0 },
              "sa": { "a": 0, "k": 0.0 }
            }
          ]
        },
        {
          "ty": "gr",
          "nm": "Group 5",
          "bm": 0,
          "mn": "ADBE Vector Group",
          "it": [
            {
              "ty": "gr",
              "nm": "Group 1",
              "bm": 0,
              "mn": "ADBE Vector Group",
              "it": [
                {
                  "ty": "sh",
                  "nm": "Path 1",
                  "mn": "ADBE Vector Shape - Group",
                  "ind": 0,
                  "ks": {
                    "k": {
                      "i": [
                        [0.0, -4.828],
                        [4.828, 0.0],
                        [0.0, 4.828],
                        [-4.828, 0.0]
                      ],
                      "o": [
                        [0.0, 4.828],
                        [-4.828, 0.0],
                        [0.0, -4.828],
                        [4.828, 0.0]
                      ],
                      "v": [
                        [-73.06, -67.711],
                        [-81.802, -58.969],
                        [-90.545, -67.711],
                        [-81.802, -76.454]
                      ],
                      "c": true
                    },
                    "a": 0
                  }
                },
                {
                  "ty": "fl",
                  "nm": "Fill 1",
                  "bm": 0,
                  "mn": "ADBE Vector Graphic - Fill",
                  "c": { "a": 0, "k": [0.0, 0.0, 0.0, 1.0] },
                  "o": { "a": 0, "k": 100.0 },
                  "r": 1
                },
                {
                  "ty": "tr",
                  "o": { "a": 0, "k": 100.0 },
                  "r": { "a": 0, "k": 0.0 },
                  "p": {
                    "k": [
                      {
                        "i": { "x": 0.667, "y": 1.0 },
                        "o": { "x": 0.333, "y": 0.0 },
                        "t": 25,
                        "s": [-82.173, -67.188],
                        "ti": [-5.793, 0],
                        "to": [5.793, 0]
                      },
                      {
                        "i": { "x": 0.667, "y": 0.667 },
                        "o": { "x": 0.333, "y": 0.333 },
                        "t": 36,
                        "s": [-47.412, -67.188],
                        "ti": [0, 0],
                        "to": [0, 0]
                      },
                      {
                        "i": { "x": 0.667, "y": 1.0 },
                        "o": { "x": 0.333, "y": 0.0 },
                        "t": 46.014,
                        "s": [-47.412, -67.188],
                        "ti": [5.793, 0],
                        "to": [-5.793, 0]
                      },
                      {
                        "i": { "x": 0.667, "y": 0.667 },
                        "o": { "x": 0.167, "y": 0.167 },
                        "t": 56.014,
                        "s": [-82.173, -67.188],
                        "ti": [0, 0],
                        "to": [0, 0]
                      },
                      {
                        "i": { "x": 0.667, "y": 1.0 },
                        "o": { "x": 0.333, "y": 0.0 },
                        "t": 78.986,
                        "s": [-82.173, -67.188],
                        "ti": [-5.793, 0],
                        "to": [5.793, 0]
                      },
                      {
                        "i": { "x": 0.667, "y": 0.667 },
                        "o": { "x": 0.333, "y": 0.333 },
                        "t": 89.986,
                        "s": [-47.412, -67.188],
                        "ti": [0, 0],
                        "to": [0, 0]
                      },
                      {
                        "i": { "x": 0.667, "y": 1.0 },
                        "o": { "x": 0.333, "y": 0.0 },
                        "t": 100,
                        "s": [-47.412, -67.188],
                        "ti": [5.793, 0],
                        "to": [-5.793, 0]
                      },
                      { "t": 110, "s": [-82.173, -67.188] }
                    ],
                    "x": "var $bm_rt;\nvar fx = effect('\u015dlosilo pli pura 3');\nvar doAnticipation = fx(1).value;\nvar doInterpolation = fx(2).value;\nvar doFollowThrough = fx(3).value;\nvar damping = $bm_div(fx(15).value, 10);\nvar elasticity = $bm_div(fx(13).value, 10);\nvar bounce = fx(17).value;\nvar anticipationDuration = fx(5).value;\nvar anticipationQuantity = $bm_div(fx(6).value, 100);\nvar slowIn = $bm_div(fx(9).value, 100);\nvar slowOut = $bm_div(fx(10).value, 100);\nvar spatialMode = fx(21).value;\nvar spatialDoInterpolation = fx(20).value;\nvar moBlurPrecision = fx(32).value;\nvar elasticityRandom = fx(14).value;\nvar dampingRandom = fx(16).value;\nvar softBody = fx(28).value;\nvar flexibility = $bm_div(fx(29).value, 100);\nvar doOverlap = fx(23).value;\nvar overlapDuration = fx(24).value;\nvar overlapRandom = fx(25).value;\nvar threshold = $bm_div($bm_div(1, moBlurPrecision), 1000);\nvar zeroValue;\nif ($bm_isInstanceOfArray(value)) {\n    if (value.length == 2)\n        zeroValue = [\n            0,\n            0\n        ];\n    else if (value.length == 3)\n        zeroValue = [\n            0,\n            0,\n            0\n        ];\n    else if (value.length == 4)\n        zeroValue = [\n            0,\n            0,\n            0,\n            0\n        ];\n} else\n    zeroValue = 0;\nvar isThisSpatial = isSpatial(thisProperty);\nvar isThisPosition = thisProperty === $bm_transform.position;\nvar simulate = false;\nif (isThisSpatial) {\n    doInterpolation = doInterpolation && spatialDoInterpolation;\n    if (isThisPosition && thisProperty.numKeys > 0) {\n        doOverlap = false;\n        simulate = false;\n    } else {\n        simulate = spatialMode == 2;\n        doOverlap = overlapDuration != 0 && doOverlap && simulate;\n    }\n} else {\n    doOverlap = false;\n}\nif (!doOverlap) {\n    overlapDuration = 0;\n}\nif (simulate && softBody && isThisSpatial && !isThisPosition && (doFollowThrough || doOverlap)) {\n    var distanceRatio = $bm_div(length(valueAtTime(0), $bm_transform.anchorPoint), $bm_div(thisLayer.width, 2));\n    distanceRatio = $bm_div($bm_sum(1, $bm_mul(distanceRatio, flexibility)), 2);\n    if (doFollowThrough) {\n        elasticity = $bm_div(elasticity, distanceRatio);\n        damping = $bm_div(damping, distanceRatio);\n    }\n    if (doOverlap) {\n        overlapDuration = $bm_mul(overlapDuration, distanceRatio);\n    }\n}\nseedRandom(0, true);\nif (doFollowThrough) {\n    if (elasticityRandom > 0)\n        elasticity = addNoise(elasticity, elasticityRandom);\n    if (dampingRandom > 0)\n        damping = addNoise(damping, dampingRandom);\n}\nif (doOverlap) {\n    if (doOverlap && overlapRandom > 0)\n        overlapDuration = addNoise(overlapDuration, overlapRandom);\n}\nvar result = value;\nfunction isSpatial(prop) {\n    if (!(prop.value instanceof Array))\n        return false;\n    if (prop.value.length != 2 && prop.value.length != 3)\n        return false;\n    try {\n        if (typeof prop.speed !== 'undefined')\n            return true;\n    } catch (e) {\n        return false;\n    }\n}\nfunction addNoise(val, quantity) {\n    var randomValue = random(0.9, 1.1);\n    var noiseValue = noise($bm_mul(valueAtTime(0), randomValue));\n    noiseValue = $bm_mul(noiseValue, $bm_div(quantity, 100));\n    return $bm_mul(val, $bm_sum(noiseValue, 1));\n}\nfunction isAfterLastKey() {\n    if (numKeys == 0)\n        return false;\n    var nKey = nearestKey(time);\n    return nKey.time <= time && nKey.index == numKeys;\n}\nfunction isStill(t, threshold) {\n    var d = $bm_sub(valueAtTime(t), valueAtTime($bm_sum(t, framesToTime(1))));\n    if ($bm_isInstanceOfArray(d)) {\n        for (var i = 0; i < d.length; i++) {\n            d[i] = Math.abs(d[i]);\n            if (d[i] >= threshold) {\n                return false;\n            }\n        }\n        return true;\n    } else {\n        d = Math.abs(d);\n        return d < threshold;\n    }\n}\nfunction bezierInterpolation(t, tMin, tMax, value1, value2, bezierPoints) {\n    if (arguments.length !== 5 && arguments.length !== 6)\n        return t;\n    var a = $bm_sub(value2, value1);\n    var b = $bm_sub(tMax, tMin);\n    if (b == 0)\n        return t;\n    var c = clamp($bm_div($bm_sub(t, tMin), b), 0, 1);\n    if (!(bezierPoints instanceof Array) || bezierPoints.length !== 4)\n        bezierPoints = [\n            0.33,\n            0,\n            0.66,\n            1\n        ];\n    return $bm_sum($bm_mul(a, h(c, bezierPoints)), value1);\n    function h(f, g) {\n        var x = $bm_mul(3, g[0]);\n        var j = $bm_sub($bm_mul(3, $bm_sub(g[2], g[0])), x);\n        var k = $bm_sub($bm_sub(1, x), j);\n        var l = $bm_mul(3, g[1]);\n        var m = $bm_sub($bm_mul(3, $bm_sub(g[3], g[1])), l);\n        var n = $bm_sub($bm_sub(1, l), m);\n        var d = f;\n        for (var i = 0; i < 5; i++) {\n            var z = $bm_sub($bm_mul(d, $bm_sum(x, $bm_mul(d, $bm_sum(j, $bm_mul(d, k))))), f);\n            if (Math.abs(z) < 0.001)\n                break;\n            d = $bm_sub(d, $bm_div(z, $bm_sum(x, $bm_mul(d, $bm_sum($bm_mul(2, j), $bm_mul($bm_mul(3, k), d))))));\n        }\n        return $bm_mul(d, $bm_sum(l, $bm_mul(d, $bm_sum(m, $bm_mul(d, n)))));\n    }\n}\nfunction getPropWorldSpeed(t, prop) {\n    return length(getPropWorldVelocity(t, prop));\n}\nfunction getPrevKey(t) {\n    if (numKeys == 0)\n        return null;\n    var nKey = nearestKey(t);\n    if (nKey.time <= t)\n        return nKey;\n    if (nKey.index > 1)\n        return key($bm_sub(nKey.index, 1));\n    return null;\n}\nfunction getNextKey(t) {\n    if (numKeys == 0)\n        return null;\n    var nKey = nearestKey(t);\n    if (nKey.time >= t)\n        return nKey;\n    if (nKey.index < numKeys)\n        return key($bm_sum(nKey.index, 1));\n    return null;\n}\nfunction getPropWorldVelocity(t, prop) {\n    return $bm_mul($bm_sub(getPropWorldValue($bm_sum(t, 0.005), prop), getPropWorldValue($bm_sub(t, 0.005), prop)), 100);\n}\nfunction getLayerWorldPos(t, l) {\n    return l.toWorld(l.anchorPoint, t);\n}\nfunction getPropWorldValue(t, prop) {\n    if (isPosition(prop))\n        return getLayerWorldPos(t, thisLayer);\n    return thisLayer.toWorld(prop.valueAtTime(t), t);\n}\nfunction isPosition(prop) {\n    return prop === $bm_transform.position;\n}\nfunction isKeyTop(k, axis) {\n    var prevSpeed = velocityAtTime($bm_sub(k.time, threshold));\n    var nextSpeed = velocityAtTime($bm_sum(k.time, threshold));\n    if ($bm_isInstanceOfArray(value)) {\n        prevSpeed = prevSpeed[axis];\n        nextSpeed = nextSpeed[axis];\n    }\n    if (Math.abs(prevSpeed) < 0.01 || Math.abs(nextSpeed) < 0.01)\n        return true;\n    return $bm_mul(prevSpeed, nextSpeed) < 0;\n}\nfunction anticipate() {\n    var anticipation = zeroValue;\n    if (isAfterLastKey())\n        return anticipation;\n    if (numKeys < 2)\n        return anticipation;\n    var nextKey = getNextKey(time);\n    var aKey = nextKey;\n    if (!isStill(aKey.time - 0.1, 0.1)) {\n        aKey = getPrevKey(time);\n        if (!isStill(aKey.time - 0.1, 0.1))\n            return anticipation;\n    }\n    if (aKey.index == numKeys)\n        return anticipation;\n    var anticipationMiddle = aKey.time;\n    var anticipationStart = $bm_sub(anticipationMiddle, anticipationDuration);\n    var anticipationEnd = key(aKey.index + 1).time;\n    var startValue = anticipation;\n    var midValue = $bm_mul($bm_sum($bm_neg(valueAtTime($bm_sum(anticipationMiddle, anticipationDuration))), aKey.value), anticipationQuantity);\n    var endValue = anticipation;\n    if (time < anticipationStart) {\n        return anticipation;\n    } else if (time < anticipationMiddle) {\n        if ($bm_isInstanceOfArray(value)) {\n            for (var i = 0; i < value.length; i++) {\n                anticipation[i] = bezierInterpolation(time, anticipationStart, anticipationMiddle, startValue[i], midValue[i], [\n                    slowOut,\n                    0,\n                    slowIn,\n                    1\n                ]);\n            }\n            return anticipation;\n        } else {\n            return bezierInterpolation(time, anticipationStart, anticipationMiddle, startValue, midValue, [\n                slowOut,\n                0,\n                slowIn,\n                1\n            ]);\n        }\n    } else if (time <= anticipationEnd) {\n        if ($bm_isInstanceOfArray(value)) {\n            for (var i = 0; i < value.length; i++) {\n                anticipation[i] = bezierInterpolation(time, anticipationMiddle, anticipationEnd, midValue[i], endValue[i], [\n                    slowOut,\n                    0,\n                    slowIn,\n                    1\n                ]);\n            }\n            return anticipation;\n        } else {\n            return bezierInterpolation(time, anticipationMiddle, anticipationEnd, midValue, endValue, [\n                slowOut,\n                0,\n                slowIn,\n                1\n            ]);\n        }\n    } else {\n        return anticipation;\n    }\n}\nfunction followThroughAtTime(t) {\n    var fThrough = zeroValue;\n    if (elasticity == 0)\n        return fThrough;\n    var propSpeed;\n    if (!simulate) {\n        if (numKeys < 2)\n            return fThrough;\n        if (nearestKey(t).index == 1)\n            return fThrough;\n        propSpeed = length(velocityAtTime(t));\n        if (propSpeed >= threshold)\n            return fThrough;\n    } else {\n        propSpeed = getPropWorldSpeed(t, thisProperty);\n        if (propSpeed >= threshold)\n            return fThrough;\n    }\n    var fThroughStart = 0;\n    var fThroughTime = 0;\n    if (simulate) {\n        var speedI = getPropWorldSpeed(t, thisProperty);\n        var i = t;\n        while (speedI < threshold && i > 0) {\n            i = $bm_sub(i, $bm_div(thisComp.frameDuration, moBlurPrecision));\n            speedI = getPropWorldSpeed(i, thisProperty);\n        }\n        fThroughStart = i;\n    } else {\n        var fThroughKey = getPrevKey(t);\n        fThroughStart = fThroughKey.time;\n    }\n    if (fThroughStart == 0)\n        return fThrough;\n    fThroughTime = $bm_sub(t, fThroughStart);\n    if (simulate)\n        fThrough = $bm_div(getPropWorldVelocity($bm_sub(fThroughStart, thisComp.frameDuration), thisProperty), 2);\n    else\n        fThrough = $bm_div(velocityAtTime($bm_sub(fThroughStart, thisComp.frameDuration)), 2);\n    if (bounce) {\n        var cycleDamp = Math.exp($bm_mul($bm_mul(fThroughTime, damping), 0.1));\n        var damp = $bm_div(Math.exp($bm_mul(fThroughTime, damping)), $bm_div(elasticity, 2));\n        var cycleDuration = $bm_div(1, $bm_mul(elasticity, 2));\n        cycleDuration = Math.round(timeToFrames(cycleDuration));\n        cycleDuration = framesToTime(cycleDuration);\n        var midDuration = $bm_div(cycleDuration, 2);\n        var maxValue = $bm_mul(fThrough, midDuration);\n        var cycvarime = fThroughTime;\n        var numEndCycles = 1;\n        while (cycvarime > cycleDuration) {\n            cycvarime = $bm_sub(cycvarime, cycleDuration);\n            cycleDuration = $bm_div(cycleDuration, cycleDamp);\n            cycleDuration = Math.round(timeToFrames(cycleDuration));\n            if (cycleDuration < 2) {\n                cycleDuration = 2;\n                numEndCycles++;\n            }\n            cycleDuration = framesToTime(cycleDuration);\n            midDuration = $bm_div(cycleDuration, 2);\n            maxValue = $bm_div($bm_mul(fThrough, midDuration), damp);\n            if (numEndCycles > 100 / damping && maxValue < threshold)\n                return zeroValue;\n        }\n        if (cycvarime < midDuration)\n            fThrough = bezierInterpolation(cycvarime, 0, midDuration, 0, maxValue, [\n                0,\n                0.1,\n                slowIn,\n                1\n            ]);\n        else\n            fThrough = bezierInterpolation(cycvarime, midDuration, cycleDuration, maxValue, 0, [\n                $bm_sub(1, slowIn),\n                0,\n                1,\n                0.9\n            ]);\n    } else {\n        var damp = Math.exp($bm_mul(fThroughTime, damping));\n        var sinus = $bm_mul($bm_mul($bm_mul(elasticity, fThroughTime), 2), Math.PI);\n        sinus = Math.sin(sinus);\n        sinus = $bm_mul($bm_div(0.3, elasticity), sinus);\n        sinus = $bm_div(sinus, damp);\n        if (Math.abs(sinus) < $bm_div(threshold, 100))\n            return 0;\n        fThrough = $bm_mul(fThrough, sinus);\n        if (threshold > 0) {\n            fThrough = $bm_mul(fThrough, $bm_sub(1, $bm_div(propSpeed, threshold)));\n        }\n    }\n    if (bounce) {\n        var prevValue = valueAtTime($bm_sub(fThroughStart, thisComp.frameDuration));\n        var startValue = valueAtTime(fThroughStart);\n        if ($bm_isInstanceOfArray(value)) {\n            for (var i = 0; i < prevValue.length; i++) {\n                if (prevValue[i] > startValue[i])\n                    fThrough[i] = Math.abs(fThrough[i]);\n                if (prevValue[i] < startValue[i])\n                    fThrough[i] = $bm_neg(Math.abs(fThrough[i]));\n            }\n        } else {\n            if (prevValue > startValue)\n                fThrough = Math.abs(fThrough);\n            if (prevValue < startValue)\n                fThrough = $bm_neg(Math.abs(fThrough));\n        }\n    }\n    if (simulate) {\n        if (!isThisPosition) {\n            fThrough = $bm_sum(fThrough, getLayerWorldPos(time, thisLayer));\n            fThrough = $bm_sub(thisLayer.fromWorld(fThrough), thisLayer.anchorPoint);\n        } else if (thisLayer.hasParent) {\n            fThrough = $bm_sum(fThrough, getLayerWorldPos(time, thisLayer.parent));\n            fThrough = $bm_sub(thisLayer.parent.fromWorld(fThrough), thisLayer.parent.anchorPoint);\n        }\n    }\n    return fThrough;\n}\nfunction followThrough() {\n    var propSpeed = length(velocity);\n    if (propSpeed < threshold)\n        return followThroughAtTime($bm_sub(time, overlapDuration));\n    var fThrough = zeroValue;\n    var t = time;\n    while (t > 0) {\n        t = $bm_sub(t, thisComp.frameDuration);\n        if (simulate)\n            propSpeed = getPropWorldSpeed($bm_sub(t, overlapDuration), thisProperty);\n        else\n            propSpeed = length(velocityAtTime(t));\n        if (propSpeed < threshold) {\n            fThrough = followThroughAtTime($bm_sub(t, overlapDuration));\n            break;\n        }\n    }\n    return linear(time, t, $bm_sum(t, $bm_mul(anticipationDuration, 2)), fThrough, zeroValue);\n}\nfunction smartSmooth(axis) {\n    var startKey = nearestKey(time);\n    var endKey = startKey;\n    if (time == startKey.time)\n        return 0;\n    if (time < startKey.time && startKey.index == 1)\n        return 0;\n    if (time > startKey.time && startKey.index == numKeys)\n        return 0;\n    if (time < startKey.time)\n        startKey = key($bm_sub(startKey.index, 1));\n    if (time > startKey.time)\n        endKey = key($bm_sum(startKey.index, 1));\n    var sI = 0.66;\n    var sO = 0.33;\n    var sIV = 1;\n    var sOV = 0;\n    var sVal = startKey.value;\n    var eVal = endKey.value;\n    if ($bm_isInstanceOfArray(value)) {\n        sVal = sVal[axis];\n        eVal = eVal[axis];\n    }\n    var sTime = startKey.time;\n    var eTime = endKey.time;\n    if (isKeyTop(startKey, axis))\n        sO = slowOut;\n    else {\n        var prevKey = key($bm_sub(startKey.index, 1));\n        var pVal = prevKey.value;\n        if ($bm_isInstanceOfArray(value))\n            pVal = pVal[axis];\n        sOV = $bm_div($bm_sub(sVal, pVal), $bm_sub(eVal, pVal));\n    }\n    if (isKeyTop(endKey, axis)) {\n        sI = slowIn;\n        if (endKey.index != numKeys) {\n            var nextKey = key($bm_sum(endKey.index, 1));\n            var nVal = nextKey.value;\n            if ($bm_isInstanceOfArray(value))\n                nVal = nVal[axis];\n            if (Math.abs(nVal - eVal) < 0.01 && doFollowThrough)\n                sI = 1;\n        }\n    } else {\n        var nextKey = key($bm_sum(endKey.index, 1));\n        var nVal = nextKey.value;\n        if ($bm_isInstanceOfArray(value))\n            nVal = nVal[axis];\n        sIV = $bm_div($bm_sub(eVal, sVal), $bm_sub(nVal, sVal));\n    }\n    if (endKey.index == numKeys && doFollowThrough) {\n        sI = 1;\n    }\n    var val = value;\n    if ($bm_isInstanceOfArray(value))\n        val = val[axis];\n    return $bm_sub(bezierInterpolation(time, sTime, eTime, sVal, eVal, [\n        sO,\n        sOV,\n        sI,\n        sIV\n    ]), val);\n}\nfunction overlap() {\n    var ol = zeroValue;\n    if (isThisPosition && !hasParent)\n        return zeroValue;\n    ol = $bm_sub(getPropWorldValue($bm_sub(time, overlapDuration), thisProperty), getPropWorldValue(time, thisProperty));\n    var motionRatio = $bm_div($bm_div(length(zeroValue, ol), thisLayer.width), 2);\n    if (isThisPosition) {\n        var originalDistance = length(valueAtTime(0));\n        motionRatio = $bm_div(length(zeroValue, ol), thisComp.width);\n    }\n    ol = $bm_sum(ol, getPropWorldValue(time, thisProperty));\n    ol = $bm_sum(ol, $bm_mul($bm_mul($bm_sub(getPropWorldValue($bm_sub(time, overlapDuration), thisLayer.anchorPoint), ol), motionRatio), flexibility));\n    ol = thisLayer.fromWorld(ol);\n    if (!isThisPosition)\n        ol = $bm_sub(ol, value);\n    else {\n        ol = linear(flexibility, 0, 100, $bm_div(ol, 2), 0);\n        var prevParentWorldPos = getLayerWorldPos($bm_sub(time, overlapDuration), parent);\n        ol = $bm_sum(ol, $bm_mul($bm_mul($bm_mul(thisLayer.fromWorld(prevParentWorldPos), motionRatio), flexibility), 5));\n    }\n    return ol;\n}\nvar okToGo = false;\nif (simulate && fx.enabled)\n    okToGo = true;\nelse if (numKeys > 1 && fx.enabled)\n    okToGo = true;\nif (okToGo) {\n    var smartSmoothResult = zeroValue;\n    if (doInterpolation) {\n        if ($bm_isInstanceOfArray(value)) {\n            if (value.length == 2)\n                smartSmoothResult = [\n                    smartSmooth(0),\n                    smartSmooth(1)\n                ];\n            else if (value.length == 3)\n                smartSmoothResult = [\n                    smartSmooth(0),\n                    smartSmooth(1),\n                    smartSmooth(2)\n                ];\n            else if (value.length == 4)\n                smartSmoothResult = [\n                    smartSmooth(0),\n                    smartSmooth(1),\n                    smartSmooth(2),\n                    smartSmooth(3)\n                ];\n        } else {\n            smartSmoothResult = smartSmooth(0);\n        }\n    }\n    if (doAnticipation)\n        result = $bm_sum(result, anticipate());\n    result = $bm_sum(result, smartSmoothResult);\n    if (doFollowThrough)\n        result = $bm_sum(result, followThrough());\n    if (doOverlap)\n        result = $bm_sum(result, overlap());\n}\n$bm_rt = result;",
                    "a": 1
                  },
                  "a": {
                    "a": 0,
                    "k": [-82.173, -67.188],
                    "x": "var $bm_rt;\nvar fx = effect('\u015dlosilo pli pura 3');\nvar doAnticipation = fx(1).value;\nvar doInterpolation = fx(2).value;\nvar doFollowThrough = fx(3).value;\nvar damping = $bm_div(fx(15).value, 10);\nvar elasticity = $bm_div(fx(13).value, 10);\nvar bounce = fx(17).value;\nvar anticipationDuration = fx(5).value;\nvar anticipationQuantity = $bm_div(fx(6).value, 100);\nvar slowIn = $bm_div(fx(9).value, 100);\nvar slowOut = $bm_div(fx(10).value, 100);\nvar spatialMode = fx(21).value;\nvar spatialDoInterpolation = fx(20).value;\nvar moBlurPrecision = fx(32).value;\nvar elasticityRandom = fx(14).value;\nvar dampingRandom = fx(16).value;\nvar softBody = fx(28).value;\nvar flexibility = $bm_div(fx(29).value, 100);\nvar doOverlap = fx(23).value;\nvar overlapDuration = fx(24).value;\nvar overlapRandom = fx(25).value;\nvar threshold = $bm_div($bm_div(1, moBlurPrecision), 1000);\nvar zeroValue;\nif ($bm_isInstanceOfArray(value)) {\n    if (value.length == 2)\n        zeroValue = [\n            0,\n            0\n        ];\n    else if (value.length == 3)\n        zeroValue = [\n            0,\n            0,\n            0\n        ];\n    else if (value.length == 4)\n        zeroValue = [\n            0,\n            0,\n            0,\n            0\n        ];\n} else\n    zeroValue = 0;\nvar isThisSpatial = isSpatial(thisProperty);\nvar isThisPosition = thisProperty === $bm_transform.position;\nvar simulate = false;\nif (isThisSpatial) {\n    doInterpolation = doInterpolation && spatialDoInterpolation;\n    if (isThisPosition && thisProperty.numKeys > 0) {\n        doOverlap = false;\n        simulate = false;\n    } else {\n        simulate = spatialMode == 2;\n        doOverlap = overlapDuration != 0 && doOverlap && simulate;\n    }\n} else {\n    doOverlap = false;\n}\nif (!doOverlap) {\n    overlapDuration = 0;\n}\nif (simulate && softBody && isThisSpatial && !isThisPosition && (doFollowThrough || doOverlap)) {\n    var distanceRatio = $bm_div(length(valueAtTime(0), $bm_transform.anchorPoint), $bm_div(thisLayer.width, 2));\n    distanceRatio = $bm_div($bm_sum(1, $bm_mul(distanceRatio, flexibility)), 2);\n    if (doFollowThrough) {\n        elasticity = $bm_div(elasticity, distanceRatio);\n        damping = $bm_div(damping, distanceRatio);\n    }\n    if (doOverlap) {\n        overlapDuration = $bm_mul(overlapDuration, distanceRatio);\n    }\n}\nseedRandom(0, true);\nif (doFollowThrough) {\n    if (elasticityRandom > 0)\n        elasticity = addNoise(elasticity, elasticityRandom);\n    if (dampingRandom > 0)\n        damping = addNoise(damping, dampingRandom);\n}\nif (doOverlap) {\n    if (doOverlap && overlapRandom > 0)\n        overlapDuration = addNoise(overlapDuration, overlapRandom);\n}\nvar result = value;\nfunction isSpatial(prop) {\n    if (!(prop.value instanceof Array))\n        return false;\n    if (prop.value.length != 2 && prop.value.length != 3)\n        return false;\n    try {\n        if (typeof prop.speed !== 'undefined')\n            return true;\n    } catch (e) {\n        return false;\n    }\n}\nfunction addNoise(val, quantity) {\n    var randomValue = random(0.9, 1.1);\n    var noiseValue = noise($bm_mul(valueAtTime(0), randomValue));\n    noiseValue = $bm_mul(noiseValue, $bm_div(quantity, 100));\n    return $bm_mul(val, $bm_sum(noiseValue, 1));\n}\nfunction isAfterLastKey() {\n    if (numKeys == 0)\n        return false;\n    var nKey = nearestKey(time);\n    return nKey.time <= time && nKey.index == numKeys;\n}\nfunction isStill(t, threshold) {\n    var d = $bm_sub(valueAtTime(t), valueAtTime($bm_sum(t, framesToTime(1))));\n    if ($bm_isInstanceOfArray(d)) {\n        for (var i = 0; i < d.length; i++) {\n            d[i] = Math.abs(d[i]);\n            if (d[i] >= threshold) {\n                return false;\n            }\n        }\n        return true;\n    } else {\n        d = Math.abs(d);\n        return d < threshold;\n    }\n}\nfunction bezierInterpolation(t, tMin, tMax, value1, value2, bezierPoints) {\n    if (arguments.length !== 5 && arguments.length !== 6)\n        return t;\n    var a = $bm_sub(value2, value1);\n    var b = $bm_sub(tMax, tMin);\n    if (b == 0)\n        return t;\n    var c = clamp($bm_div($bm_sub(t, tMin), b), 0, 1);\n    if (!(bezierPoints instanceof Array) || bezierPoints.length !== 4)\n        bezierPoints = [\n            0.33,\n            0,\n            0.66,\n            1\n        ];\n    return $bm_sum($bm_mul(a, h(c, bezierPoints)), value1);\n    function h(f, g) {\n        var x = $bm_mul(3, g[0]);\n        var j = $bm_sub($bm_mul(3, $bm_sub(g[2], g[0])), x);\n        var k = $bm_sub($bm_sub(1, x), j);\n        var l = $bm_mul(3, g[1]);\n        var m = $bm_sub($bm_mul(3, $bm_sub(g[3], g[1])), l);\n        var n = $bm_sub($bm_sub(1, l), m);\n        var d = f;\n        for (var i = 0; i < 5; i++) {\n            var z = $bm_sub($bm_mul(d, $bm_sum(x, $bm_mul(d, $bm_sum(j, $bm_mul(d, k))))), f);\n            if (Math.abs(z) < 0.001)\n                break;\n            d = $bm_sub(d, $bm_div(z, $bm_sum(x, $bm_mul(d, $bm_sum($bm_mul(2, j), $bm_mul($bm_mul(3, k), d))))));\n        }\n        return $bm_mul(d, $bm_sum(l, $bm_mul(d, $bm_sum(m, $bm_mul(d, n)))));\n    }\n}\nfunction getPropWorldSpeed(t, prop) {\n    return length(getPropWorldVelocity(t, prop));\n}\nfunction getPrevKey(t) {\n    if (numKeys == 0)\n        return null;\n    var nKey = nearestKey(t);\n    if (nKey.time <= t)\n        return nKey;\n    if (nKey.index > 1)\n        return key($bm_sub(nKey.index, 1));\n    return null;\n}\nfunction getNextKey(t) {\n    if (numKeys == 0)\n        return null;\n    var nKey = nearestKey(t);\n    if (nKey.time >= t)\n        return nKey;\n    if (nKey.index < numKeys)\n        return key($bm_sum(nKey.index, 1));\n    return null;\n}\nfunction getPropWorldVelocity(t, prop) {\n    return $bm_mul($bm_sub(getPropWorldValue($bm_sum(t, 0.005), prop), getPropWorldValue($bm_sub(t, 0.005), prop)), 100);\n}\nfunction getLayerWorldPos(t, l) {\n    return l.toWorld(l.anchorPoint, t);\n}\nfunction getPropWorldValue(t, prop) {\n    if (isPosition(prop))\n        return getLayerWorldPos(t, thisLayer);\n    return thisLayer.toWorld(prop.valueAtTime(t), t);\n}\nfunction isPosition(prop) {\n    return prop === $bm_transform.position;\n}\nfunction isKeyTop(k, axis) {\n    var prevSpeed = velocityAtTime($bm_sub(k.time, threshold));\n    var nextSpeed = velocityAtTime($bm_sum(k.time, threshold));\n    if ($bm_isInstanceOfArray(value)) {\n        prevSpeed = prevSpeed[axis];\n        nextSpeed = nextSpeed[axis];\n    }\n    if (Math.abs(prevSpeed) < 0.01 || Math.abs(nextSpeed) < 0.01)\n        return true;\n    return $bm_mul(prevSpeed, nextSpeed) < 0;\n}\nfunction anticipate() {\n    var anticipation = zeroValue;\n    if (isAfterLastKey())\n        return anticipation;\n    if (numKeys < 2)\n        return anticipation;\n    var nextKey = getNextKey(time);\n    var aKey = nextKey;\n    if (!isStill(aKey.time - 0.1, 0.1)) {\n        aKey = getPrevKey(time);\n        if (!isStill(aKey.time - 0.1, 0.1))\n            return anticipation;\n    }\n    if (aKey.index == numKeys)\n        return anticipation;\n    var anticipationMiddle = aKey.time;\n    var anticipationStart = $bm_sub(anticipationMiddle, anticipationDuration);\n    var anticipationEnd = key(aKey.index + 1).time;\n    var startValue = anticipation;\n    var midValue = $bm_mul($bm_sum($bm_neg(valueAtTime($bm_sum(anticipationMiddle, anticipationDuration))), aKey.value), anticipationQuantity);\n    var endValue = anticipation;\n    if (time < anticipationStart) {\n        return anticipation;\n    } else if (time < anticipationMiddle) {\n        if ($bm_isInstanceOfArray(value)) {\n            for (var i = 0; i < value.length; i++) {\n                anticipation[i] = bezierInterpolation(time, anticipationStart, anticipationMiddle, startValue[i], midValue[i], [\n                    slowOut,\n                    0,\n                    slowIn,\n                    1\n                ]);\n            }\n            return anticipation;\n        } else {\n            return bezierInterpolation(time, anticipationStart, anticipationMiddle, startValue, midValue, [\n                slowOut,\n                0,\n                slowIn,\n                1\n            ]);\n        }\n    } else if (time <= anticipationEnd) {\n        if ($bm_isInstanceOfArray(value)) {\n            for (var i = 0; i < value.length; i++) {\n                anticipation[i] = bezierInterpolation(time, anticipationMiddle, anticipationEnd, midValue[i], endValue[i], [\n                    slowOut,\n                    0,\n                    slowIn,\n                    1\n                ]);\n            }\n            return anticipation;\n        } else {\n            return bezierInterpolation(time, anticipationMiddle, anticipationEnd, midValue, endValue, [\n                slowOut,\n                0,\n                slowIn,\n                1\n            ]);\n        }\n    } else {\n        return anticipation;\n    }\n}\nfunction followThroughAtTime(t) {\n    var fThrough = zeroValue;\n    if (elasticity == 0)\n        return fThrough;\n    var propSpeed;\n    if (!simulate) {\n        if (numKeys < 2)\n            return fThrough;\n        if (nearestKey(t).index == 1)\n            return fThrough;\n        propSpeed = length(velocityAtTime(t));\n        if (propSpeed >= threshold)\n            return fThrough;\n    } else {\n        propSpeed = getPropWorldSpeed(t, thisProperty);\n        if (propSpeed >= threshold)\n            return fThrough;\n    }\n    var fThroughStart = 0;\n    var fThroughTime = 0;\n    if (simulate) {\n        var speedI = getPropWorldSpeed(t, thisProperty);\n        var i = t;\n        while (speedI < threshold && i > 0) {\n            i = $bm_sub(i, $bm_div(thisComp.frameDuration, moBlurPrecision));\n            speedI = getPropWorldSpeed(i, thisProperty);\n        }\n        fThroughStart = i;\n    } else {\n        var fThroughKey = getPrevKey(t);\n        fThroughStart = fThroughKey.time;\n    }\n    if (fThroughStart == 0)\n        return fThrough;\n    fThroughTime = $bm_sub(t, fThroughStart);\n    if (simulate)\n        fThrough = $bm_div(getPropWorldVelocity($bm_sub(fThroughStart, thisComp.frameDuration), thisProperty), 2);\n    else\n        fThrough = $bm_div(velocityAtTime($bm_sub(fThroughStart, thisComp.frameDuration)), 2);\n    if (bounce) {\n        var cycleDamp = Math.exp($bm_mul($bm_mul(fThroughTime, damping), 0.1));\n        var damp = $bm_div(Math.exp($bm_mul(fThroughTime, damping)), $bm_div(elasticity, 2));\n        var cycleDuration = $bm_div(1, $bm_mul(elasticity, 2));\n        cycleDuration = Math.round(timeToFrames(cycleDuration));\n        cycleDuration = framesToTime(cycleDuration);\n        var midDuration = $bm_div(cycleDuration, 2);\n        var maxValue = $bm_mul(fThrough, midDuration);\n        var cycvarime = fThroughTime;\n        var numEndCycles = 1;\n        while (cycvarime > cycleDuration) {\n            cycvarime = $bm_sub(cycvarime, cycleDuration);\n            cycleDuration = $bm_div(cycleDuration, cycleDamp);\n            cycleDuration = Math.round(timeToFrames(cycleDuration));\n            if (cycleDuration < 2) {\n                cycleDuration = 2;\n                numEndCycles++;\n            }\n            cycleDuration = framesToTime(cycleDuration);\n            midDuration = $bm_div(cycleDuration, 2);\n            maxValue = $bm_div($bm_mul(fThrough, midDuration), damp);\n            if (numEndCycles > 100 / damping && maxValue < threshold)\n                return zeroValue;\n        }\n        if (cycvarime < midDuration)\n            fThrough = bezierInterpolation(cycvarime, 0, midDuration, 0, maxValue, [\n                0,\n                0.1,\n                slowIn,\n                1\n            ]);\n        else\n            fThrough = bezierInterpolation(cycvarime, midDuration, cycleDuration, maxValue, 0, [\n                $bm_sub(1, slowIn),\n                0,\n                1,\n                0.9\n            ]);\n    } else {\n        var damp = Math.exp($bm_mul(fThroughTime, damping));\n        var sinus = $bm_mul($bm_mul($bm_mul(elasticity, fThroughTime), 2), Math.PI);\n        sinus = Math.sin(sinus);\n        sinus = $bm_mul($bm_div(0.3, elasticity), sinus);\n        sinus = $bm_div(sinus, damp);\n        if (Math.abs(sinus) < $bm_div(threshold, 100))\n            return 0;\n        fThrough = $bm_mul(fThrough, sinus);\n        if (threshold > 0) {\n            fThrough = $bm_mul(fThrough, $bm_sub(1, $bm_div(propSpeed, threshold)));\n        }\n    }\n    if (bounce) {\n        var prevValue = valueAtTime($bm_sub(fThroughStart, thisComp.frameDuration));\n        var startValue = valueAtTime(fThroughStart);\n        if ($bm_isInstanceOfArray(value)) {\n            for (var i = 0; i < prevValue.length; i++) {\n                if (prevValue[i] > startValue[i])\n                    fThrough[i] = Math.abs(fThrough[i]);\n                if (prevValue[i] < startValue[i])\n                    fThrough[i] = $bm_neg(Math.abs(fThrough[i]));\n            }\n        } else {\n            if (prevValue > startValue)\n                fThrough = Math.abs(fThrough);\n            if (prevValue < startValue)\n                fThrough = $bm_neg(Math.abs(fThrough));\n        }\n    }\n    if (simulate) {\n        if (!isThisPosition) {\n            fThrough = $bm_sum(fThrough, getLayerWorldPos(time, thisLayer));\n            fThrough = $bm_sub(thisLayer.fromWorld(fThrough), thisLayer.anchorPoint);\n        } else if (thisLayer.hasParent) {\n            fThrough = $bm_sum(fThrough, getLayerWorldPos(time, thisLayer.parent));\n            fThrough = $bm_sub(thisLayer.parent.fromWorld(fThrough), thisLayer.parent.anchorPoint);\n        }\n    }\n    return fThrough;\n}\nfunction followThrough() {\n    var propSpeed = length(velocity);\n    if (propSpeed < threshold)\n        return followThroughAtTime($bm_sub(time, overlapDuration));\n    var fThrough = zeroValue;\n    var t = time;\n    while (t > 0) {\n        t = $bm_sub(t, thisComp.frameDuration);\n        if (simulate)\n            propSpeed = getPropWorldSpeed($bm_sub(t, overlapDuration), thisProperty);\n        else\n            propSpeed = length(velocityAtTime(t));\n        if (propSpeed < threshold) {\n            fThrough = followThroughAtTime($bm_sub(t, overlapDuration));\n            break;\n        }\n    }\n    return linear(time, t, $bm_sum(t, $bm_mul(anticipationDuration, 2)), fThrough, zeroValue);\n}\nfunction smartSmooth(axis) {\n    var startKey = nearestKey(time);\n    var endKey = startKey;\n    if (time == startKey.time)\n        return 0;\n    if (time < startKey.time && startKey.index == 1)\n        return 0;\n    if (time > startKey.time && startKey.index == numKeys)\n        return 0;\n    if (time < startKey.time)\n        startKey = key($bm_sub(startKey.index, 1));\n    if (time > startKey.time)\n        endKey = key($bm_sum(startKey.index, 1));\n    var sI = 0.66;\n    var sO = 0.33;\n    var sIV = 1;\n    var sOV = 0;\n    var sVal = startKey.value;\n    var eVal = endKey.value;\n    if ($bm_isInstanceOfArray(value)) {\n        sVal = sVal[axis];\n        eVal = eVal[axis];\n    }\n    var sTime = startKey.time;\n    var eTime = endKey.time;\n    if (isKeyTop(startKey, axis))\n        sO = slowOut;\n    else {\n        var prevKey = key($bm_sub(startKey.index, 1));\n        var pVal = prevKey.value;\n        if ($bm_isInstanceOfArray(value))\n            pVal = pVal[axis];\n        sOV = $bm_div($bm_sub(sVal, pVal), $bm_sub(eVal, pVal));\n    }\n    if (isKeyTop(endKey, axis)) {\n        sI = slowIn;\n        if (endKey.index != numKeys) {\n            var nextKey = key($bm_sum(endKey.index, 1));\n            var nVal = nextKey.value;\n            if ($bm_isInstanceOfArray(value))\n                nVal = nVal[axis];\n            if (Math.abs(nVal - eVal) < 0.01 && doFollowThrough)\n                sI = 1;\n        }\n    } else {\n        var nextKey = key($bm_sum(endKey.index, 1));\n        var nVal = nextKey.value;\n        if ($bm_isInstanceOfArray(value))\n            nVal = nVal[axis];\n        sIV = $bm_div($bm_sub(eVal, sVal), $bm_sub(nVal, sVal));\n    }\n    if (endKey.index == numKeys && doFollowThrough) {\n        sI = 1;\n    }\n    var val = value;\n    if ($bm_isInstanceOfArray(value))\n        val = val[axis];\n    return $bm_sub(bezierInterpolation(time, sTime, eTime, sVal, eVal, [\n        sO,\n        sOV,\n        sI,\n        sIV\n    ]), val);\n}\nfunction overlap() {\n    var ol = zeroValue;\n    if (isThisPosition && !hasParent)\n        return zeroValue;\n    ol = $bm_sub(getPropWorldValue($bm_sub(time, overlapDuration), thisProperty), getPropWorldValue(time, thisProperty));\n    var motionRatio = $bm_div($bm_div(length(zeroValue, ol), thisLayer.width), 2);\n    if (isThisPosition) {\n        var originalDistance = length(valueAtTime(0));\n        motionRatio = $bm_div(length(zeroValue, ol), thisComp.width);\n    }\n    ol = $bm_sum(ol, getPropWorldValue(time, thisProperty));\n    ol = $bm_sum(ol, $bm_mul($bm_mul($bm_sub(getPropWorldValue($bm_sub(time, overlapDuration), thisLayer.anchorPoint), ol), motionRatio), flexibility));\n    ol = thisLayer.fromWorld(ol);\n    if (!isThisPosition)\n        ol = $bm_sub(ol, value);\n    else {\n        ol = linear(flexibility, 0, 100, $bm_div(ol, 2), 0);\n        var prevParentWorldPos = getLayerWorldPos($bm_sub(time, overlapDuration), parent);\n        ol = $bm_sum(ol, $bm_mul($bm_mul($bm_mul(thisLayer.fromWorld(prevParentWorldPos), motionRatio), flexibility), 5));\n    }\n    return ol;\n}\nvar okToGo = false;\nif (simulate && fx.enabled)\n    okToGo = true;\nelse if (numKeys > 1 && fx.enabled)\n    okToGo = true;\nif (okToGo) {\n    var smartSmoothResult = zeroValue;\n    if (doInterpolation) {\n        if ($bm_isInstanceOfArray(value)) {\n            if (value.length == 2)\n                smartSmoothResult = [\n                    smartSmooth(0),\n                    smartSmooth(1)\n                ];\n            else if (value.length == 3)\n                smartSmoothResult = [\n                    smartSmooth(0),\n                    smartSmooth(1),\n                    smartSmooth(2)\n                ];\n            else if (value.length == 4)\n                smartSmoothResult = [\n                    smartSmooth(0),\n                    smartSmooth(1),\n                    smartSmooth(2),\n                    smartSmooth(3)\n                ];\n        } else {\n            smartSmoothResult = smartSmooth(0);\n        }\n    }\n    if (doAnticipation)\n        result = $bm_sum(result, anticipate());\n    result = $bm_sum(result, smartSmoothResult);\n    if (doFollowThrough)\n        result = $bm_sum(result, followThrough());\n    if (doOverlap)\n        result = $bm_sum(result, overlap());\n}\n$bm_rt = result;"
                  },
                  "s": {
                    "a": 0,
                    "k": [100.0, 100.0],
                    "x": "var $bm_rt;\nvar fx = effect('\u015dlosilo pli pura 3');\nvar doAnticipation = fx(1).value;\nvar doInterpolation = fx(2).value;\nvar doFollowThrough = fx(3).value;\nvar damping = $bm_div(fx(15).value, 10);\nvar elasticity = $bm_div(fx(13).value, 10);\nvar bounce = fx(17).value;\nvar anticipationDuration = fx(5).value;\nvar anticipationQuantity = $bm_div(fx(6).value, 100);\nvar slowIn = $bm_div(fx(9).value, 100);\nvar slowOut = $bm_div(fx(10).value, 100);\nvar spatialMode = fx(21).value;\nvar spatialDoInterpolation = fx(20).value;\nvar moBlurPrecision = fx(32).value;\nvar elasticityRandom = fx(14).value;\nvar dampingRandom = fx(16).value;\nvar softBody = fx(28).value;\nvar flexibility = $bm_div(fx(29).value, 100);\nvar doOverlap = fx(23).value;\nvar overlapDuration = fx(24).value;\nvar overlapRandom = fx(25).value;\nvar threshold = $bm_div($bm_div(1, moBlurPrecision), 1000);\nvar zeroValue;\nif ($bm_isInstanceOfArray(value)) {\n    if (value.length == 2)\n        zeroValue = [\n            0,\n            0\n        ];\n    else if (value.length == 3)\n        zeroValue = [\n            0,\n            0,\n            0\n        ];\n    else if (value.length == 4)\n        zeroValue = [\n            0,\n            0,\n            0,\n            0\n        ];\n} else\n    zeroValue = 0;\nvar isThisSpatial = isSpatial(thisProperty);\nvar isThisPosition = thisProperty === $bm_transform.position;\nvar simulate = false;\nif (isThisSpatial) {\n    doInterpolation = doInterpolation && spatialDoInterpolation;\n    if (isThisPosition && thisProperty.numKeys > 0) {\n        doOverlap = false;\n        simulate = false;\n    } else {\n        simulate = spatialMode == 2;\n        doOverlap = overlapDuration != 0 && doOverlap && simulate;\n    }\n} else {\n    doOverlap = false;\n}\nif (!doOverlap) {\n    overlapDuration = 0;\n}\nif (simulate && softBody && isThisSpatial && !isThisPosition && (doFollowThrough || doOverlap)) {\n    var distanceRatio = $bm_div(length(valueAtTime(0), $bm_transform.anchorPoint), $bm_div(thisLayer.width, 2));\n    distanceRatio = $bm_div($bm_sum(1, $bm_mul(distanceRatio, flexibility)), 2);\n    if (doFollowThrough) {\n        elasticity = $bm_div(elasticity, distanceRatio);\n        damping = $bm_div(damping, distanceRatio);\n    }\n    if (doOverlap) {\n        overlapDuration = $bm_mul(overlapDuration, distanceRatio);\n    }\n}\nseedRandom(0, true);\nif (doFollowThrough) {\n    if (elasticityRandom > 0)\n        elasticity = addNoise(elasticity, elasticityRandom);\n    if (dampingRandom > 0)\n        damping = addNoise(damping, dampingRandom);\n}\nif (doOverlap) {\n    if (doOverlap && overlapRandom > 0)\n        overlapDuration = addNoise(overlapDuration, overlapRandom);\n}\nvar result = value;\nfunction isSpatial(prop) {\n    if (!(prop.value instanceof Array))\n        return false;\n    if (prop.value.length != 2 && prop.value.length != 3)\n        return false;\n    try {\n        if (typeof prop.speed !== 'undefined')\n            return true;\n    } catch (e) {\n        return false;\n    }\n}\nfunction addNoise(val, quantity) {\n    var randomValue = random(0.9, 1.1);\n    var noiseValue = noise($bm_mul(valueAtTime(0), randomValue));\n    noiseValue = $bm_mul(noiseValue, $bm_div(quantity, 100));\n    return $bm_mul(val, $bm_sum(noiseValue, 1));\n}\nfunction isAfterLastKey() {\n    if (numKeys == 0)\n        return false;\n    var nKey = nearestKey(time);\n    return nKey.time <= time && nKey.index == numKeys;\n}\nfunction isStill(t, threshold) {\n    var d = $bm_sub(valueAtTime(t), valueAtTime($bm_sum(t, framesToTime(1))));\n    if ($bm_isInstanceOfArray(d)) {\n        for (var i = 0; i < d.length; i++) {\n            d[i] = Math.abs(d[i]);\n            if (d[i] >= threshold) {\n                return false;\n            }\n        }\n        return true;\n    } else {\n        d = Math.abs(d);\n        return d < threshold;\n    }\n}\nfunction bezierInterpolation(t, tMin, tMax, value1, value2, bezierPoints) {\n    if (arguments.length !== 5 && arguments.length !== 6)\n        return t;\n    var a = $bm_sub(value2, value1);\n    var b = $bm_sub(tMax, tMin);\n    if (b == 0)\n        return t;\n    var c = clamp($bm_div($bm_sub(t, tMin), b), 0, 1);\n    if (!(bezierPoints instanceof Array) || bezierPoints.length !== 4)\n        bezierPoints = [\n            0.33,\n            0,\n            0.66,\n            1\n        ];\n    return $bm_sum($bm_mul(a, h(c, bezierPoints)), value1);\n    function h(f, g) {\n        var x = $bm_mul(3, g[0]);\n        var j = $bm_sub($bm_mul(3, $bm_sub(g[2], g[0])), x);\n        var k = $bm_sub($bm_sub(1, x), j);\n        var l = $bm_mul(3, g[1]);\n        var m = $bm_sub($bm_mul(3, $bm_sub(g[3], g[1])), l);\n        var n = $bm_sub($bm_sub(1, l), m);\n        var d = f;\n        for (var i = 0; i < 5; i++) {\n            var z = $bm_sub($bm_mul(d, $bm_sum(x, $bm_mul(d, $bm_sum(j, $bm_mul(d, k))))), f);\n            if (Math.abs(z) < 0.001)\n                break;\n            d = $bm_sub(d, $bm_div(z, $bm_sum(x, $bm_mul(d, $bm_sum($bm_mul(2, j), $bm_mul($bm_mul(3, k), d))))));\n        }\n        return $bm_mul(d, $bm_sum(l, $bm_mul(d, $bm_sum(m, $bm_mul(d, n)))));\n    }\n}\nfunction getPropWorldSpeed(t, prop) {\n    return length(getPropWorldVelocity(t, prop));\n}\nfunction getPrevKey(t) {\n    if (numKeys == 0)\n        return null;\n    var nKey = nearestKey(t);\n    if (nKey.time <= t)\n        return nKey;\n    if (nKey.index > 1)\n        return key($bm_sub(nKey.index, 1));\n    return null;\n}\nfunction getNextKey(t) {\n    if (numKeys == 0)\n        return null;\n    var nKey = nearestKey(t);\n    if (nKey.time >= t)\n        return nKey;\n    if (nKey.index < numKeys)\n        return key($bm_sum(nKey.index, 1));\n    return null;\n}\nfunction getPropWorldVelocity(t, prop) {\n    return $bm_mul($bm_sub(getPropWorldValue($bm_sum(t, 0.005), prop), getPropWorldValue($bm_sub(t, 0.005), prop)), 100);\n}\nfunction getLayerWorldPos(t, l) {\n    return l.toWorld(l.anchorPoint, t);\n}\nfunction getPropWorldValue(t, prop) {\n    if (isPosition(prop))\n        return getLayerWorldPos(t, thisLayer);\n    return thisLayer.toWorld(prop.valueAtTime(t), t);\n}\nfunction isPosition(prop) {\n    return prop === $bm_transform.position;\n}\nfunction isKeyTop(k, axis) {\n    var prevSpeed = velocityAtTime($bm_sub(k.time, threshold));\n    var nextSpeed = velocityAtTime($bm_sum(k.time, threshold));\n    if ($bm_isInstanceOfArray(value)) {\n        prevSpeed = prevSpeed[axis];\n        nextSpeed = nextSpeed[axis];\n    }\n    if (Math.abs(prevSpeed) < 0.01 || Math.abs(nextSpeed) < 0.01)\n        return true;\n    return $bm_mul(prevSpeed, nextSpeed) < 0;\n}\nfunction anticipate() {\n    var anticipation = zeroValue;\n    if (isAfterLastKey())\n        return anticipation;\n    if (numKeys < 2)\n        return anticipation;\n    var nextKey = getNextKey(time);\n    var aKey = nextKey;\n    if (!isStill(aKey.time - 0.1, 0.1)) {\n        aKey = getPrevKey(time);\n        if (!isStill(aKey.time - 0.1, 0.1))\n            return anticipation;\n    }\n    if (aKey.index == numKeys)\n        return anticipation;\n    var anticipationMiddle = aKey.time;\n    var anticipationStart = $bm_sub(anticipationMiddle, anticipationDuration);\n    var anticipationEnd = key(aKey.index + 1).time;\n    var startValue = anticipation;\n    var midValue = $bm_mul($bm_sum($bm_neg(valueAtTime($bm_sum(anticipationMiddle, anticipationDuration))), aKey.value), anticipationQuantity);\n    var endValue = anticipation;\n    if (time < anticipationStart) {\n        return anticipation;\n    } else if (time < anticipationMiddle) {\n        if ($bm_isInstanceOfArray(value)) {\n            for (var i = 0; i < value.length; i++) {\n                anticipation[i] = bezierInterpolation(time, anticipationStart, anticipationMiddle, startValue[i], midValue[i], [\n                    slowOut,\n                    0,\n                    slowIn,\n                    1\n                ]);\n            }\n            return anticipation;\n        } else {\n            return bezierInterpolation(time, anticipationStart, anticipationMiddle, startValue, midValue, [\n                slowOut,\n                0,\n                slowIn,\n                1\n            ]);\n        }\n    } else if (time <= anticipationEnd) {\n        if ($bm_isInstanceOfArray(value)) {\n            for (var i = 0; i < value.length; i++) {\n                anticipation[i] = bezierInterpolation(time, anticipationMiddle, anticipationEnd, midValue[i], endValue[i], [\n                    slowOut,\n                    0,\n                    slowIn,\n                    1\n                ]);\n            }\n            return anticipation;\n        } else {\n            return bezierInterpolation(time, anticipationMiddle, anticipationEnd, midValue, endValue, [\n                slowOut,\n                0,\n                slowIn,\n                1\n            ]);\n        }\n    } else {\n        return anticipation;\n    }\n}\nfunction followThroughAtTime(t) {\n    var fThrough = zeroValue;\n    if (elasticity == 0)\n        return fThrough;\n    var propSpeed;\n    if (!simulate) {\n        if (numKeys < 2)\n            return fThrough;\n        if (nearestKey(t).index == 1)\n            return fThrough;\n        propSpeed = length(velocityAtTime(t));\n        if (propSpeed >= threshold)\n            return fThrough;\n    } else {\n        propSpeed = getPropWorldSpeed(t, thisProperty);\n        if (propSpeed >= threshold)\n            return fThrough;\n    }\n    var fThroughStart = 0;\n    var fThroughTime = 0;\n    if (simulate) {\n        var speedI = getPropWorldSpeed(t, thisProperty);\n        var i = t;\n        while (speedI < threshold && i > 0) {\n            i = $bm_sub(i, $bm_div(thisComp.frameDuration, moBlurPrecision));\n            speedI = getPropWorldSpeed(i, thisProperty);\n        }\n        fThroughStart = i;\n    } else {\n        var fThroughKey = getPrevKey(t);\n        fThroughStart = fThroughKey.time;\n    }\n    if (fThroughStart == 0)\n        return fThrough;\n    fThroughTime = $bm_sub(t, fThroughStart);\n    if (simulate)\n        fThrough = $bm_div(getPropWorldVelocity($bm_sub(fThroughStart, thisComp.frameDuration), thisProperty), 2);\n    else\n        fThrough = $bm_div(velocityAtTime($bm_sub(fThroughStart, thisComp.frameDuration)), 2);\n    if (bounce) {\n        var cycleDamp = Math.exp($bm_mul($bm_mul(fThroughTime, damping), 0.1));\n        var damp = $bm_div(Math.exp($bm_mul(fThroughTime, damping)), $bm_div(elasticity, 2));\n        var cycleDuration = $bm_div(1, $bm_mul(elasticity, 2));\n        cycleDuration = Math.round(timeToFrames(cycleDuration));\n        cycleDuration = framesToTime(cycleDuration);\n        var midDuration = $bm_div(cycleDuration, 2);\n        var maxValue = $bm_mul(fThrough, midDuration);\n        var cycvarime = fThroughTime;\n        var numEndCycles = 1;\n        while (cycvarime > cycleDuration) {\n            cycvarime = $bm_sub(cycvarime, cycleDuration);\n            cycleDuration = $bm_div(cycleDuration, cycleDamp);\n            cycleDuration = Math.round(timeToFrames(cycleDuration));\n            if (cycleDuration < 2) {\n                cycleDuration = 2;\n                numEndCycles++;\n            }\n            cycleDuration = framesToTime(cycleDuration);\n            midDuration = $bm_div(cycleDuration, 2);\n            maxValue = $bm_div($bm_mul(fThrough, midDuration), damp);\n            if (numEndCycles > 100 / damping && maxValue < threshold)\n                return zeroValue;\n        }\n        if (cycvarime < midDuration)\n            fThrough = bezierInterpolation(cycvarime, 0, midDuration, 0, maxValue, [\n                0,\n                0.1,\n                slowIn,\n                1\n            ]);\n        else\n            fThrough = bezierInterpolation(cycvarime, midDuration, cycleDuration, maxValue, 0, [\n                $bm_sub(1, slowIn),\n                0,\n                1,\n                0.9\n            ]);\n    } else {\n        var damp = Math.exp($bm_mul(fThroughTime, damping));\n        var sinus = $bm_mul($bm_mul($bm_mul(elasticity, fThroughTime), 2), Math.PI);\n        sinus = Math.sin(sinus);\n        sinus = $bm_mul($bm_div(0.3, elasticity), sinus);\n        sinus = $bm_div(sinus, damp);\n        if (Math.abs(sinus) < $bm_div(threshold, 100))\n            return 0;\n        fThrough = $bm_mul(fThrough, sinus);\n        if (threshold > 0) {\n            fThrough = $bm_mul(fThrough, $bm_sub(1, $bm_div(propSpeed, threshold)));\n        }\n    }\n    if (bounce) {\n        var prevValue = valueAtTime($bm_sub(fThroughStart, thisComp.frameDuration));\n        var startValue = valueAtTime(fThroughStart);\n        if ($bm_isInstanceOfArray(value)) {\n            for (var i = 0; i < prevValue.length; i++) {\n                if (prevValue[i] > startValue[i])\n                    fThrough[i] = Math.abs(fThrough[i]);\n                if (prevValue[i] < startValue[i])\n                    fThrough[i] = $bm_neg(Math.abs(fThrough[i]));\n            }\n        } else {\n            if (prevValue > startValue)\n                fThrough = Math.abs(fThrough);\n            if (prevValue < startValue)\n                fThrough = $bm_neg(Math.abs(fThrough));\n        }\n    }\n    if (simulate) {\n        if (!isThisPosition) {\n            fThrough = $bm_sum(fThrough, getLayerWorldPos(time, thisLayer));\n            fThrough = $bm_sub(thisLayer.fromWorld(fThrough), thisLayer.anchorPoint);\n        } else if (thisLayer.hasParent) {\n            fThrough = $bm_sum(fThrough, getLayerWorldPos(time, thisLayer.parent));\n            fThrough = $bm_sub(thisLayer.parent.fromWorld(fThrough), thisLayer.parent.anchorPoint);\n        }\n    }\n    return fThrough;\n}\nfunction followThrough() {\n    var propSpeed = length(velocity);\n    if (propSpeed < threshold)\n        return followThroughAtTime($bm_sub(time, overlapDuration));\n    var fThrough = zeroValue;\n    var t = time;\n    while (t > 0) {\n        t = $bm_sub(t, thisComp.frameDuration);\n        if (simulate)\n            propSpeed = getPropWorldSpeed($bm_sub(t, overlapDuration), thisProperty);\n        else\n            propSpeed = length(velocityAtTime(t));\n        if (propSpeed < threshold) {\n            fThrough = followThroughAtTime($bm_sub(t, overlapDuration));\n            break;\n        }\n    }\n    return linear(time, t, $bm_sum(t, $bm_mul(anticipationDuration, 2)), fThrough, zeroValue);\n}\nfunction smartSmooth(axis) {\n    var startKey = nearestKey(time);\n    var endKey = startKey;\n    if (time == startKey.time)\n        return 0;\n    if (time < startKey.time && startKey.index == 1)\n        return 0;\n    if (time > startKey.time && startKey.index == numKeys)\n        return 0;\n    if (time < startKey.time)\n        startKey = key($bm_sub(startKey.index, 1));\n    if (time > startKey.time)\n        endKey = key($bm_sum(startKey.index, 1));\n    var sI = 0.66;\n    var sO = 0.33;\n    var sIV = 1;\n    var sOV = 0;\n    var sVal = startKey.value;\n    var eVal = endKey.value;\n    if ($bm_isInstanceOfArray(value)) {\n        sVal = sVal[axis];\n        eVal = eVal[axis];\n    }\n    var sTime = startKey.time;\n    var eTime = endKey.time;\n    if (isKeyTop(startKey, axis))\n        sO = slowOut;\n    else {\n        var prevKey = key($bm_sub(startKey.index, 1));\n        var pVal = prevKey.value;\n        if ($bm_isInstanceOfArray(value))\n            pVal = pVal[axis];\n        sOV = $bm_div($bm_sub(sVal, pVal), $bm_sub(eVal, pVal));\n    }\n    if (isKeyTop(endKey, axis)) {\n        sI = slowIn;\n        if (endKey.index != numKeys) {\n            var nextKey = key($bm_sum(endKey.index, 1));\n            var nVal = nextKey.value;\n            if ($bm_isInstanceOfArray(value))\n                nVal = nVal[axis];\n            if (Math.abs(nVal - eVal) < 0.01 && doFollowThrough)\n                sI = 1;\n        }\n    } else {\n        var nextKey = key($bm_sum(endKey.index, 1));\n        var nVal = nextKey.value;\n        if ($bm_isInstanceOfArray(value))\n            nVal = nVal[axis];\n        sIV = $bm_div($bm_sub(eVal, sVal), $bm_sub(nVal, sVal));\n    }\n    if (endKey.index == numKeys && doFollowThrough) {\n        sI = 1;\n    }\n    var val = value;\n    if ($bm_isInstanceOfArray(value))\n        val = val[axis];\n    return $bm_sub(bezierInterpolation(time, sTime, eTime, sVal, eVal, [\n        sO,\n        sOV,\n        sI,\n        sIV\n    ]), val);\n}\nfunction overlap() {\n    var ol = zeroValue;\n    if (isThisPosition && !hasParent)\n        return zeroValue;\n    ol = $bm_sub(getPropWorldValue($bm_sub(time, overlapDuration), thisProperty), getPropWorldValue(time, thisProperty));\n    var motionRatio = $bm_div($bm_div(length(zeroValue, ol), thisLayer.width), 2);\n    if (isThisPosition) {\n        var originalDistance = length(valueAtTime(0));\n        motionRatio = $bm_div(length(zeroValue, ol), thisComp.width);\n    }\n    ol = $bm_sum(ol, getPropWorldValue(time, thisProperty));\n    ol = $bm_sum(ol, $bm_mul($bm_mul($bm_sub(getPropWorldValue($bm_sub(time, overlapDuration), thisLayer.anchorPoint), ol), motionRatio), flexibility));\n    ol = thisLayer.fromWorld(ol);\n    if (!isThisPosition)\n        ol = $bm_sub(ol, value);\n    else {\n        ol = linear(flexibility, 0, 100, $bm_div(ol, 2), 0);\n        var prevParentWorldPos = getLayerWorldPos($bm_sub(time, overlapDuration), parent);\n        ol = $bm_sum(ol, $bm_mul($bm_mul($bm_mul(thisLayer.fromWorld(prevParentWorldPos), motionRatio), flexibility), 5));\n    }\n    return ol;\n}\nvar okToGo = false;\nif (simulate && fx.enabled)\n    okToGo = true;\nelse if (numKeys > 1 && fx.enabled)\n    okToGo = true;\nif (okToGo) {\n    var smartSmoothResult = zeroValue;\n    if (doInterpolation) {\n        if ($bm_isInstanceOfArray(value)) {\n            if (value.length == 2)\n                smartSmoothResult = [\n                    smartSmooth(0),\n                    smartSmooth(1)\n                ];\n            else if (value.length == 3)\n                smartSmoothResult = [\n                    smartSmooth(0),\n                    smartSmooth(1),\n                    smartSmooth(2)\n                ];\n            else if (value.length == 4)\n                smartSmoothResult = [\n                    smartSmooth(0),\n                    smartSmooth(1),\n                    smartSmooth(2),\n                    smartSmooth(3)\n                ];\n        } else {\n            smartSmoothResult = smartSmooth(0);\n        }\n    }\n    if (doAnticipation)\n        result = $bm_sum(result, anticipate());\n    result = $bm_sum(result, smartSmoothResult);\n    if (doFollowThrough)\n        result = $bm_sum(result, followThrough());\n    if (doOverlap)\n        result = $bm_sum(result, overlap());\n}\n$bm_rt = result;"
                  },
                  "nm": "Transform",
                  "sk": {
                    "a": 0,
                    "k": 0.0,
                    "x": "var $bm_rt;\nvar fx = effect('\u015dlosilo pli pura 3');\nvar doAnticipation = fx(1).value;\nvar doInterpolation = fx(2).value;\nvar doFollowThrough = fx(3).value;\nvar damping = $bm_div(fx(15).value, 10);\nvar elasticity = $bm_div(fx(13).value, 10);\nvar bounce = fx(17).value;\nvar anticipationDuration = fx(5).value;\nvar anticipationQuantity = $bm_div(fx(6).value, 100);\nvar slowIn = $bm_div(fx(9).value, 100);\nvar slowOut = $bm_div(fx(10).value, 100);\nvar spatialMode = fx(21).value;\nvar spatialDoInterpolation = fx(20).value;\nvar moBlurPrecision = fx(32).value;\nvar elasticityRandom = fx(14).value;\nvar dampingRandom = fx(16).value;\nvar softBody = fx(28).value;\nvar flexibility = $bm_div(fx(29).value, 100);\nvar doOverlap = fx(23).value;\nvar overlapDuration = fx(24).value;\nvar overlapRandom = fx(25).value;\nvar threshold = $bm_div($bm_div(1, moBlurPrecision), 1000);\nvar zeroValue;\nif ($bm_isInstanceOfArray(value)) {\n    if (value.length == 2)\n        zeroValue = [\n            0,\n            0\n        ];\n    else if (value.length == 3)\n        zeroValue = [\n            0,\n            0,\n            0\n        ];\n    else if (value.length == 4)\n        zeroValue = [\n            0,\n            0,\n            0,\n            0\n        ];\n} else\n    zeroValue = 0;\nvar isThisSpatial = isSpatial(thisProperty);\nvar isThisPosition = thisProperty === $bm_transform.position;\nvar simulate = false;\nif (isThisSpatial) {\n    doInterpolation = doInterpolation && spatialDoInterpolation;\n    if (isThisPosition && thisProperty.numKeys > 0) {\n        doOverlap = false;\n        simulate = false;\n    } else {\n        simulate = spatialMode == 2;\n        doOverlap = overlapDuration != 0 && doOverlap && simulate;\n    }\n} else {\n    doOverlap = false;\n}\nif (!doOverlap) {\n    overlapDuration = 0;\n}\nif (simulate && softBody && isThisSpatial && !isThisPosition && (doFollowThrough || doOverlap)) {\n    var distanceRatio = $bm_div(length(valueAtTime(0), $bm_transform.anchorPoint), $bm_div(thisLayer.width, 2));\n    distanceRatio = $bm_div($bm_sum(1, $bm_mul(distanceRatio, flexibility)), 2);\n    if (doFollowThrough) {\n        elasticity = $bm_div(elasticity, distanceRatio);\n        damping = $bm_div(damping, distanceRatio);\n    }\n    if (doOverlap) {\n        overlapDuration = $bm_mul(overlapDuration, distanceRatio);\n    }\n}\nseedRandom(0, true);\nif (doFollowThrough) {\n    if (elasticityRandom > 0)\n        elasticity = addNoise(elasticity, elasticityRandom);\n    if (dampingRandom > 0)\n        damping = addNoise(damping, dampingRandom);\n}\nif (doOverlap) {\n    if (doOverlap && overlapRandom > 0)\n        overlapDuration = addNoise(overlapDuration, overlapRandom);\n}\nvar result = value;\nfunction isSpatial(prop) {\n    if (!(prop.value instanceof Array))\n        return false;\n    if (prop.value.length != 2 && prop.value.length != 3)\n        return false;\n    try {\n        if (typeof prop.speed !== 'undefined')\n            return true;\n    } catch (e) {\n        return false;\n    }\n}\nfunction addNoise(val, quantity) {\n    var randomValue = random(0.9, 1.1);\n    var noiseValue = noise($bm_mul(valueAtTime(0), randomValue));\n    noiseValue = $bm_mul(noiseValue, $bm_div(quantity, 100));\n    return $bm_mul(val, $bm_sum(noiseValue, 1));\n}\nfunction isAfterLastKey() {\n    if (numKeys == 0)\n        return false;\n    var nKey = nearestKey(time);\n    return nKey.time <= time && nKey.index == numKeys;\n}\nfunction isStill(t, threshold) {\n    var d = $bm_sub(valueAtTime(t), valueAtTime($bm_sum(t, framesToTime(1))));\n    if ($bm_isInstanceOfArray(d)) {\n        for (var i = 0; i < d.length; i++) {\n            d[i] = Math.abs(d[i]);\n            if (d[i] >= threshold) {\n                return false;\n            }\n        }\n        return true;\n    } else {\n        d = Math.abs(d);\n        return d < threshold;\n    }\n}\nfunction bezierInterpolation(t, tMin, tMax, value1, value2, bezierPoints) {\n    if (arguments.length !== 5 && arguments.length !== 6)\n        return t;\n    var a = $bm_sub(value2, value1);\n    var b = $bm_sub(tMax, tMin);\n    if (b == 0)\n        return t;\n    var c = clamp($bm_div($bm_sub(t, tMin), b), 0, 1);\n    if (!(bezierPoints instanceof Array) || bezierPoints.length !== 4)\n        bezierPoints = [\n            0.33,\n            0,\n            0.66,\n            1\n        ];\n    return $bm_sum($bm_mul(a, h(c, bezierPoints)), value1);\n    function h(f, g) {\n        var x = $bm_mul(3, g[0]);\n        var j = $bm_sub($bm_mul(3, $bm_sub(g[2], g[0])), x);\n        var k = $bm_sub($bm_sub(1, x), j);\n        var l = $bm_mul(3, g[1]);\n        var m = $bm_sub($bm_mul(3, $bm_sub(g[3], g[1])), l);\n        var n = $bm_sub($bm_sub(1, l), m);\n        var d = f;\n        for (var i = 0; i < 5; i++) {\n            var z = $bm_sub($bm_mul(d, $bm_sum(x, $bm_mul(d, $bm_sum(j, $bm_mul(d, k))))), f);\n            if (Math.abs(z) < 0.001)\n                break;\n            d = $bm_sub(d, $bm_div(z, $bm_sum(x, $bm_mul(d, $bm_sum($bm_mul(2, j), $bm_mul($bm_mul(3, k), d))))));\n        }\n        return $bm_mul(d, $bm_sum(l, $bm_mul(d, $bm_sum(m, $bm_mul(d, n)))));\n    }\n}\nfunction getPropWorldSpeed(t, prop) {\n    return length(getPropWorldVelocity(t, prop));\n}\nfunction getPrevKey(t) {\n    if (numKeys == 0)\n        return null;\n    var nKey = nearestKey(t);\n    if (nKey.time <= t)\n        return nKey;\n    if (nKey.index > 1)\n        return key($bm_sub(nKey.index, 1));\n    return null;\n}\nfunction getNextKey(t) {\n    if (numKeys == 0)\n        return null;\n    var nKey = nearestKey(t);\n    if (nKey.time >= t)\n        return nKey;\n    if (nKey.index < numKeys)\n        return key($bm_sum(nKey.index, 1));\n    return null;\n}\nfunction getPropWorldVelocity(t, prop) {\n    return $bm_mul($bm_sub(getPropWorldValue($bm_sum(t, 0.005), prop), getPropWorldValue($bm_sub(t, 0.005), prop)), 100);\n}\nfunction getLayerWorldPos(t, l) {\n    return l.toWorld(l.anchorPoint, t);\n}\nfunction getPropWorldValue(t, prop) {\n    if (isPosition(prop))\n        return getLayerWorldPos(t, thisLayer);\n    return thisLayer.toWorld(prop.valueAtTime(t), t);\n}\nfunction isPosition(prop) {\n    return prop === $bm_transform.position;\n}\nfunction isKeyTop(k, axis) {\n    var prevSpeed = velocityAtTime($bm_sub(k.time, threshold));\n    var nextSpeed = velocityAtTime($bm_sum(k.time, threshold));\n    if ($bm_isInstanceOfArray(value)) {\n        prevSpeed = prevSpeed[axis];\n        nextSpeed = nextSpeed[axis];\n    }\n    if (Math.abs(prevSpeed) < 0.01 || Math.abs(nextSpeed) < 0.01)\n        return true;\n    return $bm_mul(prevSpeed, nextSpeed) < 0;\n}\nfunction anticipate() {\n    var anticipation = zeroValue;\n    if (isAfterLastKey())\n        return anticipation;\n    if (numKeys < 2)\n        return anticipation;\n    var nextKey = getNextKey(time);\n    var aKey = nextKey;\n    if (!isStill(aKey.time - 0.1, 0.1)) {\n        aKey = getPrevKey(time);\n        if (!isStill(aKey.time - 0.1, 0.1))\n            return anticipation;\n    }\n    if (aKey.index == numKeys)\n        return anticipation;\n    var anticipationMiddle = aKey.time;\n    var anticipationStart = $bm_sub(anticipationMiddle, anticipationDuration);\n    var anticipationEnd = key(aKey.index + 1).time;\n    var startValue = anticipation;\n    var midValue = $bm_mul($bm_sum($bm_neg(valueAtTime($bm_sum(anticipationMiddle, anticipationDuration))), aKey.value), anticipationQuantity);\n    var endValue = anticipation;\n    if (time < anticipationStart) {\n        return anticipation;\n    } else if (time < anticipationMiddle) {\n        if ($bm_isInstanceOfArray(value)) {\n            for (var i = 0; i < value.length; i++) {\n                anticipation[i] = bezierInterpolation(time, anticipationStart, anticipationMiddle, startValue[i], midValue[i], [\n                    slowOut,\n                    0,\n                    slowIn,\n                    1\n                ]);\n            }\n            return anticipation;\n        } else {\n            return bezierInterpolation(time, anticipationStart, anticipationMiddle, startValue, midValue, [\n                slowOut,\n                0,\n                slowIn,\n                1\n            ]);\n        }\n    } else if (time <= anticipationEnd) {\n        if ($bm_isInstanceOfArray(value)) {\n            for (var i = 0; i < value.length; i++) {\n                anticipation[i] = bezierInterpolation(time, anticipationMiddle, anticipationEnd, midValue[i], endValue[i], [\n                    slowOut,\n                    0,\n                    slowIn,\n                    1\n                ]);\n            }\n            return anticipation;\n        } else {\n            return bezierInterpolation(time, anticipationMiddle, anticipationEnd, midValue, endValue, [\n                slowOut,\n                0,\n                slowIn,\n                1\n            ]);\n        }\n    } else {\n        return anticipation;\n    }\n}\nfunction followThroughAtTime(t) {\n    var fThrough = zeroValue;\n    if (elasticity == 0)\n        return fThrough;\n    var propSpeed;\n    if (!simulate) {\n        if (numKeys < 2)\n            return fThrough;\n        if (nearestKey(t).index == 1)\n            return fThrough;\n        propSpeed = length(velocityAtTime(t));\n        if (propSpeed >= threshold)\n            return fThrough;\n    } else {\n        propSpeed = getPropWorldSpeed(t, thisProperty);\n        if (propSpeed >= threshold)\n            return fThrough;\n    }\n    var fThroughStart = 0;\n    var fThroughTime = 0;\n    if (simulate) {\n        var speedI = getPropWorldSpeed(t, thisProperty);\n        var i = t;\n        while (speedI < threshold && i > 0) {\n            i = $bm_sub(i, $bm_div(thisComp.frameDuration, moBlurPrecision));\n            speedI = getPropWorldSpeed(i, thisProperty);\n        }\n        fThroughStart = i;\n    } else {\n        var fThroughKey = getPrevKey(t);\n        fThroughStart = fThroughKey.time;\n    }\n    if (fThroughStart == 0)\n        return fThrough;\n    fThroughTime = $bm_sub(t, fThroughStart);\n    if (simulate)\n        fThrough = $bm_div(getPropWorldVelocity($bm_sub(fThroughStart, thisComp.frameDuration), thisProperty), 2);\n    else\n        fThrough = $bm_div(velocityAtTime($bm_sub(fThroughStart, thisComp.frameDuration)), 2);\n    if (bounce) {\n        var cycleDamp = Math.exp($bm_mul($bm_mul(fThroughTime, damping), 0.1));\n        var damp = $bm_div(Math.exp($bm_mul(fThroughTime, damping)), $bm_div(elasticity, 2));\n        var cycleDuration = $bm_div(1, $bm_mul(elasticity, 2));\n        cycleDuration = Math.round(timeToFrames(cycleDuration));\n        cycleDuration = framesToTime(cycleDuration);\n        var midDuration = $bm_div(cycleDuration, 2);\n        var maxValue = $bm_mul(fThrough, midDuration);\n        var cycvarime = fThroughTime;\n        var numEndCycles = 1;\n        while (cycvarime > cycleDuration) {\n            cycvarime = $bm_sub(cycvarime, cycleDuration);\n            cycleDuration = $bm_div(cycleDuration, cycleDamp);\n            cycleDuration = Math.round(timeToFrames(cycleDuration));\n            if (cycleDuration < 2) {\n                cycleDuration = 2;\n                numEndCycles++;\n            }\n            cycleDuration = framesToTime(cycleDuration);\n            midDuration = $bm_div(cycleDuration, 2);\n            maxValue = $bm_div($bm_mul(fThrough, midDuration), damp);\n            if (numEndCycles > 100 / damping && maxValue < threshold)\n                return zeroValue;\n        }\n        if (cycvarime < midDuration)\n            fThrough = bezierInterpolation(cycvarime, 0, midDuration, 0, maxValue, [\n                0,\n                0.1,\n                slowIn,\n                1\n            ]);\n        else\n            fThrough = bezierInterpolation(cycvarime, midDuration, cycleDuration, maxValue, 0, [\n                $bm_sub(1, slowIn),\n                0,\n                1,\n                0.9\n            ]);\n    } else {\n        var damp = Math.exp($bm_mul(fThroughTime, damping));\n        var sinus = $bm_mul($bm_mul($bm_mul(elasticity, fThroughTime), 2), Math.PI);\n        sinus = Math.sin(sinus);\n        sinus = $bm_mul($bm_div(0.3, elasticity), sinus);\n        sinus = $bm_div(sinus, damp);\n        if (Math.abs(sinus) < $bm_div(threshold, 100))\n            return 0;\n        fThrough = $bm_mul(fThrough, sinus);\n        if (threshold > 0) {\n            fThrough = $bm_mul(fThrough, $bm_sub(1, $bm_div(propSpeed, threshold)));\n        }\n    }\n    if (bounce) {\n        var prevValue = valueAtTime($bm_sub(fThroughStart, thisComp.frameDuration));\n        var startValue = valueAtTime(fThroughStart);\n        if ($bm_isInstanceOfArray(value)) {\n            for (var i = 0; i < prevValue.length; i++) {\n                if (prevValue[i] > startValue[i])\n                    fThrough[i] = Math.abs(fThrough[i]);\n                if (prevValue[i] < startValue[i])\n                    fThrough[i] = $bm_neg(Math.abs(fThrough[i]));\n            }\n        } else {\n            if (prevValue > startValue)\n                fThrough = Math.abs(fThrough);\n            if (prevValue < startValue)\n                fThrough = $bm_neg(Math.abs(fThrough));\n        }\n    }\n    if (simulate) {\n        if (!isThisPosition) {\n            fThrough = $bm_sum(fThrough, getLayerWorldPos(time, thisLayer));\n            fThrough = $bm_sub(thisLayer.fromWorld(fThrough), thisLayer.anchorPoint);\n        } else if (thisLayer.hasParent) {\n            fThrough = $bm_sum(fThrough, getLayerWorldPos(time, thisLayer.parent));\n            fThrough = $bm_sub(thisLayer.parent.fromWorld(fThrough), thisLayer.parent.anchorPoint);\n        }\n    }\n    return fThrough;\n}\nfunction followThrough() {\n    var propSpeed = length(velocity);\n    if (propSpeed < threshold)\n        return followThroughAtTime($bm_sub(time, overlapDuration));\n    var fThrough = zeroValue;\n    var t = time;\n    while (t > 0) {\n        t = $bm_sub(t, thisComp.frameDuration);\n        if (simulate)\n            propSpeed = getPropWorldSpeed($bm_sub(t, overlapDuration), thisProperty);\n        else\n            propSpeed = length(velocityAtTime(t));\n        if (propSpeed < threshold) {\n            fThrough = followThroughAtTime($bm_sub(t, overlapDuration));\n            break;\n        }\n    }\n    return linear(time, t, $bm_sum(t, $bm_mul(anticipationDuration, 2)), fThrough, zeroValue);\n}\nfunction smartSmooth(axis) {\n    var startKey = nearestKey(time);\n    var endKey = startKey;\n    if (time == startKey.time)\n        return 0;\n    if (time < startKey.time && startKey.index == 1)\n        return 0;\n    if (time > startKey.time && startKey.index == numKeys)\n        return 0;\n    if (time < startKey.time)\n        startKey = key($bm_sub(startKey.index, 1));\n    if (time > startKey.time)\n        endKey = key($bm_sum(startKey.index, 1));\n    var sI = 0.66;\n    var sO = 0.33;\n    var sIV = 1;\n    var sOV = 0;\n    var sVal = startKey.value;\n    var eVal = endKey.value;\n    if ($bm_isInstanceOfArray(value)) {\n        sVal = sVal[axis];\n        eVal = eVal[axis];\n    }\n    var sTime = startKey.time;\n    var eTime = endKey.time;\n    if (isKeyTop(startKey, axis))\n        sO = slowOut;\n    else {\n        var prevKey = key($bm_sub(startKey.index, 1));\n        var pVal = prevKey.value;\n        if ($bm_isInstanceOfArray(value))\n            pVal = pVal[axis];\n        sOV = $bm_div($bm_sub(sVal, pVal), $bm_sub(eVal, pVal));\n    }\n    if (isKeyTop(endKey, axis)) {\n        sI = slowIn;\n        if (endKey.index != numKeys) {\n            var nextKey = key($bm_sum(endKey.index, 1));\n            var nVal = nextKey.value;\n            if ($bm_isInstanceOfArray(value))\n                nVal = nVal[axis];\n            if (Math.abs(nVal - eVal) < 0.01 && doFollowThrough)\n                sI = 1;\n        }\n    } else {\n        var nextKey = key($bm_sum(endKey.index, 1));\n        var nVal = nextKey.value;\n        if ($bm_isInstanceOfArray(value))\n            nVal = nVal[axis];\n        sIV = $bm_div($bm_sub(eVal, sVal), $bm_sub(nVal, sVal));\n    }\n    if (endKey.index == numKeys && doFollowThrough) {\n        sI = 1;\n    }\n    var val = value;\n    if ($bm_isInstanceOfArray(value))\n        val = val[axis];\n    return $bm_sub(bezierInterpolation(time, sTime, eTime, sVal, eVal, [\n        sO,\n        sOV,\n        sI,\n        sIV\n    ]), val);\n}\nfunction overlap() {\n    var ol = zeroValue;\n    if (isThisPosition && !hasParent)\n        return zeroValue;\n    ol = $bm_sub(getPropWorldValue($bm_sub(time, overlapDuration), thisProperty), getPropWorldValue(time, thisProperty));\n    var motionRatio = $bm_div($bm_div(length(zeroValue, ol), thisLayer.width), 2);\n    if (isThisPosition) {\n        var originalDistance = length(valueAtTime(0));\n        motionRatio = $bm_div(length(zeroValue, ol), thisComp.width);\n    }\n    ol = $bm_sum(ol, getPropWorldValue(time, thisProperty));\n    ol = $bm_sum(ol, $bm_mul($bm_mul($bm_sub(getPropWorldValue($bm_sub(time, overlapDuration), thisLayer.anchorPoint), ol), motionRatio), flexibility));\n    ol = thisLayer.fromWorld(ol);\n    if (!isThisPosition)\n        ol = $bm_sub(ol, value);\n    else {\n        ol = linear(flexibility, 0, 100, $bm_div(ol, 2), 0);\n        var prevParentWorldPos = getLayerWorldPos($bm_sub(time, overlapDuration), parent);\n        ol = $bm_sum(ol, $bm_mul($bm_mul($bm_mul(thisLayer.fromWorld(prevParentWorldPos), motionRatio), flexibility), 5));\n    }\n    return ol;\n}\nvar okToGo = false;\nif (simulate && fx.enabled)\n    okToGo = true;\nelse if (numKeys > 1 && fx.enabled)\n    okToGo = true;\nif (okToGo) {\n    var smartSmoothResult = zeroValue;\n    if (doInterpolation) {\n        if ($bm_isInstanceOfArray(value)) {\n            if (value.length == 2)\n                smartSmoothResult = [\n                    smartSmooth(0),\n                    smartSmooth(1)\n                ];\n            else if (value.length == 3)\n                smartSmoothResult = [\n                    smartSmooth(0),\n                    smartSmooth(1),\n                    smartSmooth(2)\n                ];\n            else if (value.length == 4)\n                smartSmoothResult = [\n                    smartSmooth(0),\n                    smartSmooth(1),\n                    smartSmooth(2),\n                    smartSmooth(3)\n                ];\n        } else {\n            smartSmoothResult = smartSmooth(0);\n        }\n    }\n    if (doAnticipation)\n        result = $bm_sum(result, anticipate());\n    result = $bm_sum(result, smartSmoothResult);\n    if (doFollowThrough)\n        result = $bm_sum(result, followThrough());\n    if (doOverlap)\n        result = $bm_sum(result, overlap());\n}\n$bm_rt = result;"
                  },
                  "sa": { "a": 0, "k": 0.0 }
                }
              ]
            },
            {
              "ty": "gr",
              "nm": "Group 2",
              "bm": 0,
              "mn": "ADBE Vector Group",
              "it": [
                {
                  "ty": "sh",
                  "nm": "Path 1",
                  "mn": "ADBE Vector Shape - Group",
                  "ind": 0,
                  "ks": {
                    "k": {
                      "i": [
                        [-0.128, -5.829],
                        [-3.143, -5.502],
                        [-7.835, -2.298],
                        [-5.088, 1.125],
                        [-3.901, 3.679],
                        [-1.978, 4.921],
                        [-0.565, 4.132],
                        [1.364, 3.541],
                        [2.412, 1.348],
                        [2.99, 0.112],
                        [3.56, 0.134],
                        [6.163, -0.129],
                        [3.811, -4.282]
                      ],
                      "o": [
                        [0.139, 6.331],
                        [3.935, 6.887],
                        [5.032, 1.476],
                        [5.22, -1.154],
                        [3.898, -3.676],
                        [1.555, -3.869],
                        [0.514, -3.759],
                        [-0.975, -2.531],
                        [-2.633, -1.472],
                        [-3.56, -0.134],
                        [-6.16, -0.232],
                        [-5.443, 0.114],
                        [-3.844, 4.319]
                      ],
                      "v": [
                        [-96.62, -62.903],
                        [-91.634, -44.767],
                        [-72.684, -28.297],
                        [-57.111, -28.064],
                        [-43.505, -34.994],
                        [-34.822, -49.136],
                        [-31.612, -61.195],
                        [-32.391, -72.428],
                        [-37.913, -79.388],
                        [-46.833, -81.645],
                        [-57.513, -82.046],
                        [-76.001, -82.38],
                        [-91.327, -77.491]
                      ],
                      "c": true
                    },
                    "a": 0
                  }
                },
                {
                  "ty": "st",
                  "nm": "Stroke 1",
                  "bm": 0,
                  "mn": "ADBE Vector Graphic - Stroke",
                  "lc": 2,
                  "lj": 2,
                  "o": { "a": 0, "k": 100.0 },
                  "w": { "a": 0, "k": 0.684 },
                  "c": { "a": 0, "k": [0.0, 0.0, 0.0, 1.0] }
                },
                {
                  "ty": "fl",
                  "nm": "Fill 1",
                  "bm": 0,
                  "mn": "ADBE Vector Graphic - Fill",
                  "c": { "a": 0, "k": [1.0, 1.0, 1.0, 1.0] },
                  "o": { "a": 0, "k": 100.0 },
                  "r": 1
                },
                {
                  "ty": "tr",
                  "o": { "a": 0, "k": 100.0 },
                  "r": { "a": 0, "k": 0.0 },
                  "p": { "a": 0, "k": [0.0, 0.0] },
                  "a": { "a": 0, "k": [0.0, 0.0] },
                  "s": { "a": 0, "k": [100.0, 100.0] },
                  "nm": "Transform",
                  "sk": { "a": 0, "k": 0.0 },
                  "sa": { "a": 0, "k": 0.0 }
                }
              ]
            },
            {
              "ty": "gr",
              "nm": "Group 4",
              "bm": 0,
              "mn": "ADBE Vector Group",
              "it": [
                {
                  "ty": "gr",
                  "nm": "Group 3",
                  "bm": 0,
                  "mn": "ADBE Vector Group",
                  "it": [
                    {
                      "ty": "sh",
                      "nm": "Path 1",
                      "mn": "ADBE Vector Shape - Group",
                      "ind": 0,
                      "ks": {
                        "k": {
                          "i": [
                            [0.0, -3.168],
                            [17.303, 0.0],
                            [0.0, 3.168],
                            [-17.303, 0.0]
                          ],
                          "o": [
                            [0.0, 3.168],
                            [-17.303, 0.0],
                            [0.0, -3.168],
                            [17.303, 0.0]
                          ],
                          "v": [
                            [-32.62, -29.736],
                            [-63.949, -24.001],
                            [-95.279, -29.736],
                            [-63.949, -35.472]
                          ],
                          "c": true
                        },
                        "a": 0
                      }
                    },
                    {
                      "ty": "fl",
                      "nm": "Fill 1",
                      "bm": 0,
                      "mn": "ADBE Vector Graphic - Fill",
                      "c": { "a": 0, "k": [0.0, 0.0, 0.0, 1.0] },
                      "o": { "a": 0, "k": 100.0 },
                      "r": 1
                    },
                    {
                      "ty": "tr",
                      "o": { "a": 0, "k": 100.0 },
                      "r": { "a": 0, "k": 0.0 },
                      "p": { "a": 0, "k": [0.0, 0.0] },
                      "a": { "a": 0, "k": [0.0, 0.0] },
                      "s": { "a": 0, "k": [100.0, 100.0] },
                      "nm": "Transform",
                      "sk": { "a": 0, "k": 0.0 },
                      "sa": { "a": 0, "k": 0.0 }
                    }
                  ]
                },
                {
                  "ty": "tr",
                  "o": { "a": 0, "k": 100.0 },
                  "r": { "a": 0, "k": 0.0 },
                  "p": { "a": 0, "k": [-63.95, -29.736] },
                  "a": { "a": 0, "k": [-63.95, -29.736] },
                  "s": { "a": 0, "k": [100.0, 100.0] },
                  "nm": "Transform",
                  "sk": { "a": 0, "k": 0.0 },
                  "sa": { "a": 0, "k": 0.0 }
                }
              ]
            },
            {
              "ty": "gr",
              "nm": "Group 7",
              "bm": 0,
              "mn": "ADBE Vector Group",
              "it": [
                {
                  "ty": "gr",
                  "nm": "Group 3",
                  "bm": 0,
                  "mn": "ADBE Vector Group",
                  "it": [
                    {
                      "ty": "sh",
                      "nm": "Path 1",
                      "mn": "ADBE Vector Shape - Group",
                      "ind": 0,
                      "ks": {
                        "k": {
                          "i": [
                            [0.0, -3.168],
                            [17.303, 0.0],
                            [0.0, 3.168],
                            [-17.303, 0.0]
                          ],
                          "o": [
                            [0.0, 3.168],
                            [-17.303, 0.0],
                            [0.0, -3.168],
                            [17.303, 0.0]
                          ],
                          "v": [
                            [-32.62, -29.736],
                            [-63.949, -24.001],
                            [-95.279, -29.736],
                            [-63.949, -35.472]
                          ],
                          "c": true
                        },
                        "a": 0
                      }
                    },
                    {
                      "ty": "fl",
                      "nm": "Fill 1",
                      "bm": 0,
                      "mn": "ADBE Vector Graphic - Fill",
                      "c": { "a": 0, "k": [0.0, 0.0, 0.0, 1.0] },
                      "o": { "a": 0, "k": 100.0 },
                      "r": 1
                    },
                    {
                      "ty": "tr",
                      "o": { "a": 0, "k": 100.0 },
                      "r": { "a": 0, "k": 0.0 },
                      "p": { "a": 0, "k": [0.0, 0.0] },
                      "a": { "a": 0, "k": [0.0, 0.0] },
                      "s": { "a": 0, "k": [100.0, 100.0] },
                      "nm": "Transform",
                      "sk": { "a": 0, "k": 0.0 },
                      "sa": { "a": 0, "k": 0.0 }
                    }
                  ]
                },
                {
                  "ty": "tr",
                  "o": {
                    "a": 1,
                    "k": [
                      {
                        "i": { "x": [0.667], "y": [1] },
                        "o": { "x": [0.333], "y": [0] },
                        "t": 116,
                        "s": [10.0]
                      },
                      { "t": 120, "s": [0.0] }
                    ]
                  },
                  "r": { "a": 0, "k": 0.0 },
                  "p": {
                    "a": 0,
                    "k": [-63.95, -29.736],
                    "x": "var $bm_rt;\nvar fx = effect('\u015dlosilo pli pura 4');\nvar doAnticipation = fx(1).value;\nvar doInterpolation = fx(2).value;\nvar doFollowThrough = fx(3).value;\nvar damping = $bm_div(fx(15).value, 10);\nvar elasticity = $bm_div(fx(13).value, 10);\nvar bounce = fx(17).value;\nvar anticipationDuration = fx(5).value;\nvar anticipationQuantity = $bm_div(fx(6).value, 100);\nvar slowIn = $bm_div(fx(9).value, 100);\nvar slowOut = $bm_div(fx(10).value, 100);\nvar spatialMode = fx(21).value;\nvar spatialDoInterpolation = fx(20).value;\nvar moBlurPrecision = fx(32).value;\nvar elasticityRandom = fx(14).value;\nvar dampingRandom = fx(16).value;\nvar softBody = fx(28).value;\nvar flexibility = $bm_div(fx(29).value, 100);\nvar doOverlap = fx(23).value;\nvar overlapDuration = fx(24).value;\nvar overlapRandom = fx(25).value;\nvar threshold = $bm_div($bm_div(1, moBlurPrecision), 1000);\nvar zeroValue;\nif ($bm_isInstanceOfArray(value)) {\n    if (value.length == 2)\n        zeroValue = [\n            0,\n            0\n        ];\n    else if (value.length == 3)\n        zeroValue = [\n            0,\n            0,\n            0\n        ];\n    else if (value.length == 4)\n        zeroValue = [\n            0,\n            0,\n            0,\n            0\n        ];\n} else\n    zeroValue = 0;\nvar isThisSpatial = isSpatial(thisProperty);\nvar isThisPosition = thisProperty === $bm_transform.position;\nvar simulate = false;\nif (isThisSpatial) {\n    doInterpolation = doInterpolation && spatialDoInterpolation;\n    if (isThisPosition && thisProperty.numKeys > 0) {\n        doOverlap = false;\n        simulate = false;\n    } else {\n        simulate = spatialMode == 2;\n        doOverlap = overlapDuration != 0 && doOverlap && simulate;\n    }\n} else {\n    doOverlap = false;\n}\nif (!doOverlap) {\n    overlapDuration = 0;\n}\nif (simulate && softBody && isThisSpatial && !isThisPosition && (doFollowThrough || doOverlap)) {\n    var distanceRatio = $bm_div(length(valueAtTime(0), $bm_transform.anchorPoint), $bm_div(thisLayer.width, 2));\n    distanceRatio = $bm_div($bm_sum(1, $bm_mul(distanceRatio, flexibility)), 2);\n    if (doFollowThrough) {\n        elasticity = $bm_div(elasticity, distanceRatio);\n        damping = $bm_div(damping, distanceRatio);\n    }\n    if (doOverlap) {\n        overlapDuration = $bm_mul(overlapDuration, distanceRatio);\n    }\n}\nseedRandom(0, true);\nif (doFollowThrough) {\n    if (elasticityRandom > 0)\n        elasticity = addNoise(elasticity, elasticityRandom);\n    if (dampingRandom > 0)\n        damping = addNoise(damping, dampingRandom);\n}\nif (doOverlap) {\n    if (doOverlap && overlapRandom > 0)\n        overlapDuration = addNoise(overlapDuration, overlapRandom);\n}\nvar result = value;\nfunction isSpatial(prop) {\n    if (!(prop.value instanceof Array))\n        return false;\n    if (prop.value.length != 2 && prop.value.length != 3)\n        return false;\n    try {\n        if (typeof prop.speed !== 'undefined')\n            return true;\n    } catch (e) {\n        return false;\n    }\n}\nfunction addNoise(val, quantity) {\n    var randomValue = random(0.9, 1.1);\n    var noiseValue = noise($bm_mul(valueAtTime(0), randomValue));\n    noiseValue = $bm_mul(noiseValue, $bm_div(quantity, 100));\n    return $bm_mul(val, $bm_sum(noiseValue, 1));\n}\nfunction isAfterLastKey() {\n    if (numKeys == 0)\n        return false;\n    var nKey = nearestKey(time);\n    return nKey.time <= time && nKey.index == numKeys;\n}\nfunction isStill(t, threshold) {\n    var d = $bm_sub(valueAtTime(t), valueAtTime($bm_sum(t, framesToTime(1))));\n    if ($bm_isInstanceOfArray(d)) {\n        for (var i = 0; i < d.length; i++) {\n            d[i] = Math.abs(d[i]);\n            if (d[i] >= threshold) {\n                return false;\n            }\n        }\n        return true;\n    } else {\n        d = Math.abs(d);\n        return d < threshold;\n    }\n}\nfunction bezierInterpolation(t, tMin, tMax, value1, value2, bezierPoints) {\n    if (arguments.length !== 5 && arguments.length !== 6)\n        return t;\n    var a = $bm_sub(value2, value1);\n    var b = $bm_sub(tMax, tMin);\n    if (b == 0)\n        return t;\n    var c = clamp($bm_div($bm_sub(t, tMin), b), 0, 1);\n    if (!(bezierPoints instanceof Array) || bezierPoints.length !== 4)\n        bezierPoints = [\n            0.33,\n            0,\n            0.66,\n            1\n        ];\n    return $bm_sum($bm_mul(a, h(c, bezierPoints)), value1);\n    function h(f, g) {\n        var x = $bm_mul(3, g[0]);\n        var j = $bm_sub($bm_mul(3, $bm_sub(g[2], g[0])), x);\n        var k = $bm_sub($bm_sub(1, x), j);\n        var l = $bm_mul(3, g[1]);\n        var m = $bm_sub($bm_mul(3, $bm_sub(g[3], g[1])), l);\n        var n = $bm_sub($bm_sub(1, l), m);\n        var d = f;\n        for (var i = 0; i < 5; i++) {\n            var z = $bm_sub($bm_mul(d, $bm_sum(x, $bm_mul(d, $bm_sum(j, $bm_mul(d, k))))), f);\n            if (Math.abs(z) < 0.001)\n                break;\n            d = $bm_sub(d, $bm_div(z, $bm_sum(x, $bm_mul(d, $bm_sum($bm_mul(2, j), $bm_mul($bm_mul(3, k), d))))));\n        }\n        return $bm_mul(d, $bm_sum(l, $bm_mul(d, $bm_sum(m, $bm_mul(d, n)))));\n    }\n}\nfunction getPropWorldSpeed(t, prop) {\n    return length(getPropWorldVelocity(t, prop));\n}\nfunction getPrevKey(t) {\n    if (numKeys == 0)\n        return null;\n    var nKey = nearestKey(t);\n    if (nKey.time <= t)\n        return nKey;\n    if (nKey.index > 1)\n        return key($bm_sub(nKey.index, 1));\n    return null;\n}\nfunction getNextKey(t) {\n    if (numKeys == 0)\n        return null;\n    var nKey = nearestKey(t);\n    if (nKey.time >= t)\n        return nKey;\n    if (nKey.index < numKeys)\n        return key($bm_sum(nKey.index, 1));\n    return null;\n}\nfunction getPropWorldVelocity(t, prop) {\n    return $bm_mul($bm_sub(getPropWorldValue($bm_sum(t, 0.005), prop), getPropWorldValue($bm_sub(t, 0.005), prop)), 100);\n}\nfunction getLayerWorldPos(t, l) {\n    return l.toWorld(l.anchorPoint, t);\n}\nfunction getPropWorldValue(t, prop) {\n    if (isPosition(prop))\n        return getLayerWorldPos(t, thisLayer);\n    return thisLayer.toWorld(prop.valueAtTime(t), t);\n}\nfunction isPosition(prop) {\n    return prop === $bm_transform.position;\n}\nfunction isKeyTop(k, axis) {\n    var prevSpeed = velocityAtTime($bm_sub(k.time, threshold));\n    var nextSpeed = velocityAtTime($bm_sum(k.time, threshold));\n    if ($bm_isInstanceOfArray(value)) {\n        prevSpeed = prevSpeed[axis];\n        nextSpeed = nextSpeed[axis];\n    }\n    if (Math.abs(prevSpeed) < 0.01 || Math.abs(nextSpeed) < 0.01)\n        return true;\n    return $bm_mul(prevSpeed, nextSpeed) < 0;\n}\nfunction anticipate() {\n    var anticipation = zeroValue;\n    if (isAfterLastKey())\n        return anticipation;\n    if (numKeys < 2)\n        return anticipation;\n    var nextKey = getNextKey(time);\n    var aKey = nextKey;\n    if (!isStill(aKey.time - 0.1, 0.1)) {\n        aKey = getPrevKey(time);\n        if (!isStill(aKey.time - 0.1, 0.1))\n            return anticipation;\n    }\n    if (aKey.index == numKeys)\n        return anticipation;\n    var anticipationMiddle = aKey.time;\n    var anticipationStart = $bm_sub(anticipationMiddle, anticipationDuration);\n    var anticipationEnd = key(aKey.index + 1).time;\n    var startValue = anticipation;\n    var midValue = $bm_mul($bm_sum($bm_neg(valueAtTime($bm_sum(anticipationMiddle, anticipationDuration))), aKey.value), anticipationQuantity);\n    var endValue = anticipation;\n    if (time < anticipationStart) {\n        return anticipation;\n    } else if (time < anticipationMiddle) {\n        if ($bm_isInstanceOfArray(value)) {\n            for (var i = 0; i < value.length; i++) {\n                anticipation[i] = bezierInterpolation(time, anticipationStart, anticipationMiddle, startValue[i], midValue[i], [\n                    slowOut,\n                    0,\n                    slowIn,\n                    1\n                ]);\n            }\n            return anticipation;\n        } else {\n            return bezierInterpolation(time, anticipationStart, anticipationMiddle, startValue, midValue, [\n                slowOut,\n                0,\n                slowIn,\n                1\n            ]);\n        }\n    } else if (time <= anticipationEnd) {\n        if ($bm_isInstanceOfArray(value)) {\n            for (var i = 0; i < value.length; i++) {\n                anticipation[i] = bezierInterpolation(time, anticipationMiddle, anticipationEnd, midValue[i], endValue[i], [\n                    slowOut,\n                    0,\n                    slowIn,\n                    1\n                ]);\n            }\n            return anticipation;\n        } else {\n            return bezierInterpolation(time, anticipationMiddle, anticipationEnd, midValue, endValue, [\n                slowOut,\n                0,\n                slowIn,\n                1\n            ]);\n        }\n    } else {\n        return anticipation;\n    }\n}\nfunction followThroughAtTime(t) {\n    var fThrough = zeroValue;\n    if (elasticity == 0)\n        return fThrough;\n    var propSpeed;\n    if (!simulate) {\n        if (numKeys < 2)\n            return fThrough;\n        if (nearestKey(t).index == 1)\n            return fThrough;\n        propSpeed = length(velocityAtTime(t));\n        if (propSpeed >= threshold)\n            return fThrough;\n    } else {\n        propSpeed = getPropWorldSpeed(t, thisProperty);\n        if (propSpeed >= threshold)\n            return fThrough;\n    }\n    var fThroughStart = 0;\n    var fThroughTime = 0;\n    if (simulate) {\n        var speedI = getPropWorldSpeed(t, thisProperty);\n        var i = t;\n        while (speedI < threshold && i > 0) {\n            i = $bm_sub(i, $bm_div(thisComp.frameDuration, moBlurPrecision));\n            speedI = getPropWorldSpeed(i, thisProperty);\n        }\n        fThroughStart = i;\n    } else {\n        var fThroughKey = getPrevKey(t);\n        fThroughStart = fThroughKey.time;\n    }\n    if (fThroughStart == 0)\n        return fThrough;\n    fThroughTime = $bm_sub(t, fThroughStart);\n    if (simulate)\n        fThrough = $bm_div(getPropWorldVelocity($bm_sub(fThroughStart, thisComp.frameDuration), thisProperty), 2);\n    else\n        fThrough = $bm_div(velocityAtTime($bm_sub(fThroughStart, thisComp.frameDuration)), 2);\n    if (bounce) {\n        var cycleDamp = Math.exp($bm_mul($bm_mul(fThroughTime, damping), 0.1));\n        var damp = $bm_div(Math.exp($bm_mul(fThroughTime, damping)), $bm_div(elasticity, 2));\n        var cycleDuration = $bm_div(1, $bm_mul(elasticity, 2));\n        cycleDuration = Math.round(timeToFrames(cycleDuration));\n        cycleDuration = framesToTime(cycleDuration);\n        var midDuration = $bm_div(cycleDuration, 2);\n        var maxValue = $bm_mul(fThrough, midDuration);\n        var cycvarime = fThroughTime;\n        var numEndCycles = 1;\n        while (cycvarime > cycleDuration) {\n            cycvarime = $bm_sub(cycvarime, cycleDuration);\n            cycleDuration = $bm_div(cycleDuration, cycleDamp);\n            cycleDuration = Math.round(timeToFrames(cycleDuration));\n            if (cycleDuration < 2) {\n                cycleDuration = 2;\n                numEndCycles++;\n            }\n            cycleDuration = framesToTime(cycleDuration);\n            midDuration = $bm_div(cycleDuration, 2);\n            maxValue = $bm_div($bm_mul(fThrough, midDuration), damp);\n            if (numEndCycles > 100 / damping && maxValue < threshold)\n                return zeroValue;\n        }\n        if (cycvarime < midDuration)\n            fThrough = bezierInterpolation(cycvarime, 0, midDuration, 0, maxValue, [\n                0,\n                0.1,\n                slowIn,\n                1\n            ]);\n        else\n            fThrough = bezierInterpolation(cycvarime, midDuration, cycleDuration, maxValue, 0, [\n                $bm_sub(1, slowIn),\n                0,\n                1,\n                0.9\n            ]);\n    } else {\n        var damp = Math.exp($bm_mul(fThroughTime, damping));\n        var sinus = $bm_mul($bm_mul($bm_mul(elasticity, fThroughTime), 2), Math.PI);\n        sinus = Math.sin(sinus);\n        sinus = $bm_mul($bm_div(0.3, elasticity), sinus);\n        sinus = $bm_div(sinus, damp);\n        if (Math.abs(sinus) < $bm_div(threshold, 100))\n            return 0;\n        fThrough = $bm_mul(fThrough, sinus);\n        if (threshold > 0) {\n            fThrough = $bm_mul(fThrough, $bm_sub(1, $bm_div(propSpeed, threshold)));\n        }\n    }\n    if (bounce) {\n        var prevValue = valueAtTime($bm_sub(fThroughStart, thisComp.frameDuration));\n        var startValue = valueAtTime(fThroughStart);\n        if ($bm_isInstanceOfArray(value)) {\n            for (var i = 0; i < prevValue.length; i++) {\n                if (prevValue[i] > startValue[i])\n                    fThrough[i] = Math.abs(fThrough[i]);\n                if (prevValue[i] < startValue[i])\n                    fThrough[i] = $bm_neg(Math.abs(fThrough[i]));\n            }\n        } else {\n            if (prevValue > startValue)\n                fThrough = Math.abs(fThrough);\n            if (prevValue < startValue)\n                fThrough = $bm_neg(Math.abs(fThrough));\n        }\n    }\n    if (simulate) {\n        if (!isThisPosition) {\n            fThrough = $bm_sum(fThrough, getLayerWorldPos(time, thisLayer));\n            fThrough = $bm_sub(thisLayer.fromWorld(fThrough), thisLayer.anchorPoint);\n        } else if (thisLayer.hasParent) {\n            fThrough = $bm_sum(fThrough, getLayerWorldPos(time, thisLayer.parent));\n            fThrough = $bm_sub(thisLayer.parent.fromWorld(fThrough), thisLayer.parent.anchorPoint);\n        }\n    }\n    return fThrough;\n}\nfunction followThrough() {\n    var propSpeed = length(velocity);\n    if (propSpeed < threshold)\n        return followThroughAtTime($bm_sub(time, overlapDuration));\n    var fThrough = zeroValue;\n    var t = time;\n    while (t > 0) {\n        t = $bm_sub(t, thisComp.frameDuration);\n        if (simulate)\n            propSpeed = getPropWorldSpeed($bm_sub(t, overlapDuration), thisProperty);\n        else\n            propSpeed = length(velocityAtTime(t));\n        if (propSpeed < threshold) {\n            fThrough = followThroughAtTime($bm_sub(t, overlapDuration));\n            break;\n        }\n    }\n    return linear(time, t, $bm_sum(t, $bm_mul(anticipationDuration, 2)), fThrough, zeroValue);\n}\nfunction smartSmooth(axis) {\n    var startKey = nearestKey(time);\n    var endKey = startKey;\n    if (time == startKey.time)\n        return 0;\n    if (time < startKey.time && startKey.index == 1)\n        return 0;\n    if (time > startKey.time && startKey.index == numKeys)\n        return 0;\n    if (time < startKey.time)\n        startKey = key($bm_sub(startKey.index, 1));\n    if (time > startKey.time)\n        endKey = key($bm_sum(startKey.index, 1));\n    var sI = 0.66;\n    var sO = 0.33;\n    var sIV = 1;\n    var sOV = 0;\n    var sVal = startKey.value;\n    var eVal = endKey.value;\n    if ($bm_isInstanceOfArray(value)) {\n        sVal = sVal[axis];\n        eVal = eVal[axis];\n    }\n    var sTime = startKey.time;\n    var eTime = endKey.time;\n    if (isKeyTop(startKey, axis))\n        sO = slowOut;\n    else {\n        var prevKey = key($bm_sub(startKey.index, 1));\n        var pVal = prevKey.value;\n        if ($bm_isInstanceOfArray(value))\n            pVal = pVal[axis];\n        sOV = $bm_div($bm_sub(sVal, pVal), $bm_sub(eVal, pVal));\n    }\n    if (isKeyTop(endKey, axis)) {\n        sI = slowIn;\n        if (endKey.index != numKeys) {\n            var nextKey = key($bm_sum(endKey.index, 1));\n            var nVal = nextKey.value;\n            if ($bm_isInstanceOfArray(value))\n                nVal = nVal[axis];\n            if (Math.abs(nVal - eVal) < 0.01 && doFollowThrough)\n                sI = 1;\n        }\n    } else {\n        var nextKey = key($bm_sum(endKey.index, 1));\n        var nVal = nextKey.value;\n        if ($bm_isInstanceOfArray(value))\n            nVal = nVal[axis];\n        sIV = $bm_div($bm_sub(eVal, sVal), $bm_sub(nVal, sVal));\n    }\n    if (endKey.index == numKeys && doFollowThrough) {\n        sI = 1;\n    }\n    var val = value;\n    if ($bm_isInstanceOfArray(value))\n        val = val[axis];\n    return $bm_sub(bezierInterpolation(time, sTime, eTime, sVal, eVal, [\n        sO,\n        sOV,\n        sI,\n        sIV\n    ]), val);\n}\nfunction overlap() {\n    var ol = zeroValue;\n    if (isThisPosition && !hasParent)\n        return zeroValue;\n    ol = $bm_sub(getPropWorldValue($bm_sub(time, overlapDuration), thisProperty), getPropWorldValue(time, thisProperty));\n    var motionRatio = $bm_div($bm_div(length(zeroValue, ol), thisLayer.width), 2);\n    if (isThisPosition) {\n        var originalDistance = length(valueAtTime(0));\n        motionRatio = $bm_div(length(zeroValue, ol), thisComp.width);\n    }\n    ol = $bm_sum(ol, getPropWorldValue(time, thisProperty));\n    ol = $bm_sum(ol, $bm_mul($bm_mul($bm_sub(getPropWorldValue($bm_sub(time, overlapDuration), thisLayer.anchorPoint), ol), motionRatio), flexibility));\n    ol = thisLayer.fromWorld(ol);\n    if (!isThisPosition)\n        ol = $bm_sub(ol, value);\n    else {\n        ol = linear(flexibility, 0, 100, $bm_div(ol, 2), 0);\n        var prevParentWorldPos = getLayerWorldPos($bm_sub(time, overlapDuration), parent);\n        ol = $bm_sum(ol, $bm_mul($bm_mul($bm_mul(thisLayer.fromWorld(prevParentWorldPos), motionRatio), flexibility), 5));\n    }\n    return ol;\n}\nvar okToGo = false;\nif (simulate && fx.enabled)\n    okToGo = true;\nelse if (numKeys > 1 && fx.enabled)\n    okToGo = true;\nif (okToGo) {\n    var smartSmoothResult = zeroValue;\n    if (doInterpolation) {\n        if ($bm_isInstanceOfArray(value)) {\n            if (value.length == 2)\n                smartSmoothResult = [\n                    smartSmooth(0),\n                    smartSmooth(1)\n                ];\n            else if (value.length == 3)\n                smartSmoothResult = [\n                    smartSmooth(0),\n                    smartSmooth(1),\n                    smartSmooth(2)\n                ];\n            else if (value.length == 4)\n                smartSmoothResult = [\n                    smartSmooth(0),\n                    smartSmooth(1),\n                    smartSmooth(2),\n                    smartSmooth(3)\n                ];\n        } else {\n            smartSmoothResult = smartSmooth(0);\n        }\n    }\n    if (doAnticipation)\n        result = $bm_sum(result, anticipate());\n    result = $bm_sum(result, smartSmoothResult);\n    if (doFollowThrough)\n        result = $bm_sum(result, followThrough());\n    if (doOverlap)\n        result = $bm_sum(result, overlap());\n}\n$bm_rt = result;"
                  },
                  "a": { "a": 0, "k": [-63.95, -29.736] },
                  "s": {
                    "k": [
                      {
                        "i": { "x": [0.667, 0.667], "y": [1.0, 1.0] },
                        "o": { "x": [0.333, 0.333], "y": [0.0, 0.0] },
                        "t": 103,
                        "s": [100, 100]
                      },
                      { "t": 116, "s": [160, 160] }
                    ],
                    "x": "var $bm_rt;\nvar fx = effect('\u015dlosilo pli pura 4');\nvar doAnticipation = fx(1).value;\nvar doInterpolation = fx(2).value;\nvar doFollowThrough = fx(3).value;\nvar damping = $bm_div(fx(15).value, 10);\nvar elasticity = $bm_div(fx(13).value, 10);\nvar bounce = fx(17).value;\nvar anticipationDuration = fx(5).value;\nvar anticipationQuantity = $bm_div(fx(6).value, 100);\nvar slowIn = $bm_div(fx(9).value, 100);\nvar slowOut = $bm_div(fx(10).value, 100);\nvar spatialMode = fx(21).value;\nvar spatialDoInterpolation = fx(20).value;\nvar moBlurPrecision = fx(32).value;\nvar elasticityRandom = fx(14).value;\nvar dampingRandom = fx(16).value;\nvar softBody = fx(28).value;\nvar flexibility = $bm_div(fx(29).value, 100);\nvar doOverlap = fx(23).value;\nvar overlapDuration = fx(24).value;\nvar overlapRandom = fx(25).value;\nvar threshold = $bm_div($bm_div(1, moBlurPrecision), 1000);\nvar zeroValue;\nif ($bm_isInstanceOfArray(value)) {\n    if (value.length == 2)\n        zeroValue = [\n            0,\n            0\n        ];\n    else if (value.length == 3)\n        zeroValue = [\n            0,\n            0,\n            0\n        ];\n    else if (value.length == 4)\n        zeroValue = [\n            0,\n            0,\n            0,\n            0\n        ];\n} else\n    zeroValue = 0;\nvar isThisSpatial = isSpatial(thisProperty);\nvar isThisPosition = thisProperty === $bm_transform.position;\nvar simulate = false;\nif (isThisSpatial) {\n    doInterpolation = doInterpolation && spatialDoInterpolation;\n    if (isThisPosition && thisProperty.numKeys > 0) {\n        doOverlap = false;\n        simulate = false;\n    } else {\n        simulate = spatialMode == 2;\n        doOverlap = overlapDuration != 0 && doOverlap && simulate;\n    }\n} else {\n    doOverlap = false;\n}\nif (!doOverlap) {\n    overlapDuration = 0;\n}\nif (simulate && softBody && isThisSpatial && !isThisPosition && (doFollowThrough || doOverlap)) {\n    var distanceRatio = $bm_div(length(valueAtTime(0), $bm_transform.anchorPoint), $bm_div(thisLayer.width, 2));\n    distanceRatio = $bm_div($bm_sum(1, $bm_mul(distanceRatio, flexibility)), 2);\n    if (doFollowThrough) {\n        elasticity = $bm_div(elasticity, distanceRatio);\n        damping = $bm_div(damping, distanceRatio);\n    }\n    if (doOverlap) {\n        overlapDuration = $bm_mul(overlapDuration, distanceRatio);\n    }\n}\nseedRandom(0, true);\nif (doFollowThrough) {\n    if (elasticityRandom > 0)\n        elasticity = addNoise(elasticity, elasticityRandom);\n    if (dampingRandom > 0)\n        damping = addNoise(damping, dampingRandom);\n}\nif (doOverlap) {\n    if (doOverlap && overlapRandom > 0)\n        overlapDuration = addNoise(overlapDuration, overlapRandom);\n}\nvar result = value;\nfunction isSpatial(prop) {\n    if (!(prop.value instanceof Array))\n        return false;\n    if (prop.value.length != 2 && prop.value.length != 3)\n        return false;\n    try {\n        if (typeof prop.speed !== 'undefined')\n            return true;\n    } catch (e) {\n        return false;\n    }\n}\nfunction addNoise(val, quantity) {\n    var randomValue = random(0.9, 1.1);\n    var noiseValue = noise($bm_mul(valueAtTime(0), randomValue));\n    noiseValue = $bm_mul(noiseValue, $bm_div(quantity, 100));\n    return $bm_mul(val, $bm_sum(noiseValue, 1));\n}\nfunction isAfterLastKey() {\n    if (numKeys == 0)\n        return false;\n    var nKey = nearestKey(time);\n    return nKey.time <= time && nKey.index == numKeys;\n}\nfunction isStill(t, threshold) {\n    var d = $bm_sub(valueAtTime(t), valueAtTime($bm_sum(t, framesToTime(1))));\n    if ($bm_isInstanceOfArray(d)) {\n        for (var i = 0; i < d.length; i++) {\n            d[i] = Math.abs(d[i]);\n            if (d[i] >= threshold) {\n                return false;\n            }\n        }\n        return true;\n    } else {\n        d = Math.abs(d);\n        return d < threshold;\n    }\n}\nfunction bezierInterpolation(t, tMin, tMax, value1, value2, bezierPoints) {\n    if (arguments.length !== 5 && arguments.length !== 6)\n        return t;\n    var a = $bm_sub(value2, value1);\n    var b = $bm_sub(tMax, tMin);\n    if (b == 0)\n        return t;\n    var c = clamp($bm_div($bm_sub(t, tMin), b), 0, 1);\n    if (!(bezierPoints instanceof Array) || bezierPoints.length !== 4)\n        bezierPoints = [\n            0.33,\n            0,\n            0.66,\n            1\n        ];\n    return $bm_sum($bm_mul(a, h(c, bezierPoints)), value1);\n    function h(f, g) {\n        var x = $bm_mul(3, g[0]);\n        var j = $bm_sub($bm_mul(3, $bm_sub(g[2], g[0])), x);\n        var k = $bm_sub($bm_sub(1, x), j);\n        var l = $bm_mul(3, g[1]);\n        var m = $bm_sub($bm_mul(3, $bm_sub(g[3], g[1])), l);\n        var n = $bm_sub($bm_sub(1, l), m);\n        var d = f;\n        for (var i = 0; i < 5; i++) {\n            var z = $bm_sub($bm_mul(d, $bm_sum(x, $bm_mul(d, $bm_sum(j, $bm_mul(d, k))))), f);\n            if (Math.abs(z) < 0.001)\n                break;\n            d = $bm_sub(d, $bm_div(z, $bm_sum(x, $bm_mul(d, $bm_sum($bm_mul(2, j), $bm_mul($bm_mul(3, k), d))))));\n        }\n        return $bm_mul(d, $bm_sum(l, $bm_mul(d, $bm_sum(m, $bm_mul(d, n)))));\n    }\n}\nfunction getPropWorldSpeed(t, prop) {\n    return length(getPropWorldVelocity(t, prop));\n}\nfunction getPrevKey(t) {\n    if (numKeys == 0)\n        return null;\n    var nKey = nearestKey(t);\n    if (nKey.time <= t)\n        return nKey;\n    if (nKey.index > 1)\n        return key($bm_sub(nKey.index, 1));\n    return null;\n}\nfunction getNextKey(t) {\n    if (numKeys == 0)\n        return null;\n    var nKey = nearestKey(t);\n    if (nKey.time >= t)\n        return nKey;\n    if (nKey.index < numKeys)\n        return key($bm_sum(nKey.index, 1));\n    return null;\n}\nfunction getPropWorldVelocity(t, prop) {\n    return $bm_mul($bm_sub(getPropWorldValue($bm_sum(t, 0.005), prop), getPropWorldValue($bm_sub(t, 0.005), prop)), 100);\n}\nfunction getLayerWorldPos(t, l) {\n    return l.toWorld(l.anchorPoint, t);\n}\nfunction getPropWorldValue(t, prop) {\n    if (isPosition(prop))\n        return getLayerWorldPos(t, thisLayer);\n    return thisLayer.toWorld(prop.valueAtTime(t), t);\n}\nfunction isPosition(prop) {\n    return prop === $bm_transform.position;\n}\nfunction isKeyTop(k, axis) {\n    var prevSpeed = velocityAtTime($bm_sub(k.time, threshold));\n    var nextSpeed = velocityAtTime($bm_sum(k.time, threshold));\n    if ($bm_isInstanceOfArray(value)) {\n        prevSpeed = prevSpeed[axis];\n        nextSpeed = nextSpeed[axis];\n    }\n    if (Math.abs(prevSpeed) < 0.01 || Math.abs(nextSpeed) < 0.01)\n        return true;\n    return $bm_mul(prevSpeed, nextSpeed) < 0;\n}\nfunction anticipate() {\n    var anticipation = zeroValue;\n    if (isAfterLastKey())\n        return anticipation;\n    if (numKeys < 2)\n        return anticipation;\n    var nextKey = getNextKey(time);\n    var aKey = nextKey;\n    if (!isStill(aKey.time - 0.1, 0.1)) {\n        aKey = getPrevKey(time);\n        if (!isStill(aKey.time - 0.1, 0.1))\n            return anticipation;\n    }\n    if (aKey.index == numKeys)\n        return anticipation;\n    var anticipationMiddle = aKey.time;\n    var anticipationStart = $bm_sub(anticipationMiddle, anticipationDuration);\n    var anticipationEnd = key(aKey.index + 1).time;\n    var startValue = anticipation;\n    var midValue = $bm_mul($bm_sum($bm_neg(valueAtTime($bm_sum(anticipationMiddle, anticipationDuration))), aKey.value), anticipationQuantity);\n    var endValue = anticipation;\n    if (time < anticipationStart) {\n        return anticipation;\n    } else if (time < anticipationMiddle) {\n        if ($bm_isInstanceOfArray(value)) {\n            for (var i = 0; i < value.length; i++) {\n                anticipation[i] = bezierInterpolation(time, anticipationStart, anticipationMiddle, startValue[i], midValue[i], [\n                    slowOut,\n                    0,\n                    slowIn,\n                    1\n                ]);\n            }\n            return anticipation;\n        } else {\n            return bezierInterpolation(time, anticipationStart, anticipationMiddle, startValue, midValue, [\n                slowOut,\n                0,\n                slowIn,\n                1\n            ]);\n        }\n    } else if (time <= anticipationEnd) {\n        if ($bm_isInstanceOfArray(value)) {\n            for (var i = 0; i < value.length; i++) {\n                anticipation[i] = bezierInterpolation(time, anticipationMiddle, anticipationEnd, midValue[i], endValue[i], [\n                    slowOut,\n                    0,\n                    slowIn,\n                    1\n                ]);\n            }\n            return anticipation;\n        } else {\n            return bezierInterpolation(time, anticipationMiddle, anticipationEnd, midValue, endValue, [\n                slowOut,\n                0,\n                slowIn,\n                1\n            ]);\n        }\n    } else {\n        return anticipation;\n    }\n}\nfunction followThroughAtTime(t) {\n    var fThrough = zeroValue;\n    if (elasticity == 0)\n        return fThrough;\n    var propSpeed;\n    if (!simulate) {\n        if (numKeys < 2)\n            return fThrough;\n        if (nearestKey(t).index == 1)\n            return fThrough;\n        propSpeed = length(velocityAtTime(t));\n        if (propSpeed >= threshold)\n            return fThrough;\n    } else {\n        propSpeed = getPropWorldSpeed(t, thisProperty);\n        if (propSpeed >= threshold)\n            return fThrough;\n    }\n    var fThroughStart = 0;\n    var fThroughTime = 0;\n    if (simulate) {\n        var speedI = getPropWorldSpeed(t, thisProperty);\n        var i = t;\n        while (speedI < threshold && i > 0) {\n            i = $bm_sub(i, $bm_div(thisComp.frameDuration, moBlurPrecision));\n            speedI = getPropWorldSpeed(i, thisProperty);\n        }\n        fThroughStart = i;\n    } else {\n        var fThroughKey = getPrevKey(t);\n        fThroughStart = fThroughKey.time;\n    }\n    if (fThroughStart == 0)\n        return fThrough;\n    fThroughTime = $bm_sub(t, fThroughStart);\n    if (simulate)\n        fThrough = $bm_div(getPropWorldVelocity($bm_sub(fThroughStart, thisComp.frameDuration), thisProperty), 2);\n    else\n        fThrough = $bm_div(velocityAtTime($bm_sub(fThroughStart, thisComp.frameDuration)), 2);\n    if (bounce) {\n        var cycleDamp = Math.exp($bm_mul($bm_mul(fThroughTime, damping), 0.1));\n        var damp = $bm_div(Math.exp($bm_mul(fThroughTime, damping)), $bm_div(elasticity, 2));\n        var cycleDuration = $bm_div(1, $bm_mul(elasticity, 2));\n        cycleDuration = Math.round(timeToFrames(cycleDuration));\n        cycleDuration = framesToTime(cycleDuration);\n        var midDuration = $bm_div(cycleDuration, 2);\n        var maxValue = $bm_mul(fThrough, midDuration);\n        var cycvarime = fThroughTime;\n        var numEndCycles = 1;\n        while (cycvarime > cycleDuration) {\n            cycvarime = $bm_sub(cycvarime, cycleDuration);\n            cycleDuration = $bm_div(cycleDuration, cycleDamp);\n            cycleDuration = Math.round(timeToFrames(cycleDuration));\n            if (cycleDuration < 2) {\n                cycleDuration = 2;\n                numEndCycles++;\n            }\n            cycleDuration = framesToTime(cycleDuration);\n            midDuration = $bm_div(cycleDuration, 2);\n            maxValue = $bm_div($bm_mul(fThrough, midDuration), damp);\n            if (numEndCycles > 100 / damping && maxValue < threshold)\n                return zeroValue;\n        }\n        if (cycvarime < midDuration)\n            fThrough = bezierInterpolation(cycvarime, 0, midDuration, 0, maxValue, [\n                0,\n                0.1,\n                slowIn,\n                1\n            ]);\n        else\n            fThrough = bezierInterpolation(cycvarime, midDuration, cycleDuration, maxValue, 0, [\n                $bm_sub(1, slowIn),\n                0,\n                1,\n                0.9\n            ]);\n    } else {\n        var damp = Math.exp($bm_mul(fThroughTime, damping));\n        var sinus = $bm_mul($bm_mul($bm_mul(elasticity, fThroughTime), 2), Math.PI);\n        sinus = Math.sin(sinus);\n        sinus = $bm_mul($bm_div(0.3, elasticity), sinus);\n        sinus = $bm_div(sinus, damp);\n        if (Math.abs(sinus) < $bm_div(threshold, 100))\n            return 0;\n        fThrough = $bm_mul(fThrough, sinus);\n        if (threshold > 0) {\n            fThrough = $bm_mul(fThrough, $bm_sub(1, $bm_div(propSpeed, threshold)));\n        }\n    }\n    if (bounce) {\n        var prevValue = valueAtTime($bm_sub(fThroughStart, thisComp.frameDuration));\n        var startValue = valueAtTime(fThroughStart);\n        if ($bm_isInstanceOfArray(value)) {\n            for (var i = 0; i < prevValue.length; i++) {\n                if (prevValue[i] > startValue[i])\n                    fThrough[i] = Math.abs(fThrough[i]);\n                if (prevValue[i] < startValue[i])\n                    fThrough[i] = $bm_neg(Math.abs(fThrough[i]));\n            }\n        } else {\n            if (prevValue > startValue)\n                fThrough = Math.abs(fThrough);\n            if (prevValue < startValue)\n                fThrough = $bm_neg(Math.abs(fThrough));\n        }\n    }\n    if (simulate) {\n        if (!isThisPosition) {\n            fThrough = $bm_sum(fThrough, getLayerWorldPos(time, thisLayer));\n            fThrough = $bm_sub(thisLayer.fromWorld(fThrough), thisLayer.anchorPoint);\n        } else if (thisLayer.hasParent) {\n            fThrough = $bm_sum(fThrough, getLayerWorldPos(time, thisLayer.parent));\n            fThrough = $bm_sub(thisLayer.parent.fromWorld(fThrough), thisLayer.parent.anchorPoint);\n        }\n    }\n    return fThrough;\n}\nfunction followThrough() {\n    var propSpeed = length(velocity);\n    if (propSpeed < threshold)\n        return followThroughAtTime($bm_sub(time, overlapDuration));\n    var fThrough = zeroValue;\n    var t = time;\n    while (t > 0) {\n        t = $bm_sub(t, thisComp.frameDuration);\n        if (simulate)\n            propSpeed = getPropWorldSpeed($bm_sub(t, overlapDuration), thisProperty);\n        else\n            propSpeed = length(velocityAtTime(t));\n        if (propSpeed < threshold) {\n            fThrough = followThroughAtTime($bm_sub(t, overlapDuration));\n            break;\n        }\n    }\n    return linear(time, t, $bm_sum(t, $bm_mul(anticipationDuration, 2)), fThrough, zeroValue);\n}\nfunction smartSmooth(axis) {\n    var startKey = nearestKey(time);\n    var endKey = startKey;\n    if (time == startKey.time)\n        return 0;\n    if (time < startKey.time && startKey.index == 1)\n        return 0;\n    if (time > startKey.time && startKey.index == numKeys)\n        return 0;\n    if (time < startKey.time)\n        startKey = key($bm_sub(startKey.index, 1));\n    if (time > startKey.time)\n        endKey = key($bm_sum(startKey.index, 1));\n    var sI = 0.66;\n    var sO = 0.33;\n    var sIV = 1;\n    var sOV = 0;\n    var sVal = startKey.value;\n    var eVal = endKey.value;\n    if ($bm_isInstanceOfArray(value)) {\n        sVal = sVal[axis];\n        eVal = eVal[axis];\n    }\n    var sTime = startKey.time;\n    var eTime = endKey.time;\n    if (isKeyTop(startKey, axis))\n        sO = slowOut;\n    else {\n        var prevKey = key($bm_sub(startKey.index, 1));\n        var pVal = prevKey.value;\n        if ($bm_isInstanceOfArray(value))\n            pVal = pVal[axis];\n        sOV = $bm_div($bm_sub(sVal, pVal), $bm_sub(eVal, pVal));\n    }\n    if (isKeyTop(endKey, axis)) {\n        sI = slowIn;\n        if (endKey.index != numKeys) {\n            var nextKey = key($bm_sum(endKey.index, 1));\n            var nVal = nextKey.value;\n            if ($bm_isInstanceOfArray(value))\n                nVal = nVal[axis];\n            if (Math.abs(nVal - eVal) < 0.01 && doFollowThrough)\n                sI = 1;\n        }\n    } else {\n        var nextKey = key($bm_sum(endKey.index, 1));\n        var nVal = nextKey.value;\n        if ($bm_isInstanceOfArray(value))\n            nVal = nVal[axis];\n        sIV = $bm_div($bm_sub(eVal, sVal), $bm_sub(nVal, sVal));\n    }\n    if (endKey.index == numKeys && doFollowThrough) {\n        sI = 1;\n    }\n    var val = value;\n    if ($bm_isInstanceOfArray(value))\n        val = val[axis];\n    return $bm_sub(bezierInterpolation(time, sTime, eTime, sVal, eVal, [\n        sO,\n        sOV,\n        sI,\n        sIV\n    ]), val);\n}\nfunction overlap() {\n    var ol = zeroValue;\n    if (isThisPosition && !hasParent)\n        return zeroValue;\n    ol = $bm_sub(getPropWorldValue($bm_sub(time, overlapDuration), thisProperty), getPropWorldValue(time, thisProperty));\n    var motionRatio = $bm_div($bm_div(length(zeroValue, ol), thisLayer.width), 2);\n    if (isThisPosition) {\n        var originalDistance = length(valueAtTime(0));\n        motionRatio = $bm_div(length(zeroValue, ol), thisComp.width);\n    }\n    ol = $bm_sum(ol, getPropWorldValue(time, thisProperty));\n    ol = $bm_sum(ol, $bm_mul($bm_mul($bm_sub(getPropWorldValue($bm_sub(time, overlapDuration), thisLayer.anchorPoint), ol), motionRatio), flexibility));\n    ol = thisLayer.fromWorld(ol);\n    if (!isThisPosition)\n        ol = $bm_sub(ol, value);\n    else {\n        ol = linear(flexibility, 0, 100, $bm_div(ol, 2), 0);\n        var prevParentWorldPos = getLayerWorldPos($bm_sub(time, overlapDuration), parent);\n        ol = $bm_sum(ol, $bm_mul($bm_mul($bm_mul(thisLayer.fromWorld(prevParentWorldPos), motionRatio), flexibility), 5));\n    }\n    return ol;\n}\nvar okToGo = false;\nif (simulate && fx.enabled)\n    okToGo = true;\nelse if (numKeys > 1 && fx.enabled)\n    okToGo = true;\nif (okToGo) {\n    var smartSmoothResult = zeroValue;\n    if (doInterpolation) {\n        if ($bm_isInstanceOfArray(value)) {\n            if (value.length == 2)\n                smartSmoothResult = [\n                    smartSmooth(0),\n                    smartSmooth(1)\n                ];\n            else if (value.length == 3)\n                smartSmoothResult = [\n                    smartSmooth(0),\n                    smartSmooth(1),\n                    smartSmooth(2)\n                ];\n            else if (value.length == 4)\n                smartSmoothResult = [\n                    smartSmooth(0),\n                    smartSmooth(1),\n                    smartSmooth(2),\n                    smartSmooth(3)\n                ];\n        } else {\n            smartSmoothResult = smartSmooth(0);\n        }\n    }\n    if (doAnticipation)\n        result = $bm_sum(result, anticipate());\n    result = $bm_sum(result, smartSmoothResult);\n    if (doFollowThrough)\n        result = $bm_sum(result, followThrough());\n    if (doOverlap)\n        result = $bm_sum(result, overlap());\n}\n$bm_rt = result;",
                    "a": 1
                  },
                  "nm": "Transform",
                  "sk": { "a": 0, "k": 0.0 },
                  "sa": { "a": 0, "k": 0.0 }
                }
              ]
            },
            {
              "ty": "gr",
              "nm": "Group 6",
              "bm": 0,
              "mn": "ADBE Vector Group",
              "it": [
                {
                  "ty": "gr",
                  "nm": "Group 3",
                  "bm": 0,
                  "mn": "ADBE Vector Group",
                  "it": [
                    {
                      "ty": "sh",
                      "nm": "Path 1",
                      "mn": "ADBE Vector Shape - Group",
                      "ind": 0,
                      "ks": {
                        "k": {
                          "i": [
                            [0.0, -3.168],
                            [17.303, 0.0],
                            [0.0, 3.168],
                            [-17.303, 0.0]
                          ],
                          "o": [
                            [0.0, 3.168],
                            [-17.303, 0.0],
                            [0.0, -3.168],
                            [17.303, 0.0]
                          ],
                          "v": [
                            [-32.62, -29.736],
                            [-63.949, -24.001],
                            [-95.279, -29.736],
                            [-63.949, -35.472]
                          ],
                          "c": true
                        },
                        "a": 0
                      }
                    },
                    {
                      "ty": "fl",
                      "nm": "Fill 1",
                      "bm": 0,
                      "mn": "ADBE Vector Graphic - Fill",
                      "c": { "a": 0, "k": [0.0, 0.0, 0.0, 1.0] },
                      "o": { "a": 0, "k": 100.0 },
                      "r": 1
                    },
                    {
                      "ty": "tr",
                      "o": { "a": 0, "k": 100.0 },
                      "r": { "a": 0, "k": 0.0 },
                      "p": { "a": 0, "k": [0.0, 0.0] },
                      "a": { "a": 0, "k": [0.0, 0.0] },
                      "s": { "a": 0, "k": [100.0, 100.0] },
                      "nm": "Transform",
                      "sk": { "a": 0, "k": 0.0 },
                      "sa": { "a": 0, "k": 0.0 }
                    }
                  ]
                },
                {
                  "ty": "tr",
                  "o": {
                    "a": 1,
                    "k": [
                      {
                        "i": { "x": [0.667], "y": [1] },
                        "o": { "x": [0.333], "y": [0] },
                        "t": 94,
                        "s": [10.0]
                      },
                      { "t": 98, "s": [0.0] }
                    ]
                  },
                  "r": { "a": 0, "k": 0.0 },
                  "p": {
                    "a": 0,
                    "k": [-63.95, -29.736],
                    "x": "var $bm_rt;\nvar fx = effect('\u015dlosilo pli pura 4');\nvar doAnticipation = fx(1).value;\nvar doInterpolation = fx(2).value;\nvar doFollowThrough = fx(3).value;\nvar damping = $bm_div(fx(15).value, 10);\nvar elasticity = $bm_div(fx(13).value, 10);\nvar bounce = fx(17).value;\nvar anticipationDuration = fx(5).value;\nvar anticipationQuantity = $bm_div(fx(6).value, 100);\nvar slowIn = $bm_div(fx(9).value, 100);\nvar slowOut = $bm_div(fx(10).value, 100);\nvar spatialMode = fx(21).value;\nvar spatialDoInterpolation = fx(20).value;\nvar moBlurPrecision = fx(32).value;\nvar elasticityRandom = fx(14).value;\nvar dampingRandom = fx(16).value;\nvar softBody = fx(28).value;\nvar flexibility = $bm_div(fx(29).value, 100);\nvar doOverlap = fx(23).value;\nvar overlapDuration = fx(24).value;\nvar overlapRandom = fx(25).value;\nvar threshold = $bm_div($bm_div(1, moBlurPrecision), 1000);\nvar zeroValue;\nif ($bm_isInstanceOfArray(value)) {\n    if (value.length == 2)\n        zeroValue = [\n            0,\n            0\n        ];\n    else if (value.length == 3)\n        zeroValue = [\n            0,\n            0,\n            0\n        ];\n    else if (value.length == 4)\n        zeroValue = [\n            0,\n            0,\n            0,\n            0\n        ];\n} else\n    zeroValue = 0;\nvar isThisSpatial = isSpatial(thisProperty);\nvar isThisPosition = thisProperty === $bm_transform.position;\nvar simulate = false;\nif (isThisSpatial) {\n    doInterpolation = doInterpolation && spatialDoInterpolation;\n    if (isThisPosition && thisProperty.numKeys > 0) {\n        doOverlap = false;\n        simulate = false;\n    } else {\n        simulate = spatialMode == 2;\n        doOverlap = overlapDuration != 0 && doOverlap && simulate;\n    }\n} else {\n    doOverlap = false;\n}\nif (!doOverlap) {\n    overlapDuration = 0;\n}\nif (simulate && softBody && isThisSpatial && !isThisPosition && (doFollowThrough || doOverlap)) {\n    var distanceRatio = $bm_div(length(valueAtTime(0), $bm_transform.anchorPoint), $bm_div(thisLayer.width, 2));\n    distanceRatio = $bm_div($bm_sum(1, $bm_mul(distanceRatio, flexibility)), 2);\n    if (doFollowThrough) {\n        elasticity = $bm_div(elasticity, distanceRatio);\n        damping = $bm_div(damping, distanceRatio);\n    }\n    if (doOverlap) {\n        overlapDuration = $bm_mul(overlapDuration, distanceRatio);\n    }\n}\nseedRandom(0, true);\nif (doFollowThrough) {\n    if (elasticityRandom > 0)\n        elasticity = addNoise(elasticity, elasticityRandom);\n    if (dampingRandom > 0)\n        damping = addNoise(damping, dampingRandom);\n}\nif (doOverlap) {\n    if (doOverlap && overlapRandom > 0)\n        overlapDuration = addNoise(overlapDuration, overlapRandom);\n}\nvar result = value;\nfunction isSpatial(prop) {\n    if (!(prop.value instanceof Array))\n        return false;\n    if (prop.value.length != 2 && prop.value.length != 3)\n        return false;\n    try {\n        if (typeof prop.speed !== 'undefined')\n            return true;\n    } catch (e) {\n        return false;\n    }\n}\nfunction addNoise(val, quantity) {\n    var randomValue = random(0.9, 1.1);\n    var noiseValue = noise($bm_mul(valueAtTime(0), randomValue));\n    noiseValue = $bm_mul(noiseValue, $bm_div(quantity, 100));\n    return $bm_mul(val, $bm_sum(noiseValue, 1));\n}\nfunction isAfterLastKey() {\n    if (numKeys == 0)\n        return false;\n    var nKey = nearestKey(time);\n    return nKey.time <= time && nKey.index == numKeys;\n}\nfunction isStill(t, threshold) {\n    var d = $bm_sub(valueAtTime(t), valueAtTime($bm_sum(t, framesToTime(1))));\n    if ($bm_isInstanceOfArray(d)) {\n        for (var i = 0; i < d.length; i++) {\n            d[i] = Math.abs(d[i]);\n            if (d[i] >= threshold) {\n                return false;\n            }\n        }\n        return true;\n    } else {\n        d = Math.abs(d);\n        return d < threshold;\n    }\n}\nfunction bezierInterpolation(t, tMin, tMax, value1, value2, bezierPoints) {\n    if (arguments.length !== 5 && arguments.length !== 6)\n        return t;\n    var a = $bm_sub(value2, value1);\n    var b = $bm_sub(tMax, tMin);\n    if (b == 0)\n        return t;\n    var c = clamp($bm_div($bm_sub(t, tMin), b), 0, 1);\n    if (!(bezierPoints instanceof Array) || bezierPoints.length !== 4)\n        bezierPoints = [\n            0.33,\n            0,\n            0.66,\n            1\n        ];\n    return $bm_sum($bm_mul(a, h(c, bezierPoints)), value1);\n    function h(f, g) {\n        var x = $bm_mul(3, g[0]);\n        var j = $bm_sub($bm_mul(3, $bm_sub(g[2], g[0])), x);\n        var k = $bm_sub($bm_sub(1, x), j);\n        var l = $bm_mul(3, g[1]);\n        var m = $bm_sub($bm_mul(3, $bm_sub(g[3], g[1])), l);\n        var n = $bm_sub($bm_sub(1, l), m);\n        var d = f;\n        for (var i = 0; i < 5; i++) {\n            var z = $bm_sub($bm_mul(d, $bm_sum(x, $bm_mul(d, $bm_sum(j, $bm_mul(d, k))))), f);\n            if (Math.abs(z) < 0.001)\n                break;\n            d = $bm_sub(d, $bm_div(z, $bm_sum(x, $bm_mul(d, $bm_sum($bm_mul(2, j), $bm_mul($bm_mul(3, k), d))))));\n        }\n        return $bm_mul(d, $bm_sum(l, $bm_mul(d, $bm_sum(m, $bm_mul(d, n)))));\n    }\n}\nfunction getPropWorldSpeed(t, prop) {\n    return length(getPropWorldVelocity(t, prop));\n}\nfunction getPrevKey(t) {\n    if (numKeys == 0)\n        return null;\n    var nKey = nearestKey(t);\n    if (nKey.time <= t)\n        return nKey;\n    if (nKey.index > 1)\n        return key($bm_sub(nKey.index, 1));\n    return null;\n}\nfunction getNextKey(t) {\n    if (numKeys == 0)\n        return null;\n    var nKey = nearestKey(t);\n    if (nKey.time >= t)\n        return nKey;\n    if (nKey.index < numKeys)\n        return key($bm_sum(nKey.index, 1));\n    return null;\n}\nfunction getPropWorldVelocity(t, prop) {\n    return $bm_mul($bm_sub(getPropWorldValue($bm_sum(t, 0.005), prop), getPropWorldValue($bm_sub(t, 0.005), prop)), 100);\n}\nfunction getLayerWorldPos(t, l) {\n    return l.toWorld(l.anchorPoint, t);\n}\nfunction getPropWorldValue(t, prop) {\n    if (isPosition(prop))\n        return getLayerWorldPos(t, thisLayer);\n    return thisLayer.toWorld(prop.valueAtTime(t), t);\n}\nfunction isPosition(prop) {\n    return prop === $bm_transform.position;\n}\nfunction isKeyTop(k, axis) {\n    var prevSpeed = velocityAtTime($bm_sub(k.time, threshold));\n    var nextSpeed = velocityAtTime($bm_sum(k.time, threshold));\n    if ($bm_isInstanceOfArray(value)) {\n        prevSpeed = prevSpeed[axis];\n        nextSpeed = nextSpeed[axis];\n    }\n    if (Math.abs(prevSpeed) < 0.01 || Math.abs(nextSpeed) < 0.01)\n        return true;\n    return $bm_mul(prevSpeed, nextSpeed) < 0;\n}\nfunction anticipate() {\n    var anticipation = zeroValue;\n    if (isAfterLastKey())\n        return anticipation;\n    if (numKeys < 2)\n        return anticipation;\n    var nextKey = getNextKey(time);\n    var aKey = nextKey;\n    if (!isStill(aKey.time - 0.1, 0.1)) {\n        aKey = getPrevKey(time);\n        if (!isStill(aKey.time - 0.1, 0.1))\n            return anticipation;\n    }\n    if (aKey.index == numKeys)\n        return anticipation;\n    var anticipationMiddle = aKey.time;\n    var anticipationStart = $bm_sub(anticipationMiddle, anticipationDuration);\n    var anticipationEnd = key(aKey.index + 1).time;\n    var startValue = anticipation;\n    var midValue = $bm_mul($bm_sum($bm_neg(valueAtTime($bm_sum(anticipationMiddle, anticipationDuration))), aKey.value), anticipationQuantity);\n    var endValue = anticipation;\n    if (time < anticipationStart) {\n        return anticipation;\n    } else if (time < anticipationMiddle) {\n        if ($bm_isInstanceOfArray(value)) {\n            for (var i = 0; i < value.length; i++) {\n                anticipation[i] = bezierInterpolation(time, anticipationStart, anticipationMiddle, startValue[i], midValue[i], [\n                    slowOut,\n                    0,\n                    slowIn,\n                    1\n                ]);\n            }\n            return anticipation;\n        } else {\n            return bezierInterpolation(time, anticipationStart, anticipationMiddle, startValue, midValue, [\n                slowOut,\n                0,\n                slowIn,\n                1\n            ]);\n        }\n    } else if (time <= anticipationEnd) {\n        if ($bm_isInstanceOfArray(value)) {\n            for (var i = 0; i < value.length; i++) {\n                anticipation[i] = bezierInterpolation(time, anticipationMiddle, anticipationEnd, midValue[i], endValue[i], [\n                    slowOut,\n                    0,\n                    slowIn,\n                    1\n                ]);\n            }\n            return anticipation;\n        } else {\n            return bezierInterpolation(time, anticipationMiddle, anticipationEnd, midValue, endValue, [\n                slowOut,\n                0,\n                slowIn,\n                1\n            ]);\n        }\n    } else {\n        return anticipation;\n    }\n}\nfunction followThroughAtTime(t) {\n    var fThrough = zeroValue;\n    if (elasticity == 0)\n        return fThrough;\n    var propSpeed;\n    if (!simulate) {\n        if (numKeys < 2)\n            return fThrough;\n        if (nearestKey(t).index == 1)\n            return fThrough;\n        propSpeed = length(velocityAtTime(t));\n        if (propSpeed >= threshold)\n            return fThrough;\n    } else {\n        propSpeed = getPropWorldSpeed(t, thisProperty);\n        if (propSpeed >= threshold)\n            return fThrough;\n    }\n    var fThroughStart = 0;\n    var fThroughTime = 0;\n    if (simulate) {\n        var speedI = getPropWorldSpeed(t, thisProperty);\n        var i = t;\n        while (speedI < threshold && i > 0) {\n            i = $bm_sub(i, $bm_div(thisComp.frameDuration, moBlurPrecision));\n            speedI = getPropWorldSpeed(i, thisProperty);\n        }\n        fThroughStart = i;\n    } else {\n        var fThroughKey = getPrevKey(t);\n        fThroughStart = fThroughKey.time;\n    }\n    if (fThroughStart == 0)\n        return fThrough;\n    fThroughTime = $bm_sub(t, fThroughStart);\n    if (simulate)\n        fThrough = $bm_div(getPropWorldVelocity($bm_sub(fThroughStart, thisComp.frameDuration), thisProperty), 2);\n    else\n        fThrough = $bm_div(velocityAtTime($bm_sub(fThroughStart, thisComp.frameDuration)), 2);\n    if (bounce) {\n        var cycleDamp = Math.exp($bm_mul($bm_mul(fThroughTime, damping), 0.1));\n        var damp = $bm_div(Math.exp($bm_mul(fThroughTime, damping)), $bm_div(elasticity, 2));\n        var cycleDuration = $bm_div(1, $bm_mul(elasticity, 2));\n        cycleDuration = Math.round(timeToFrames(cycleDuration));\n        cycleDuration = framesToTime(cycleDuration);\n        var midDuration = $bm_div(cycleDuration, 2);\n        var maxValue = $bm_mul(fThrough, midDuration);\n        var cycvarime = fThroughTime;\n        var numEndCycles = 1;\n        while (cycvarime > cycleDuration) {\n            cycvarime = $bm_sub(cycvarime, cycleDuration);\n            cycleDuration = $bm_div(cycleDuration, cycleDamp);\n            cycleDuration = Math.round(timeToFrames(cycleDuration));\n            if (cycleDuration < 2) {\n                cycleDuration = 2;\n                numEndCycles++;\n            }\n            cycleDuration = framesToTime(cycleDuration);\n            midDuration = $bm_div(cycleDuration, 2);\n            maxValue = $bm_div($bm_mul(fThrough, midDuration), damp);\n            if (numEndCycles > 100 / damping && maxValue < threshold)\n                return zeroValue;\n        }\n        if (cycvarime < midDuration)\n            fThrough = bezierInterpolation(cycvarime, 0, midDuration, 0, maxValue, [\n                0,\n                0.1,\n                slowIn,\n                1\n            ]);\n        else\n            fThrough = bezierInterpolation(cycvarime, midDuration, cycleDuration, maxValue, 0, [\n                $bm_sub(1, slowIn),\n                0,\n                1,\n                0.9\n            ]);\n    } else {\n        var damp = Math.exp($bm_mul(fThroughTime, damping));\n        var sinus = $bm_mul($bm_mul($bm_mul(elasticity, fThroughTime), 2), Math.PI);\n        sinus = Math.sin(sinus);\n        sinus = $bm_mul($bm_div(0.3, elasticity), sinus);\n        sinus = $bm_div(sinus, damp);\n        if (Math.abs(sinus) < $bm_div(threshold, 100))\n            return 0;\n        fThrough = $bm_mul(fThrough, sinus);\n        if (threshold > 0) {\n            fThrough = $bm_mul(fThrough, $bm_sub(1, $bm_div(propSpeed, threshold)));\n        }\n    }\n    if (bounce) {\n        var prevValue = valueAtTime($bm_sub(fThroughStart, thisComp.frameDuration));\n        var startValue = valueAtTime(fThroughStart);\n        if ($bm_isInstanceOfArray(value)) {\n            for (var i = 0; i < prevValue.length; i++) {\n                if (prevValue[i] > startValue[i])\n                    fThrough[i] = Math.abs(fThrough[i]);\n                if (prevValue[i] < startValue[i])\n                    fThrough[i] = $bm_neg(Math.abs(fThrough[i]));\n            }\n        } else {\n            if (prevValue > startValue)\n                fThrough = Math.abs(fThrough);\n            if (prevValue < startValue)\n                fThrough = $bm_neg(Math.abs(fThrough));\n        }\n    }\n    if (simulate) {\n        if (!isThisPosition) {\n            fThrough = $bm_sum(fThrough, getLayerWorldPos(time, thisLayer));\n            fThrough = $bm_sub(thisLayer.fromWorld(fThrough), thisLayer.anchorPoint);\n        } else if (thisLayer.hasParent) {\n            fThrough = $bm_sum(fThrough, getLayerWorldPos(time, thisLayer.parent));\n            fThrough = $bm_sub(thisLayer.parent.fromWorld(fThrough), thisLayer.parent.anchorPoint);\n        }\n    }\n    return fThrough;\n}\nfunction followThrough() {\n    var propSpeed = length(velocity);\n    if (propSpeed < threshold)\n        return followThroughAtTime($bm_sub(time, overlapDuration));\n    var fThrough = zeroValue;\n    var t = time;\n    while (t > 0) {\n        t = $bm_sub(t, thisComp.frameDuration);\n        if (simulate)\n            propSpeed = getPropWorldSpeed($bm_sub(t, overlapDuration), thisProperty);\n        else\n            propSpeed = length(velocityAtTime(t));\n        if (propSpeed < threshold) {\n            fThrough = followThroughAtTime($bm_sub(t, overlapDuration));\n            break;\n        }\n    }\n    return linear(time, t, $bm_sum(t, $bm_mul(anticipationDuration, 2)), fThrough, zeroValue);\n}\nfunction smartSmooth(axis) {\n    var startKey = nearestKey(time);\n    var endKey = startKey;\n    if (time == startKey.time)\n        return 0;\n    if (time < startKey.time && startKey.index == 1)\n        return 0;\n    if (time > startKey.time && startKey.index == numKeys)\n        return 0;\n    if (time < startKey.time)\n        startKey = key($bm_sub(startKey.index, 1));\n    if (time > startKey.time)\n        endKey = key($bm_sum(startKey.index, 1));\n    var sI = 0.66;\n    var sO = 0.33;\n    var sIV = 1;\n    var sOV = 0;\n    var sVal = startKey.value;\n    var eVal = endKey.value;\n    if ($bm_isInstanceOfArray(value)) {\n        sVal = sVal[axis];\n        eVal = eVal[axis];\n    }\n    var sTime = startKey.time;\n    var eTime = endKey.time;\n    if (isKeyTop(startKey, axis))\n        sO = slowOut;\n    else {\n        var prevKey = key($bm_sub(startKey.index, 1));\n        var pVal = prevKey.value;\n        if ($bm_isInstanceOfArray(value))\n            pVal = pVal[axis];\n        sOV = $bm_div($bm_sub(sVal, pVal), $bm_sub(eVal, pVal));\n    }\n    if (isKeyTop(endKey, axis)) {\n        sI = slowIn;\n        if (endKey.index != numKeys) {\n            var nextKey = key($bm_sum(endKey.index, 1));\n            var nVal = nextKey.value;\n            if ($bm_isInstanceOfArray(value))\n                nVal = nVal[axis];\n            if (Math.abs(nVal - eVal) < 0.01 && doFollowThrough)\n                sI = 1;\n        }\n    } else {\n        var nextKey = key($bm_sum(endKey.index, 1));\n        var nVal = nextKey.value;\n        if ($bm_isInstanceOfArray(value))\n            nVal = nVal[axis];\n        sIV = $bm_div($bm_sub(eVal, sVal), $bm_sub(nVal, sVal));\n    }\n    if (endKey.index == numKeys && doFollowThrough) {\n        sI = 1;\n    }\n    var val = value;\n    if ($bm_isInstanceOfArray(value))\n        val = val[axis];\n    return $bm_sub(bezierInterpolation(time, sTime, eTime, sVal, eVal, [\n        sO,\n        sOV,\n        sI,\n        sIV\n    ]), val);\n}\nfunction overlap() {\n    var ol = zeroValue;\n    if (isThisPosition && !hasParent)\n        return zeroValue;\n    ol = $bm_sub(getPropWorldValue($bm_sub(time, overlapDuration), thisProperty), getPropWorldValue(time, thisProperty));\n    var motionRatio = $bm_div($bm_div(length(zeroValue, ol), thisLayer.width), 2);\n    if (isThisPosition) {\n        var originalDistance = length(valueAtTime(0));\n        motionRatio = $bm_div(length(zeroValue, ol), thisComp.width);\n    }\n    ol = $bm_sum(ol, getPropWorldValue(time, thisProperty));\n    ol = $bm_sum(ol, $bm_mul($bm_mul($bm_sub(getPropWorldValue($bm_sub(time, overlapDuration), thisLayer.anchorPoint), ol), motionRatio), flexibility));\n    ol = thisLayer.fromWorld(ol);\n    if (!isThisPosition)\n        ol = $bm_sub(ol, value);\n    else {\n        ol = linear(flexibility, 0, 100, $bm_div(ol, 2), 0);\n        var prevParentWorldPos = getLayerWorldPos($bm_sub(time, overlapDuration), parent);\n        ol = $bm_sum(ol, $bm_mul($bm_mul($bm_mul(thisLayer.fromWorld(prevParentWorldPos), motionRatio), flexibility), 5));\n    }\n    return ol;\n}\nvar okToGo = false;\nif (simulate && fx.enabled)\n    okToGo = true;\nelse if (numKeys > 1 && fx.enabled)\n    okToGo = true;\nif (okToGo) {\n    var smartSmoothResult = zeroValue;\n    if (doInterpolation) {\n        if ($bm_isInstanceOfArray(value)) {\n            if (value.length == 2)\n                smartSmoothResult = [\n                    smartSmooth(0),\n                    smartSmooth(1)\n                ];\n            else if (value.length == 3)\n                smartSmoothResult = [\n                    smartSmooth(0),\n                    smartSmooth(1),\n                    smartSmooth(2)\n                ];\n            else if (value.length == 4)\n                smartSmoothResult = [\n                    smartSmooth(0),\n                    smartSmooth(1),\n                    smartSmooth(2),\n                    smartSmooth(3)\n                ];\n        } else {\n            smartSmoothResult = smartSmooth(0);\n        }\n    }\n    if (doAnticipation)\n        result = $bm_sum(result, anticipate());\n    result = $bm_sum(result, smartSmoothResult);\n    if (doFollowThrough)\n        result = $bm_sum(result, followThrough());\n    if (doOverlap)\n        result = $bm_sum(result, overlap());\n}\n$bm_rt = result;"
                  },
                  "a": { "a": 0, "k": [-63.95, -29.736] },
                  "s": {
                    "k": [
                      {
                        "i": { "x": [0.667, 0.667], "y": [1.0, 1.0] },
                        "o": { "x": [0.333, 0.333], "y": [0.0, 0.0] },
                        "t": 81,
                        "s": [100, 100]
                      },
                      { "t": 94, "s": [160, 160] }
                    ],
                    "x": "var $bm_rt;\nvar fx = effect('\u015dlosilo pli pura 4');\nvar doAnticipation = fx(1).value;\nvar doInterpolation = fx(2).value;\nvar doFollowThrough = fx(3).value;\nvar damping = $bm_div(fx(15).value, 10);\nvar elasticity = $bm_div(fx(13).value, 10);\nvar bounce = fx(17).value;\nvar anticipationDuration = fx(5).value;\nvar anticipationQuantity = $bm_div(fx(6).value, 100);\nvar slowIn = $bm_div(fx(9).value, 100);\nvar slowOut = $bm_div(fx(10).value, 100);\nvar spatialMode = fx(21).value;\nvar spatialDoInterpolation = fx(20).value;\nvar moBlurPrecision = fx(32).value;\nvar elasticityRandom = fx(14).value;\nvar dampingRandom = fx(16).value;\nvar softBody = fx(28).value;\nvar flexibility = $bm_div(fx(29).value, 100);\nvar doOverlap = fx(23).value;\nvar overlapDuration = fx(24).value;\nvar overlapRandom = fx(25).value;\nvar threshold = $bm_div($bm_div(1, moBlurPrecision), 1000);\nvar zeroValue;\nif ($bm_isInstanceOfArray(value)) {\n    if (value.length == 2)\n        zeroValue = [\n            0,\n            0\n        ];\n    else if (value.length == 3)\n        zeroValue = [\n            0,\n            0,\n            0\n        ];\n    else if (value.length == 4)\n        zeroValue = [\n            0,\n            0,\n            0,\n            0\n        ];\n} else\n    zeroValue = 0;\nvar isThisSpatial = isSpatial(thisProperty);\nvar isThisPosition = thisProperty === $bm_transform.position;\nvar simulate = false;\nif (isThisSpatial) {\n    doInterpolation = doInterpolation && spatialDoInterpolation;\n    if (isThisPosition && thisProperty.numKeys > 0) {\n        doOverlap = false;\n        simulate = false;\n    } else {\n        simulate = spatialMode == 2;\n        doOverlap = overlapDuration != 0 && doOverlap && simulate;\n    }\n} else {\n    doOverlap = false;\n}\nif (!doOverlap) {\n    overlapDuration = 0;\n}\nif (simulate && softBody && isThisSpatial && !isThisPosition && (doFollowThrough || doOverlap)) {\n    var distanceRatio = $bm_div(length(valueAtTime(0), $bm_transform.anchorPoint), $bm_div(thisLayer.width, 2));\n    distanceRatio = $bm_div($bm_sum(1, $bm_mul(distanceRatio, flexibility)), 2);\n    if (doFollowThrough) {\n        elasticity = $bm_div(elasticity, distanceRatio);\n        damping = $bm_div(damping, distanceRatio);\n    }\n    if (doOverlap) {\n        overlapDuration = $bm_mul(overlapDuration, distanceRatio);\n    }\n}\nseedRandom(0, true);\nif (doFollowThrough) {\n    if (elasticityRandom > 0)\n        elasticity = addNoise(elasticity, elasticityRandom);\n    if (dampingRandom > 0)\n        damping = addNoise(damping, dampingRandom);\n}\nif (doOverlap) {\n    if (doOverlap && overlapRandom > 0)\n        overlapDuration = addNoise(overlapDuration, overlapRandom);\n}\nvar result = value;\nfunction isSpatial(prop) {\n    if (!(prop.value instanceof Array))\n        return false;\n    if (prop.value.length != 2 && prop.value.length != 3)\n        return false;\n    try {\n        if (typeof prop.speed !== 'undefined')\n            return true;\n    } catch (e) {\n        return false;\n    }\n}\nfunction addNoise(val, quantity) {\n    var randomValue = random(0.9, 1.1);\n    var noiseValue = noise($bm_mul(valueAtTime(0), randomValue));\n    noiseValue = $bm_mul(noiseValue, $bm_div(quantity, 100));\n    return $bm_mul(val, $bm_sum(noiseValue, 1));\n}\nfunction isAfterLastKey() {\n    if (numKeys == 0)\n        return false;\n    var nKey = nearestKey(time);\n    return nKey.time <= time && nKey.index == numKeys;\n}\nfunction isStill(t, threshold) {\n    var d = $bm_sub(valueAtTime(t), valueAtTime($bm_sum(t, framesToTime(1))));\n    if ($bm_isInstanceOfArray(d)) {\n        for (var i = 0; i < d.length; i++) {\n            d[i] = Math.abs(d[i]);\n            if (d[i] >= threshold) {\n                return false;\n            }\n        }\n        return true;\n    } else {\n        d = Math.abs(d);\n        return d < threshold;\n    }\n}\nfunction bezierInterpolation(t, tMin, tMax, value1, value2, bezierPoints) {\n    if (arguments.length !== 5 && arguments.length !== 6)\n        return t;\n    var a = $bm_sub(value2, value1);\n    var b = $bm_sub(tMax, tMin);\n    if (b == 0)\n        return t;\n    var c = clamp($bm_div($bm_sub(t, tMin), b), 0, 1);\n    if (!(bezierPoints instanceof Array) || bezierPoints.length !== 4)\n        bezierPoints = [\n            0.33,\n            0,\n            0.66,\n            1\n        ];\n    return $bm_sum($bm_mul(a, h(c, bezierPoints)), value1);\n    function h(f, g) {\n        var x = $bm_mul(3, g[0]);\n        var j = $bm_sub($bm_mul(3, $bm_sub(g[2], g[0])), x);\n        var k = $bm_sub($bm_sub(1, x), j);\n        var l = $bm_mul(3, g[1]);\n        var m = $bm_sub($bm_mul(3, $bm_sub(g[3], g[1])), l);\n        var n = $bm_sub($bm_sub(1, l), m);\n        var d = f;\n        for (var i = 0; i < 5; i++) {\n            var z = $bm_sub($bm_mul(d, $bm_sum(x, $bm_mul(d, $bm_sum(j, $bm_mul(d, k))))), f);\n            if (Math.abs(z) < 0.001)\n                break;\n            d = $bm_sub(d, $bm_div(z, $bm_sum(x, $bm_mul(d, $bm_sum($bm_mul(2, j), $bm_mul($bm_mul(3, k), d))))));\n        }\n        return $bm_mul(d, $bm_sum(l, $bm_mul(d, $bm_sum(m, $bm_mul(d, n)))));\n    }\n}\nfunction getPropWorldSpeed(t, prop) {\n    return length(getPropWorldVelocity(t, prop));\n}\nfunction getPrevKey(t) {\n    if (numKeys == 0)\n        return null;\n    var nKey = nearestKey(t);\n    if (nKey.time <= t)\n        return nKey;\n    if (nKey.index > 1)\n        return key($bm_sub(nKey.index, 1));\n    return null;\n}\nfunction getNextKey(t) {\n    if (numKeys == 0)\n        return null;\n    var nKey = nearestKey(t);\n    if (nKey.time >= t)\n        return nKey;\n    if (nKey.index < numKeys)\n        return key($bm_sum(nKey.index, 1));\n    return null;\n}\nfunction getPropWorldVelocity(t, prop) {\n    return $bm_mul($bm_sub(getPropWorldValue($bm_sum(t, 0.005), prop), getPropWorldValue($bm_sub(t, 0.005), prop)), 100);\n}\nfunction getLayerWorldPos(t, l) {\n    return l.toWorld(l.anchorPoint, t);\n}\nfunction getPropWorldValue(t, prop) {\n    if (isPosition(prop))\n        return getLayerWorldPos(t, thisLayer);\n    return thisLayer.toWorld(prop.valueAtTime(t), t);\n}\nfunction isPosition(prop) {\n    return prop === $bm_transform.position;\n}\nfunction isKeyTop(k, axis) {\n    var prevSpeed = velocityAtTime($bm_sub(k.time, threshold));\n    var nextSpeed = velocityAtTime($bm_sum(k.time, threshold));\n    if ($bm_isInstanceOfArray(value)) {\n        prevSpeed = prevSpeed[axis];\n        nextSpeed = nextSpeed[axis];\n    }\n    if (Math.abs(prevSpeed) < 0.01 || Math.abs(nextSpeed) < 0.01)\n        return true;\n    return $bm_mul(prevSpeed, nextSpeed) < 0;\n}\nfunction anticipate() {\n    var anticipation = zeroValue;\n    if (isAfterLastKey())\n        return anticipation;\n    if (numKeys < 2)\n        return anticipation;\n    var nextKey = getNextKey(time);\n    var aKey = nextKey;\n    if (!isStill(aKey.time - 0.1, 0.1)) {\n        aKey = getPrevKey(time);\n        if (!isStill(aKey.time - 0.1, 0.1))\n            return anticipation;\n    }\n    if (aKey.index == numKeys)\n        return anticipation;\n    var anticipationMiddle = aKey.time;\n    var anticipationStart = $bm_sub(anticipationMiddle, anticipationDuration);\n    var anticipationEnd = key(aKey.index + 1).time;\n    var startValue = anticipation;\n    var midValue = $bm_mul($bm_sum($bm_neg(valueAtTime($bm_sum(anticipationMiddle, anticipationDuration))), aKey.value), anticipationQuantity);\n    var endValue = anticipation;\n    if (time < anticipationStart) {\n        return anticipation;\n    } else if (time < anticipationMiddle) {\n        if ($bm_isInstanceOfArray(value)) {\n            for (var i = 0; i < value.length; i++) {\n                anticipation[i] = bezierInterpolation(time, anticipationStart, anticipationMiddle, startValue[i], midValue[i], [\n                    slowOut,\n                    0,\n                    slowIn,\n                    1\n                ]);\n            }\n            return anticipation;\n        } else {\n            return bezierInterpolation(time, anticipationStart, anticipationMiddle, startValue, midValue, [\n                slowOut,\n                0,\n                slowIn,\n                1\n            ]);\n        }\n    } else if (time <= anticipationEnd) {\n        if ($bm_isInstanceOfArray(value)) {\n            for (var i = 0; i < value.length; i++) {\n                anticipation[i] = bezierInterpolation(time, anticipationMiddle, anticipationEnd, midValue[i], endValue[i], [\n                    slowOut,\n                    0,\n                    slowIn,\n                    1\n                ]);\n            }\n            return anticipation;\n        } else {\n            return bezierInterpolation(time, anticipationMiddle, anticipationEnd, midValue, endValue, [\n                slowOut,\n                0,\n                slowIn,\n                1\n            ]);\n        }\n    } else {\n        return anticipation;\n    }\n}\nfunction followThroughAtTime(t) {\n    var fThrough = zeroValue;\n    if (elasticity == 0)\n        return fThrough;\n    var propSpeed;\n    if (!simulate) {\n        if (numKeys < 2)\n            return fThrough;\n        if (nearestKey(t).index == 1)\n            return fThrough;\n        propSpeed = length(velocityAtTime(t));\n        if (propSpeed >= threshold)\n            return fThrough;\n    } else {\n        propSpeed = getPropWorldSpeed(t, thisProperty);\n        if (propSpeed >= threshold)\n            return fThrough;\n    }\n    var fThroughStart = 0;\n    var fThroughTime = 0;\n    if (simulate) {\n        var speedI = getPropWorldSpeed(t, thisProperty);\n        var i = t;\n        while (speedI < threshold && i > 0) {\n            i = $bm_sub(i, $bm_div(thisComp.frameDuration, moBlurPrecision));\n            speedI = getPropWorldSpeed(i, thisProperty);\n        }\n        fThroughStart = i;\n    } else {\n        var fThroughKey = getPrevKey(t);\n        fThroughStart = fThroughKey.time;\n    }\n    if (fThroughStart == 0)\n        return fThrough;\n    fThroughTime = $bm_sub(t, fThroughStart);\n    if (simulate)\n        fThrough = $bm_div(getPropWorldVelocity($bm_sub(fThroughStart, thisComp.frameDuration), thisProperty), 2);\n    else\n        fThrough = $bm_div(velocityAtTime($bm_sub(fThroughStart, thisComp.frameDuration)), 2);\n    if (bounce) {\n        var cycleDamp = Math.exp($bm_mul($bm_mul(fThroughTime, damping), 0.1));\n        var damp = $bm_div(Math.exp($bm_mul(fThroughTime, damping)), $bm_div(elasticity, 2));\n        var cycleDuration = $bm_div(1, $bm_mul(elasticity, 2));\n        cycleDuration = Math.round(timeToFrames(cycleDuration));\n        cycleDuration = framesToTime(cycleDuration);\n        var midDuration = $bm_div(cycleDuration, 2);\n        var maxValue = $bm_mul(fThrough, midDuration);\n        var cycvarime = fThroughTime;\n        var numEndCycles = 1;\n        while (cycvarime > cycleDuration) {\n            cycvarime = $bm_sub(cycvarime, cycleDuration);\n            cycleDuration = $bm_div(cycleDuration, cycleDamp);\n            cycleDuration = Math.round(timeToFrames(cycleDuration));\n            if (cycleDuration < 2) {\n                cycleDuration = 2;\n                numEndCycles++;\n            }\n            cycleDuration = framesToTime(cycleDuration);\n            midDuration = $bm_div(cycleDuration, 2);\n            maxValue = $bm_div($bm_mul(fThrough, midDuration), damp);\n            if (numEndCycles > 100 / damping && maxValue < threshold)\n                return zeroValue;\n        }\n        if (cycvarime < midDuration)\n            fThrough = bezierInterpolation(cycvarime, 0, midDuration, 0, maxValue, [\n                0,\n                0.1,\n                slowIn,\n                1\n            ]);\n        else\n            fThrough = bezierInterpolation(cycvarime, midDuration, cycleDuration, maxValue, 0, [\n                $bm_sub(1, slowIn),\n                0,\n                1,\n                0.9\n            ]);\n    } else {\n        var damp = Math.exp($bm_mul(fThroughTime, damping));\n        var sinus = $bm_mul($bm_mul($bm_mul(elasticity, fThroughTime), 2), Math.PI);\n        sinus = Math.sin(sinus);\n        sinus = $bm_mul($bm_div(0.3, elasticity), sinus);\n        sinus = $bm_div(sinus, damp);\n        if (Math.abs(sinus) < $bm_div(threshold, 100))\n            return 0;\n        fThrough = $bm_mul(fThrough, sinus);\n        if (threshold > 0) {\n            fThrough = $bm_mul(fThrough, $bm_sub(1, $bm_div(propSpeed, threshold)));\n        }\n    }\n    if (bounce) {\n        var prevValue = valueAtTime($bm_sub(fThroughStart, thisComp.frameDuration));\n        var startValue = valueAtTime(fThroughStart);\n        if ($bm_isInstanceOfArray(value)) {\n            for (var i = 0; i < prevValue.length; i++) {\n                if (prevValue[i] > startValue[i])\n                    fThrough[i] = Math.abs(fThrough[i]);\n                if (prevValue[i] < startValue[i])\n                    fThrough[i] = $bm_neg(Math.abs(fThrough[i]));\n            }\n        } else {\n            if (prevValue > startValue)\n                fThrough = Math.abs(fThrough);\n            if (prevValue < startValue)\n                fThrough = $bm_neg(Math.abs(fThrough));\n        }\n    }\n    if (simulate) {\n        if (!isThisPosition) {\n            fThrough = $bm_sum(fThrough, getLayerWorldPos(time, thisLayer));\n            fThrough = $bm_sub(thisLayer.fromWorld(fThrough), thisLayer.anchorPoint);\n        } else if (thisLayer.hasParent) {\n            fThrough = $bm_sum(fThrough, getLayerWorldPos(time, thisLayer.parent));\n            fThrough = $bm_sub(thisLayer.parent.fromWorld(fThrough), thisLayer.parent.anchorPoint);\n        }\n    }\n    return fThrough;\n}\nfunction followThrough() {\n    var propSpeed = length(velocity);\n    if (propSpeed < threshold)\n        return followThroughAtTime($bm_sub(time, overlapDuration));\n    var fThrough = zeroValue;\n    var t = time;\n    while (t > 0) {\n        t = $bm_sub(t, thisComp.frameDuration);\n        if (simulate)\n            propSpeed = getPropWorldSpeed($bm_sub(t, overlapDuration), thisProperty);\n        else\n            propSpeed = length(velocityAtTime(t));\n        if (propSpeed < threshold) {\n            fThrough = followThroughAtTime($bm_sub(t, overlapDuration));\n            break;\n        }\n    }\n    return linear(time, t, $bm_sum(t, $bm_mul(anticipationDuration, 2)), fThrough, zeroValue);\n}\nfunction smartSmooth(axis) {\n    var startKey = nearestKey(time);\n    var endKey = startKey;\n    if (time == startKey.time)\n        return 0;\n    if (time < startKey.time && startKey.index == 1)\n        return 0;\n    if (time > startKey.time && startKey.index == numKeys)\n        return 0;\n    if (time < startKey.time)\n        startKey = key($bm_sub(startKey.index, 1));\n    if (time > startKey.time)\n        endKey = key($bm_sum(startKey.index, 1));\n    var sI = 0.66;\n    var sO = 0.33;\n    var sIV = 1;\n    var sOV = 0;\n    var sVal = startKey.value;\n    var eVal = endKey.value;\n    if ($bm_isInstanceOfArray(value)) {\n        sVal = sVal[axis];\n        eVal = eVal[axis];\n    }\n    var sTime = startKey.time;\n    var eTime = endKey.time;\n    if (isKeyTop(startKey, axis))\n        sO = slowOut;\n    else {\n        var prevKey = key($bm_sub(startKey.index, 1));\n        var pVal = prevKey.value;\n        if ($bm_isInstanceOfArray(value))\n            pVal = pVal[axis];\n        sOV = $bm_div($bm_sub(sVal, pVal), $bm_sub(eVal, pVal));\n    }\n    if (isKeyTop(endKey, axis)) {\n        sI = slowIn;\n        if (endKey.index != numKeys) {\n            var nextKey = key($bm_sum(endKey.index, 1));\n            var nVal = nextKey.value;\n            if ($bm_isInstanceOfArray(value))\n                nVal = nVal[axis];\n            if (Math.abs(nVal - eVal) < 0.01 && doFollowThrough)\n                sI = 1;\n        }\n    } else {\n        var nextKey = key($bm_sum(endKey.index, 1));\n        var nVal = nextKey.value;\n        if ($bm_isInstanceOfArray(value))\n            nVal = nVal[axis];\n        sIV = $bm_div($bm_sub(eVal, sVal), $bm_sub(nVal, sVal));\n    }\n    if (endKey.index == numKeys && doFollowThrough) {\n        sI = 1;\n    }\n    var val = value;\n    if ($bm_isInstanceOfArray(value))\n        val = val[axis];\n    return $bm_sub(bezierInterpolation(time, sTime, eTime, sVal, eVal, [\n        sO,\n        sOV,\n        sI,\n        sIV\n    ]), val);\n}\nfunction overlap() {\n    var ol = zeroValue;\n    if (isThisPosition && !hasParent)\n        return zeroValue;\n    ol = $bm_sub(getPropWorldValue($bm_sub(time, overlapDuration), thisProperty), getPropWorldValue(time, thisProperty));\n    var motionRatio = $bm_div($bm_div(length(zeroValue, ol), thisLayer.width), 2);\n    if (isThisPosition) {\n        var originalDistance = length(valueAtTime(0));\n        motionRatio = $bm_div(length(zeroValue, ol), thisComp.width);\n    }\n    ol = $bm_sum(ol, getPropWorldValue(time, thisProperty));\n    ol = $bm_sum(ol, $bm_mul($bm_mul($bm_sub(getPropWorldValue($bm_sub(time, overlapDuration), thisLayer.anchorPoint), ol), motionRatio), flexibility));\n    ol = thisLayer.fromWorld(ol);\n    if (!isThisPosition)\n        ol = $bm_sub(ol, value);\n    else {\n        ol = linear(flexibility, 0, 100, $bm_div(ol, 2), 0);\n        var prevParentWorldPos = getLayerWorldPos($bm_sub(time, overlapDuration), parent);\n        ol = $bm_sum(ol, $bm_mul($bm_mul($bm_mul(thisLayer.fromWorld(prevParentWorldPos), motionRatio), flexibility), 5));\n    }\n    return ol;\n}\nvar okToGo = false;\nif (simulate && fx.enabled)\n    okToGo = true;\nelse if (numKeys > 1 && fx.enabled)\n    okToGo = true;\nif (okToGo) {\n    var smartSmoothResult = zeroValue;\n    if (doInterpolation) {\n        if ($bm_isInstanceOfArray(value)) {\n            if (value.length == 2)\n                smartSmoothResult = [\n                    smartSmooth(0),\n                    smartSmooth(1)\n                ];\n            else if (value.length == 3)\n                smartSmoothResult = [\n                    smartSmooth(0),\n                    smartSmooth(1),\n                    smartSmooth(2)\n                ];\n            else if (value.length == 4)\n                smartSmoothResult = [\n                    smartSmooth(0),\n                    smartSmooth(1),\n                    smartSmooth(2),\n                    smartSmooth(3)\n                ];\n        } else {\n            smartSmoothResult = smartSmooth(0);\n        }\n    }\n    if (doAnticipation)\n        result = $bm_sum(result, anticipate());\n    result = $bm_sum(result, smartSmoothResult);\n    if (doFollowThrough)\n        result = $bm_sum(result, followThrough());\n    if (doOverlap)\n        result = $bm_sum(result, overlap());\n}\n$bm_rt = result;",
                    "a": 1
                  },
                  "nm": "Transform",
                  "sk": { "a": 0, "k": 0.0 },
                  "sa": { "a": 0, "k": 0.0 }
                }
              ]
            },
            {
              "ty": "gr",
              "nm": "Group 5",
              "bm": 0,
              "mn": "ADBE Vector Group",
              "it": [
                {
                  "ty": "gr",
                  "nm": "Group 3",
                  "bm": 0,
                  "mn": "ADBE Vector Group",
                  "it": [
                    {
                      "ty": "sh",
                      "nm": "Path 1",
                      "mn": "ADBE Vector Shape - Group",
                      "ind": 0,
                      "ks": {
                        "k": {
                          "i": [
                            [0.0, -3.168],
                            [17.303, 0.0],
                            [0.0, 3.168],
                            [-17.303, 0.0]
                          ],
                          "o": [
                            [0.0, 3.168],
                            [-17.303, 0.0],
                            [0.0, -3.168],
                            [17.303, 0.0]
                          ],
                          "v": [
                            [-32.62, -29.736],
                            [-63.949, -24.001],
                            [-95.279, -29.736],
                            [-63.949, -35.472]
                          ],
                          "c": true
                        },
                        "a": 0
                      }
                    },
                    {
                      "ty": "fl",
                      "nm": "Fill 1",
                      "bm": 0,
                      "mn": "ADBE Vector Graphic - Fill",
                      "c": { "a": 0, "k": [0.0, 0.0, 0.0, 1.0] },
                      "o": { "a": 0, "k": 100.0 },
                      "r": 1
                    },
                    {
                      "ty": "tr",
                      "o": { "a": 0, "k": 100.0 },
                      "r": { "a": 0, "k": 0.0 },
                      "p": { "a": 0, "k": [0.0, 0.0] },
                      "a": { "a": 0, "k": [0.0, 0.0] },
                      "s": { "a": 0, "k": [100.0, 100.0] },
                      "nm": "Transform",
                      "sk": { "a": 0, "k": 0.0 },
                      "sa": { "a": 0, "k": 0.0 }
                    }
                  ]
                },
                {
                  "ty": "tr",
                  "o": {
                    "a": 1,
                    "k": [
                      {
                        "i": { "x": [0.667], "y": [1] },
                        "o": { "x": [0.333], "y": [0] },
                        "t": 72,
                        "s": [10.0]
                      },
                      { "t": 76, "s": [0.0] }
                    ]
                  },
                  "r": { "a": 0, "k": 0.0 },
                  "p": {
                    "a": 0,
                    "k": [-63.95, -29.736],
                    "x": "var $bm_rt;\nvar fx = effect('\u015dlosilo pli pura 4');\nvar doAnticipation = fx(1).value;\nvar doInterpolation = fx(2).value;\nvar doFollowThrough = fx(3).value;\nvar damping = $bm_div(fx(15).value, 10);\nvar elasticity = $bm_div(fx(13).value, 10);\nvar bounce = fx(17).value;\nvar anticipationDuration = fx(5).value;\nvar anticipationQuantity = $bm_div(fx(6).value, 100);\nvar slowIn = $bm_div(fx(9).value, 100);\nvar slowOut = $bm_div(fx(10).value, 100);\nvar spatialMode = fx(21).value;\nvar spatialDoInterpolation = fx(20).value;\nvar moBlurPrecision = fx(32).value;\nvar elasticityRandom = fx(14).value;\nvar dampingRandom = fx(16).value;\nvar softBody = fx(28).value;\nvar flexibility = $bm_div(fx(29).value, 100);\nvar doOverlap = fx(23).value;\nvar overlapDuration = fx(24).value;\nvar overlapRandom = fx(25).value;\nvar threshold = $bm_div($bm_div(1, moBlurPrecision), 1000);\nvar zeroValue;\nif ($bm_isInstanceOfArray(value)) {\n    if (value.length == 2)\n        zeroValue = [\n            0,\n            0\n        ];\n    else if (value.length == 3)\n        zeroValue = [\n            0,\n            0,\n            0\n        ];\n    else if (value.length == 4)\n        zeroValue = [\n            0,\n            0,\n            0,\n            0\n        ];\n} else\n    zeroValue = 0;\nvar isThisSpatial = isSpatial(thisProperty);\nvar isThisPosition = thisProperty === $bm_transform.position;\nvar simulate = false;\nif (isThisSpatial) {\n    doInterpolation = doInterpolation && spatialDoInterpolation;\n    if (isThisPosition && thisProperty.numKeys > 0) {\n        doOverlap = false;\n        simulate = false;\n    } else {\n        simulate = spatialMode == 2;\n        doOverlap = overlapDuration != 0 && doOverlap && simulate;\n    }\n} else {\n    doOverlap = false;\n}\nif (!doOverlap) {\n    overlapDuration = 0;\n}\nif (simulate && softBody && isThisSpatial && !isThisPosition && (doFollowThrough || doOverlap)) {\n    var distanceRatio = $bm_div(length(valueAtTime(0), $bm_transform.anchorPoint), $bm_div(thisLayer.width, 2));\n    distanceRatio = $bm_div($bm_sum(1, $bm_mul(distanceRatio, flexibility)), 2);\n    if (doFollowThrough) {\n        elasticity = $bm_div(elasticity, distanceRatio);\n        damping = $bm_div(damping, distanceRatio);\n    }\n    if (doOverlap) {\n        overlapDuration = $bm_mul(overlapDuration, distanceRatio);\n    }\n}\nseedRandom(0, true);\nif (doFollowThrough) {\n    if (elasticityRandom > 0)\n        elasticity = addNoise(elasticity, elasticityRandom);\n    if (dampingRandom > 0)\n        damping = addNoise(damping, dampingRandom);\n}\nif (doOverlap) {\n    if (doOverlap && overlapRandom > 0)\n        overlapDuration = addNoise(overlapDuration, overlapRandom);\n}\nvar result = value;\nfunction isSpatial(prop) {\n    if (!(prop.value instanceof Array))\n        return false;\n    if (prop.value.length != 2 && prop.value.length != 3)\n        return false;\n    try {\n        if (typeof prop.speed !== 'undefined')\n            return true;\n    } catch (e) {\n        return false;\n    }\n}\nfunction addNoise(val, quantity) {\n    var randomValue = random(0.9, 1.1);\n    var noiseValue = noise($bm_mul(valueAtTime(0), randomValue));\n    noiseValue = $bm_mul(noiseValue, $bm_div(quantity, 100));\n    return $bm_mul(val, $bm_sum(noiseValue, 1));\n}\nfunction isAfterLastKey() {\n    if (numKeys == 0)\n        return false;\n    var nKey = nearestKey(time);\n    return nKey.time <= time && nKey.index == numKeys;\n}\nfunction isStill(t, threshold) {\n    var d = $bm_sub(valueAtTime(t), valueAtTime($bm_sum(t, framesToTime(1))));\n    if ($bm_isInstanceOfArray(d)) {\n        for (var i = 0; i < d.length; i++) {\n            d[i] = Math.abs(d[i]);\n            if (d[i] >= threshold) {\n                return false;\n            }\n        }\n        return true;\n    } else {\n        d = Math.abs(d);\n        return d < threshold;\n    }\n}\nfunction bezierInterpolation(t, tMin, tMax, value1, value2, bezierPoints) {\n    if (arguments.length !== 5 && arguments.length !== 6)\n        return t;\n    var a = $bm_sub(value2, value1);\n    var b = $bm_sub(tMax, tMin);\n    if (b == 0)\n        return t;\n    var c = clamp($bm_div($bm_sub(t, tMin), b), 0, 1);\n    if (!(bezierPoints instanceof Array) || bezierPoints.length !== 4)\n        bezierPoints = [\n            0.33,\n            0,\n            0.66,\n            1\n        ];\n    return $bm_sum($bm_mul(a, h(c, bezierPoints)), value1);\n    function h(f, g) {\n        var x = $bm_mul(3, g[0]);\n        var j = $bm_sub($bm_mul(3, $bm_sub(g[2], g[0])), x);\n        var k = $bm_sub($bm_sub(1, x), j);\n        var l = $bm_mul(3, g[1]);\n        var m = $bm_sub($bm_mul(3, $bm_sub(g[3], g[1])), l);\n        var n = $bm_sub($bm_sub(1, l), m);\n        var d = f;\n        for (var i = 0; i < 5; i++) {\n            var z = $bm_sub($bm_mul(d, $bm_sum(x, $bm_mul(d, $bm_sum(j, $bm_mul(d, k))))), f);\n            if (Math.abs(z) < 0.001)\n                break;\n            d = $bm_sub(d, $bm_div(z, $bm_sum(x, $bm_mul(d, $bm_sum($bm_mul(2, j), $bm_mul($bm_mul(3, k), d))))));\n        }\n        return $bm_mul(d, $bm_sum(l, $bm_mul(d, $bm_sum(m, $bm_mul(d, n)))));\n    }\n}\nfunction getPropWorldSpeed(t, prop) {\n    return length(getPropWorldVelocity(t, prop));\n}\nfunction getPrevKey(t) {\n    if (numKeys == 0)\n        return null;\n    var nKey = nearestKey(t);\n    if (nKey.time <= t)\n        return nKey;\n    if (nKey.index > 1)\n        return key($bm_sub(nKey.index, 1));\n    return null;\n}\nfunction getNextKey(t) {\n    if (numKeys == 0)\n        return null;\n    var nKey = nearestKey(t);\n    if (nKey.time >= t)\n        return nKey;\n    if (nKey.index < numKeys)\n        return key($bm_sum(nKey.index, 1));\n    return null;\n}\nfunction getPropWorldVelocity(t, prop) {\n    return $bm_mul($bm_sub(getPropWorldValue($bm_sum(t, 0.005), prop), getPropWorldValue($bm_sub(t, 0.005), prop)), 100);\n}\nfunction getLayerWorldPos(t, l) {\n    return l.toWorld(l.anchorPoint, t);\n}\nfunction getPropWorldValue(t, prop) {\n    if (isPosition(prop))\n        return getLayerWorldPos(t, thisLayer);\n    return thisLayer.toWorld(prop.valueAtTime(t), t);\n}\nfunction isPosition(prop) {\n    return prop === $bm_transform.position;\n}\nfunction isKeyTop(k, axis) {\n    var prevSpeed = velocityAtTime($bm_sub(k.time, threshold));\n    var nextSpeed = velocityAtTime($bm_sum(k.time, threshold));\n    if ($bm_isInstanceOfArray(value)) {\n        prevSpeed = prevSpeed[axis];\n        nextSpeed = nextSpeed[axis];\n    }\n    if (Math.abs(prevSpeed) < 0.01 || Math.abs(nextSpeed) < 0.01)\n        return true;\n    return $bm_mul(prevSpeed, nextSpeed) < 0;\n}\nfunction anticipate() {\n    var anticipation = zeroValue;\n    if (isAfterLastKey())\n        return anticipation;\n    if (numKeys < 2)\n        return anticipation;\n    var nextKey = getNextKey(time);\n    var aKey = nextKey;\n    if (!isStill(aKey.time - 0.1, 0.1)) {\n        aKey = getPrevKey(time);\n        if (!isStill(aKey.time - 0.1, 0.1))\n            return anticipation;\n    }\n    if (aKey.index == numKeys)\n        return anticipation;\n    var anticipationMiddle = aKey.time;\n    var anticipationStart = $bm_sub(anticipationMiddle, anticipationDuration);\n    var anticipationEnd = key(aKey.index + 1).time;\n    var startValue = anticipation;\n    var midValue = $bm_mul($bm_sum($bm_neg(valueAtTime($bm_sum(anticipationMiddle, anticipationDuration))), aKey.value), anticipationQuantity);\n    var endValue = anticipation;\n    if (time < anticipationStart) {\n        return anticipation;\n    } else if (time < anticipationMiddle) {\n        if ($bm_isInstanceOfArray(value)) {\n            for (var i = 0; i < value.length; i++) {\n                anticipation[i] = bezierInterpolation(time, anticipationStart, anticipationMiddle, startValue[i], midValue[i], [\n                    slowOut,\n                    0,\n                    slowIn,\n                    1\n                ]);\n            }\n            return anticipation;\n        } else {\n            return bezierInterpolation(time, anticipationStart, anticipationMiddle, startValue, midValue, [\n                slowOut,\n                0,\n                slowIn,\n                1\n            ]);\n        }\n    } else if (time <= anticipationEnd) {\n        if ($bm_isInstanceOfArray(value)) {\n            for (var i = 0; i < value.length; i++) {\n                anticipation[i] = bezierInterpolation(time, anticipationMiddle, anticipationEnd, midValue[i], endValue[i], [\n                    slowOut,\n                    0,\n                    slowIn,\n                    1\n                ]);\n            }\n            return anticipation;\n        } else {\n            return bezierInterpolation(time, anticipationMiddle, anticipationEnd, midValue, endValue, [\n                slowOut,\n                0,\n                slowIn,\n                1\n            ]);\n        }\n    } else {\n        return anticipation;\n    }\n}\nfunction followThroughAtTime(t) {\n    var fThrough = zeroValue;\n    if (elasticity == 0)\n        return fThrough;\n    var propSpeed;\n    if (!simulate) {\n        if (numKeys < 2)\n            return fThrough;\n        if (nearestKey(t).index == 1)\n            return fThrough;\n        propSpeed = length(velocityAtTime(t));\n        if (propSpeed >= threshold)\n            return fThrough;\n    } else {\n        propSpeed = getPropWorldSpeed(t, thisProperty);\n        if (propSpeed >= threshold)\n            return fThrough;\n    }\n    var fThroughStart = 0;\n    var fThroughTime = 0;\n    if (simulate) {\n        var speedI = getPropWorldSpeed(t, thisProperty);\n        var i = t;\n        while (speedI < threshold && i > 0) {\n            i = $bm_sub(i, $bm_div(thisComp.frameDuration, moBlurPrecision));\n            speedI = getPropWorldSpeed(i, thisProperty);\n        }\n        fThroughStart = i;\n    } else {\n        var fThroughKey = getPrevKey(t);\n        fThroughStart = fThroughKey.time;\n    }\n    if (fThroughStart == 0)\n        return fThrough;\n    fThroughTime = $bm_sub(t, fThroughStart);\n    if (simulate)\n        fThrough = $bm_div(getPropWorldVelocity($bm_sub(fThroughStart, thisComp.frameDuration), thisProperty), 2);\n    else\n        fThrough = $bm_div(velocityAtTime($bm_sub(fThroughStart, thisComp.frameDuration)), 2);\n    if (bounce) {\n        var cycleDamp = Math.exp($bm_mul($bm_mul(fThroughTime, damping), 0.1));\n        var damp = $bm_div(Math.exp($bm_mul(fThroughTime, damping)), $bm_div(elasticity, 2));\n        var cycleDuration = $bm_div(1, $bm_mul(elasticity, 2));\n        cycleDuration = Math.round(timeToFrames(cycleDuration));\n        cycleDuration = framesToTime(cycleDuration);\n        var midDuration = $bm_div(cycleDuration, 2);\n        var maxValue = $bm_mul(fThrough, midDuration);\n        var cycvarime = fThroughTime;\n        var numEndCycles = 1;\n        while (cycvarime > cycleDuration) {\n            cycvarime = $bm_sub(cycvarime, cycleDuration);\n            cycleDuration = $bm_div(cycleDuration, cycleDamp);\n            cycleDuration = Math.round(timeToFrames(cycleDuration));\n            if (cycleDuration < 2) {\n                cycleDuration = 2;\n                numEndCycles++;\n            }\n            cycleDuration = framesToTime(cycleDuration);\n            midDuration = $bm_div(cycleDuration, 2);\n            maxValue = $bm_div($bm_mul(fThrough, midDuration), damp);\n            if (numEndCycles > 100 / damping && maxValue < threshold)\n                return zeroValue;\n        }\n        if (cycvarime < midDuration)\n            fThrough = bezierInterpolation(cycvarime, 0, midDuration, 0, maxValue, [\n                0,\n                0.1,\n                slowIn,\n                1\n            ]);\n        else\n            fThrough = bezierInterpolation(cycvarime, midDuration, cycleDuration, maxValue, 0, [\n                $bm_sub(1, slowIn),\n                0,\n                1,\n                0.9\n            ]);\n    } else {\n        var damp = Math.exp($bm_mul(fThroughTime, damping));\n        var sinus = $bm_mul($bm_mul($bm_mul(elasticity, fThroughTime), 2), Math.PI);\n        sinus = Math.sin(sinus);\n        sinus = $bm_mul($bm_div(0.3, elasticity), sinus);\n        sinus = $bm_div(sinus, damp);\n        if (Math.abs(sinus) < $bm_div(threshold, 100))\n            return 0;\n        fThrough = $bm_mul(fThrough, sinus);\n        if (threshold > 0) {\n            fThrough = $bm_mul(fThrough, $bm_sub(1, $bm_div(propSpeed, threshold)));\n        }\n    }\n    if (bounce) {\n        var prevValue = valueAtTime($bm_sub(fThroughStart, thisComp.frameDuration));\n        var startValue = valueAtTime(fThroughStart);\n        if ($bm_isInstanceOfArray(value)) {\n            for (var i = 0; i < prevValue.length; i++) {\n                if (prevValue[i] > startValue[i])\n                    fThrough[i] = Math.abs(fThrough[i]);\n                if (prevValue[i] < startValue[i])\n                    fThrough[i] = $bm_neg(Math.abs(fThrough[i]));\n            }\n        } else {\n            if (prevValue > startValue)\n                fThrough = Math.abs(fThrough);\n            if (prevValue < startValue)\n                fThrough = $bm_neg(Math.abs(fThrough));\n        }\n    }\n    if (simulate) {\n        if (!isThisPosition) {\n            fThrough = $bm_sum(fThrough, getLayerWorldPos(time, thisLayer));\n            fThrough = $bm_sub(thisLayer.fromWorld(fThrough), thisLayer.anchorPoint);\n        } else if (thisLayer.hasParent) {\n            fThrough = $bm_sum(fThrough, getLayerWorldPos(time, thisLayer.parent));\n            fThrough = $bm_sub(thisLayer.parent.fromWorld(fThrough), thisLayer.parent.anchorPoint);\n        }\n    }\n    return fThrough;\n}\nfunction followThrough() {\n    var propSpeed = length(velocity);\n    if (propSpeed < threshold)\n        return followThroughAtTime($bm_sub(time, overlapDuration));\n    var fThrough = zeroValue;\n    var t = time;\n    while (t > 0) {\n        t = $bm_sub(t, thisComp.frameDuration);\n        if (simulate)\n            propSpeed = getPropWorldSpeed($bm_sub(t, overlapDuration), thisProperty);\n        else\n            propSpeed = length(velocityAtTime(t));\n        if (propSpeed < threshold) {\n            fThrough = followThroughAtTime($bm_sub(t, overlapDuration));\n            break;\n        }\n    }\n    return linear(time, t, $bm_sum(t, $bm_mul(anticipationDuration, 2)), fThrough, zeroValue);\n}\nfunction smartSmooth(axis) {\n    var startKey = nearestKey(time);\n    var endKey = startKey;\n    if (time == startKey.time)\n        return 0;\n    if (time < startKey.time && startKey.index == 1)\n        return 0;\n    if (time > startKey.time && startKey.index == numKeys)\n        return 0;\n    if (time < startKey.time)\n        startKey = key($bm_sub(startKey.index, 1));\n    if (time > startKey.time)\n        endKey = key($bm_sum(startKey.index, 1));\n    var sI = 0.66;\n    var sO = 0.33;\n    var sIV = 1;\n    var sOV = 0;\n    var sVal = startKey.value;\n    var eVal = endKey.value;\n    if ($bm_isInstanceOfArray(value)) {\n        sVal = sVal[axis];\n        eVal = eVal[axis];\n    }\n    var sTime = startKey.time;\n    var eTime = endKey.time;\n    if (isKeyTop(startKey, axis))\n        sO = slowOut;\n    else {\n        var prevKey = key($bm_sub(startKey.index, 1));\n        var pVal = prevKey.value;\n        if ($bm_isInstanceOfArray(value))\n            pVal = pVal[axis];\n        sOV = $bm_div($bm_sub(sVal, pVal), $bm_sub(eVal, pVal));\n    }\n    if (isKeyTop(endKey, axis)) {\n        sI = slowIn;\n        if (endKey.index != numKeys) {\n            var nextKey = key($bm_sum(endKey.index, 1));\n            var nVal = nextKey.value;\n            if ($bm_isInstanceOfArray(value))\n                nVal = nVal[axis];\n            if (Math.abs(nVal - eVal) < 0.01 && doFollowThrough)\n                sI = 1;\n        }\n    } else {\n        var nextKey = key($bm_sum(endKey.index, 1));\n        var nVal = nextKey.value;\n        if ($bm_isInstanceOfArray(value))\n            nVal = nVal[axis];\n        sIV = $bm_div($bm_sub(eVal, sVal), $bm_sub(nVal, sVal));\n    }\n    if (endKey.index == numKeys && doFollowThrough) {\n        sI = 1;\n    }\n    var val = value;\n    if ($bm_isInstanceOfArray(value))\n        val = val[axis];\n    return $bm_sub(bezierInterpolation(time, sTime, eTime, sVal, eVal, [\n        sO,\n        sOV,\n        sI,\n        sIV\n    ]), val);\n}\nfunction overlap() {\n    var ol = zeroValue;\n    if (isThisPosition && !hasParent)\n        return zeroValue;\n    ol = $bm_sub(getPropWorldValue($bm_sub(time, overlapDuration), thisProperty), getPropWorldValue(time, thisProperty));\n    var motionRatio = $bm_div($bm_div(length(zeroValue, ol), thisLayer.width), 2);\n    if (isThisPosition) {\n        var originalDistance = length(valueAtTime(0));\n        motionRatio = $bm_div(length(zeroValue, ol), thisComp.width);\n    }\n    ol = $bm_sum(ol, getPropWorldValue(time, thisProperty));\n    ol = $bm_sum(ol, $bm_mul($bm_mul($bm_sub(getPropWorldValue($bm_sub(time, overlapDuration), thisLayer.anchorPoint), ol), motionRatio), flexibility));\n    ol = thisLayer.fromWorld(ol);\n    if (!isThisPosition)\n        ol = $bm_sub(ol, value);\n    else {\n        ol = linear(flexibility, 0, 100, $bm_div(ol, 2), 0);\n        var prevParentWorldPos = getLayerWorldPos($bm_sub(time, overlapDuration), parent);\n        ol = $bm_sum(ol, $bm_mul($bm_mul($bm_mul(thisLayer.fromWorld(prevParentWorldPos), motionRatio), flexibility), 5));\n    }\n    return ol;\n}\nvar okToGo = false;\nif (simulate && fx.enabled)\n    okToGo = true;\nelse if (numKeys > 1 && fx.enabled)\n    okToGo = true;\nif (okToGo) {\n    var smartSmoothResult = zeroValue;\n    if (doInterpolation) {\n        if ($bm_isInstanceOfArray(value)) {\n            if (value.length == 2)\n                smartSmoothResult = [\n                    smartSmooth(0),\n                    smartSmooth(1)\n                ];\n            else if (value.length == 3)\n                smartSmoothResult = [\n                    smartSmooth(0),\n                    smartSmooth(1),\n                    smartSmooth(2)\n                ];\n            else if (value.length == 4)\n                smartSmoothResult = [\n                    smartSmooth(0),\n                    smartSmooth(1),\n                    smartSmooth(2),\n                    smartSmooth(3)\n                ];\n        } else {\n            smartSmoothResult = smartSmooth(0);\n        }\n    }\n    if (doAnticipation)\n        result = $bm_sum(result, anticipate());\n    result = $bm_sum(result, smartSmoothResult);\n    if (doFollowThrough)\n        result = $bm_sum(result, followThrough());\n    if (doOverlap)\n        result = $bm_sum(result, overlap());\n}\n$bm_rt = result;"
                  },
                  "a": { "a": 0, "k": [-63.95, -29.736] },
                  "s": {
                    "k": [
                      {
                        "i": { "x": [0.667, 0.667], "y": [1.0, 1.0] },
                        "o": { "x": [0.333, 0.333], "y": [0.0, 0.0] },
                        "t": 59,
                        "s": [100, 100]
                      },
                      { "t": 72, "s": [160, 160] }
                    ],
                    "x": "var $bm_rt;\nvar fx = effect('\u015dlosilo pli pura 4');\nvar doAnticipation = fx(1).value;\nvar doInterpolation = fx(2).value;\nvar doFollowThrough = fx(3).value;\nvar damping = $bm_div(fx(15).value, 10);\nvar elasticity = $bm_div(fx(13).value, 10);\nvar bounce = fx(17).value;\nvar anticipationDuration = fx(5).value;\nvar anticipationQuantity = $bm_div(fx(6).value, 100);\nvar slowIn = $bm_div(fx(9).value, 100);\nvar slowOut = $bm_div(fx(10).value, 100);\nvar spatialMode = fx(21).value;\nvar spatialDoInterpolation = fx(20).value;\nvar moBlurPrecision = fx(32).value;\nvar elasticityRandom = fx(14).value;\nvar dampingRandom = fx(16).value;\nvar softBody = fx(28).value;\nvar flexibility = $bm_div(fx(29).value, 100);\nvar doOverlap = fx(23).value;\nvar overlapDuration = fx(24).value;\nvar overlapRandom = fx(25).value;\nvar threshold = $bm_div($bm_div(1, moBlurPrecision), 1000);\nvar zeroValue;\nif ($bm_isInstanceOfArray(value)) {\n    if (value.length == 2)\n        zeroValue = [\n            0,\n            0\n        ];\n    else if (value.length == 3)\n        zeroValue = [\n            0,\n            0,\n            0\n        ];\n    else if (value.length == 4)\n        zeroValue = [\n            0,\n            0,\n            0,\n            0\n        ];\n} else\n    zeroValue = 0;\nvar isThisSpatial = isSpatial(thisProperty);\nvar isThisPosition = thisProperty === $bm_transform.position;\nvar simulate = false;\nif (isThisSpatial) {\n    doInterpolation = doInterpolation && spatialDoInterpolation;\n    if (isThisPosition && thisProperty.numKeys > 0) {\n        doOverlap = false;\n        simulate = false;\n    } else {\n        simulate = spatialMode == 2;\n        doOverlap = overlapDuration != 0 && doOverlap && simulate;\n    }\n} else {\n    doOverlap = false;\n}\nif (!doOverlap) {\n    overlapDuration = 0;\n}\nif (simulate && softBody && isThisSpatial && !isThisPosition && (doFollowThrough || doOverlap)) {\n    var distanceRatio = $bm_div(length(valueAtTime(0), $bm_transform.anchorPoint), $bm_div(thisLayer.width, 2));\n    distanceRatio = $bm_div($bm_sum(1, $bm_mul(distanceRatio, flexibility)), 2);\n    if (doFollowThrough) {\n        elasticity = $bm_div(elasticity, distanceRatio);\n        damping = $bm_div(damping, distanceRatio);\n    }\n    if (doOverlap) {\n        overlapDuration = $bm_mul(overlapDuration, distanceRatio);\n    }\n}\nseedRandom(0, true);\nif (doFollowThrough) {\n    if (elasticityRandom > 0)\n        elasticity = addNoise(elasticity, elasticityRandom);\n    if (dampingRandom > 0)\n        damping = addNoise(damping, dampingRandom);\n}\nif (doOverlap) {\n    if (doOverlap && overlapRandom > 0)\n        overlapDuration = addNoise(overlapDuration, overlapRandom);\n}\nvar result = value;\nfunction isSpatial(prop) {\n    if (!(prop.value instanceof Array))\n        return false;\n    if (prop.value.length != 2 && prop.value.length != 3)\n        return false;\n    try {\n        if (typeof prop.speed !== 'undefined')\n            return true;\n    } catch (e) {\n        return false;\n    }\n}\nfunction addNoise(val, quantity) {\n    var randomValue = random(0.9, 1.1);\n    var noiseValue = noise($bm_mul(valueAtTime(0), randomValue));\n    noiseValue = $bm_mul(noiseValue, $bm_div(quantity, 100));\n    return $bm_mul(val, $bm_sum(noiseValue, 1));\n}\nfunction isAfterLastKey() {\n    if (numKeys == 0)\n        return false;\n    var nKey = nearestKey(time);\n    return nKey.time <= time && nKey.index == numKeys;\n}\nfunction isStill(t, threshold) {\n    var d = $bm_sub(valueAtTime(t), valueAtTime($bm_sum(t, framesToTime(1))));\n    if ($bm_isInstanceOfArray(d)) {\n        for (var i = 0; i < d.length; i++) {\n            d[i] = Math.abs(d[i]);\n            if (d[i] >= threshold) {\n                return false;\n            }\n        }\n        return true;\n    } else {\n        d = Math.abs(d);\n        return d < threshold;\n    }\n}\nfunction bezierInterpolation(t, tMin, tMax, value1, value2, bezierPoints) {\n    if (arguments.length !== 5 && arguments.length !== 6)\n        return t;\n    var a = $bm_sub(value2, value1);\n    var b = $bm_sub(tMax, tMin);\n    if (b == 0)\n        return t;\n    var c = clamp($bm_div($bm_sub(t, tMin), b), 0, 1);\n    if (!(bezierPoints instanceof Array) || bezierPoints.length !== 4)\n        bezierPoints = [\n            0.33,\n            0,\n            0.66,\n            1\n        ];\n    return $bm_sum($bm_mul(a, h(c, bezierPoints)), value1);\n    function h(f, g) {\n        var x = $bm_mul(3, g[0]);\n        var j = $bm_sub($bm_mul(3, $bm_sub(g[2], g[0])), x);\n        var k = $bm_sub($bm_sub(1, x), j);\n        var l = $bm_mul(3, g[1]);\n        var m = $bm_sub($bm_mul(3, $bm_sub(g[3], g[1])), l);\n        var n = $bm_sub($bm_sub(1, l), m);\n        var d = f;\n        for (var i = 0; i < 5; i++) {\n            var z = $bm_sub($bm_mul(d, $bm_sum(x, $bm_mul(d, $bm_sum(j, $bm_mul(d, k))))), f);\n            if (Math.abs(z) < 0.001)\n                break;\n            d = $bm_sub(d, $bm_div(z, $bm_sum(x, $bm_mul(d, $bm_sum($bm_mul(2, j), $bm_mul($bm_mul(3, k), d))))));\n        }\n        return $bm_mul(d, $bm_sum(l, $bm_mul(d, $bm_sum(m, $bm_mul(d, n)))));\n    }\n}\nfunction getPropWorldSpeed(t, prop) {\n    return length(getPropWorldVelocity(t, prop));\n}\nfunction getPrevKey(t) {\n    if (numKeys == 0)\n        return null;\n    var nKey = nearestKey(t);\n    if (nKey.time <= t)\n        return nKey;\n    if (nKey.index > 1)\n        return key($bm_sub(nKey.index, 1));\n    return null;\n}\nfunction getNextKey(t) {\n    if (numKeys == 0)\n        return null;\n    var nKey = nearestKey(t);\n    if (nKey.time >= t)\n        return nKey;\n    if (nKey.index < numKeys)\n        return key($bm_sum(nKey.index, 1));\n    return null;\n}\nfunction getPropWorldVelocity(t, prop) {\n    return $bm_mul($bm_sub(getPropWorldValue($bm_sum(t, 0.005), prop), getPropWorldValue($bm_sub(t, 0.005), prop)), 100);\n}\nfunction getLayerWorldPos(t, l) {\n    return l.toWorld(l.anchorPoint, t);\n}\nfunction getPropWorldValue(t, prop) {\n    if (isPosition(prop))\n        return getLayerWorldPos(t, thisLayer);\n    return thisLayer.toWorld(prop.valueAtTime(t), t);\n}\nfunction isPosition(prop) {\n    return prop === $bm_transform.position;\n}\nfunction isKeyTop(k, axis) {\n    var prevSpeed = velocityAtTime($bm_sub(k.time, threshold));\n    var nextSpeed = velocityAtTime($bm_sum(k.time, threshold));\n    if ($bm_isInstanceOfArray(value)) {\n        prevSpeed = prevSpeed[axis];\n        nextSpeed = nextSpeed[axis];\n    }\n    if (Math.abs(prevSpeed) < 0.01 || Math.abs(nextSpeed) < 0.01)\n        return true;\n    return $bm_mul(prevSpeed, nextSpeed) < 0;\n}\nfunction anticipate() {\n    var anticipation = zeroValue;\n    if (isAfterLastKey())\n        return anticipation;\n    if (numKeys < 2)\n        return anticipation;\n    var nextKey = getNextKey(time);\n    var aKey = nextKey;\n    if (!isStill(aKey.time - 0.1, 0.1)) {\n        aKey = getPrevKey(time);\n        if (!isStill(aKey.time - 0.1, 0.1))\n            return anticipation;\n    }\n    if (aKey.index == numKeys)\n        return anticipation;\n    var anticipationMiddle = aKey.time;\n    var anticipationStart = $bm_sub(anticipationMiddle, anticipationDuration);\n    var anticipationEnd = key(aKey.index + 1).time;\n    var startValue = anticipation;\n    var midValue = $bm_mul($bm_sum($bm_neg(valueAtTime($bm_sum(anticipationMiddle, anticipationDuration))), aKey.value), anticipationQuantity);\n    var endValue = anticipation;\n    if (time < anticipationStart) {\n        return anticipation;\n    } else if (time < anticipationMiddle) {\n        if ($bm_isInstanceOfArray(value)) {\n            for (var i = 0; i < value.length; i++) {\n                anticipation[i] = bezierInterpolation(time, anticipationStart, anticipationMiddle, startValue[i], midValue[i], [\n                    slowOut,\n                    0,\n                    slowIn,\n                    1\n                ]);\n            }\n            return anticipation;\n        } else {\n            return bezierInterpolation(time, anticipationStart, anticipationMiddle, startValue, midValue, [\n                slowOut,\n                0,\n                slowIn,\n                1\n            ]);\n        }\n    } else if (time <= anticipationEnd) {\n        if ($bm_isInstanceOfArray(value)) {\n            for (var i = 0; i < value.length; i++) {\n                anticipation[i] = bezierInterpolation(time, anticipationMiddle, anticipationEnd, midValue[i], endValue[i], [\n                    slowOut,\n                    0,\n                    slowIn,\n                    1\n                ]);\n            }\n            return anticipation;\n        } else {\n            return bezierInterpolation(time, anticipationMiddle, anticipationEnd, midValue, endValue, [\n                slowOut,\n                0,\n                slowIn,\n                1\n            ]);\n        }\n    } else {\n        return anticipation;\n    }\n}\nfunction followThroughAtTime(t) {\n    var fThrough = zeroValue;\n    if (elasticity == 0)\n        return fThrough;\n    var propSpeed;\n    if (!simulate) {\n        if (numKeys < 2)\n            return fThrough;\n        if (nearestKey(t).index == 1)\n            return fThrough;\n        propSpeed = length(velocityAtTime(t));\n        if (propSpeed >= threshold)\n            return fThrough;\n    } else {\n        propSpeed = getPropWorldSpeed(t, thisProperty);\n        if (propSpeed >= threshold)\n            return fThrough;\n    }\n    var fThroughStart = 0;\n    var fThroughTime = 0;\n    if (simulate) {\n        var speedI = getPropWorldSpeed(t, thisProperty);\n        var i = t;\n        while (speedI < threshold && i > 0) {\n            i = $bm_sub(i, $bm_div(thisComp.frameDuration, moBlurPrecision));\n            speedI = getPropWorldSpeed(i, thisProperty);\n        }\n        fThroughStart = i;\n    } else {\n        var fThroughKey = getPrevKey(t);\n        fThroughStart = fThroughKey.time;\n    }\n    if (fThroughStart == 0)\n        return fThrough;\n    fThroughTime = $bm_sub(t, fThroughStart);\n    if (simulate)\n        fThrough = $bm_div(getPropWorldVelocity($bm_sub(fThroughStart, thisComp.frameDuration), thisProperty), 2);\n    else\n        fThrough = $bm_div(velocityAtTime($bm_sub(fThroughStart, thisComp.frameDuration)), 2);\n    if (bounce) {\n        var cycleDamp = Math.exp($bm_mul($bm_mul(fThroughTime, damping), 0.1));\n        var damp = $bm_div(Math.exp($bm_mul(fThroughTime, damping)), $bm_div(elasticity, 2));\n        var cycleDuration = $bm_div(1, $bm_mul(elasticity, 2));\n        cycleDuration = Math.round(timeToFrames(cycleDuration));\n        cycleDuration = framesToTime(cycleDuration);\n        var midDuration = $bm_div(cycleDuration, 2);\n        var maxValue = $bm_mul(fThrough, midDuration);\n        var cycvarime = fThroughTime;\n        var numEndCycles = 1;\n        while (cycvarime > cycleDuration) {\n            cycvarime = $bm_sub(cycvarime, cycleDuration);\n            cycleDuration = $bm_div(cycleDuration, cycleDamp);\n            cycleDuration = Math.round(timeToFrames(cycleDuration));\n            if (cycleDuration < 2) {\n                cycleDuration = 2;\n                numEndCycles++;\n            }\n            cycleDuration = framesToTime(cycleDuration);\n            midDuration = $bm_div(cycleDuration, 2);\n            maxValue = $bm_div($bm_mul(fThrough, midDuration), damp);\n            if (numEndCycles > 100 / damping && maxValue < threshold)\n                return zeroValue;\n        }\n        if (cycvarime < midDuration)\n            fThrough = bezierInterpolation(cycvarime, 0, midDuration, 0, maxValue, [\n                0,\n                0.1,\n                slowIn,\n                1\n            ]);\n        else\n            fThrough = bezierInterpolation(cycvarime, midDuration, cycleDuration, maxValue, 0, [\n                $bm_sub(1, slowIn),\n                0,\n                1,\n                0.9\n            ]);\n    } else {\n        var damp = Math.exp($bm_mul(fThroughTime, damping));\n        var sinus = $bm_mul($bm_mul($bm_mul(elasticity, fThroughTime), 2), Math.PI);\n        sinus = Math.sin(sinus);\n        sinus = $bm_mul($bm_div(0.3, elasticity), sinus);\n        sinus = $bm_div(sinus, damp);\n        if (Math.abs(sinus) < $bm_div(threshold, 100))\n            return 0;\n        fThrough = $bm_mul(fThrough, sinus);\n        if (threshold > 0) {\n            fThrough = $bm_mul(fThrough, $bm_sub(1, $bm_div(propSpeed, threshold)));\n        }\n    }\n    if (bounce) {\n        var prevValue = valueAtTime($bm_sub(fThroughStart, thisComp.frameDuration));\n        var startValue = valueAtTime(fThroughStart);\n        if ($bm_isInstanceOfArray(value)) {\n            for (var i = 0; i < prevValue.length; i++) {\n                if (prevValue[i] > startValue[i])\n                    fThrough[i] = Math.abs(fThrough[i]);\n                if (prevValue[i] < startValue[i])\n                    fThrough[i] = $bm_neg(Math.abs(fThrough[i]));\n            }\n        } else {\n            if (prevValue > startValue)\n                fThrough = Math.abs(fThrough);\n            if (prevValue < startValue)\n                fThrough = $bm_neg(Math.abs(fThrough));\n        }\n    }\n    if (simulate) {\n        if (!isThisPosition) {\n            fThrough = $bm_sum(fThrough, getLayerWorldPos(time, thisLayer));\n            fThrough = $bm_sub(thisLayer.fromWorld(fThrough), thisLayer.anchorPoint);\n        } else if (thisLayer.hasParent) {\n            fThrough = $bm_sum(fThrough, getLayerWorldPos(time, thisLayer.parent));\n            fThrough = $bm_sub(thisLayer.parent.fromWorld(fThrough), thisLayer.parent.anchorPoint);\n        }\n    }\n    return fThrough;\n}\nfunction followThrough() {\n    var propSpeed = length(velocity);\n    if (propSpeed < threshold)\n        return followThroughAtTime($bm_sub(time, overlapDuration));\n    var fThrough = zeroValue;\n    var t = time;\n    while (t > 0) {\n        t = $bm_sub(t, thisComp.frameDuration);\n        if (simulate)\n            propSpeed = getPropWorldSpeed($bm_sub(t, overlapDuration), thisProperty);\n        else\n            propSpeed = length(velocityAtTime(t));\n        if (propSpeed < threshold) {\n            fThrough = followThroughAtTime($bm_sub(t, overlapDuration));\n            break;\n        }\n    }\n    return linear(time, t, $bm_sum(t, $bm_mul(anticipationDuration, 2)), fThrough, zeroValue);\n}\nfunction smartSmooth(axis) {\n    var startKey = nearestKey(time);\n    var endKey = startKey;\n    if (time == startKey.time)\n        return 0;\n    if (time < startKey.time && startKey.index == 1)\n        return 0;\n    if (time > startKey.time && startKey.index == numKeys)\n        return 0;\n    if (time < startKey.time)\n        startKey = key($bm_sub(startKey.index, 1));\n    if (time > startKey.time)\n        endKey = key($bm_sum(startKey.index, 1));\n    var sI = 0.66;\n    var sO = 0.33;\n    var sIV = 1;\n    var sOV = 0;\n    var sVal = startKey.value;\n    var eVal = endKey.value;\n    if ($bm_isInstanceOfArray(value)) {\n        sVal = sVal[axis];\n        eVal = eVal[axis];\n    }\n    var sTime = startKey.time;\n    var eTime = endKey.time;\n    if (isKeyTop(startKey, axis))\n        sO = slowOut;\n    else {\n        var prevKey = key($bm_sub(startKey.index, 1));\n        var pVal = prevKey.value;\n        if ($bm_isInstanceOfArray(value))\n            pVal = pVal[axis];\n        sOV = $bm_div($bm_sub(sVal, pVal), $bm_sub(eVal, pVal));\n    }\n    if (isKeyTop(endKey, axis)) {\n        sI = slowIn;\n        if (endKey.index != numKeys) {\n            var nextKey = key($bm_sum(endKey.index, 1));\n            var nVal = nextKey.value;\n            if ($bm_isInstanceOfArray(value))\n                nVal = nVal[axis];\n            if (Math.abs(nVal - eVal) < 0.01 && doFollowThrough)\n                sI = 1;\n        }\n    } else {\n        var nextKey = key($bm_sum(endKey.index, 1));\n        var nVal = nextKey.value;\n        if ($bm_isInstanceOfArray(value))\n            nVal = nVal[axis];\n        sIV = $bm_div($bm_sub(eVal, sVal), $bm_sub(nVal, sVal));\n    }\n    if (endKey.index == numKeys && doFollowThrough) {\n        sI = 1;\n    }\n    var val = value;\n    if ($bm_isInstanceOfArray(value))\n        val = val[axis];\n    return $bm_sub(bezierInterpolation(time, sTime, eTime, sVal, eVal, [\n        sO,\n        sOV,\n        sI,\n        sIV\n    ]), val);\n}\nfunction overlap() {\n    var ol = zeroValue;\n    if (isThisPosition && !hasParent)\n        return zeroValue;\n    ol = $bm_sub(getPropWorldValue($bm_sub(time, overlapDuration), thisProperty), getPropWorldValue(time, thisProperty));\n    var motionRatio = $bm_div($bm_div(length(zeroValue, ol), thisLayer.width), 2);\n    if (isThisPosition) {\n        var originalDistance = length(valueAtTime(0));\n        motionRatio = $bm_div(length(zeroValue, ol), thisComp.width);\n    }\n    ol = $bm_sum(ol, getPropWorldValue(time, thisProperty));\n    ol = $bm_sum(ol, $bm_mul($bm_mul($bm_sub(getPropWorldValue($bm_sub(time, overlapDuration), thisLayer.anchorPoint), ol), motionRatio), flexibility));\n    ol = thisLayer.fromWorld(ol);\n    if (!isThisPosition)\n        ol = $bm_sub(ol, value);\n    else {\n        ol = linear(flexibility, 0, 100, $bm_div(ol, 2), 0);\n        var prevParentWorldPos = getLayerWorldPos($bm_sub(time, overlapDuration), parent);\n        ol = $bm_sum(ol, $bm_mul($bm_mul($bm_mul(thisLayer.fromWorld(prevParentWorldPos), motionRatio), flexibility), 5));\n    }\n    return ol;\n}\nvar okToGo = false;\nif (simulate && fx.enabled)\n    okToGo = true;\nelse if (numKeys > 1 && fx.enabled)\n    okToGo = true;\nif (okToGo) {\n    var smartSmoothResult = zeroValue;\n    if (doInterpolation) {\n        if ($bm_isInstanceOfArray(value)) {\n            if (value.length == 2)\n                smartSmoothResult = [\n                    smartSmooth(0),\n                    smartSmooth(1)\n                ];\n            else if (value.length == 3)\n                smartSmoothResult = [\n                    smartSmooth(0),\n                    smartSmooth(1),\n                    smartSmooth(2)\n                ];\n            else if (value.length == 4)\n                smartSmoothResult = [\n                    smartSmooth(0),\n                    smartSmooth(1),\n                    smartSmooth(2),\n                    smartSmooth(3)\n                ];\n        } else {\n            smartSmoothResult = smartSmooth(0);\n        }\n    }\n    if (doAnticipation)\n        result = $bm_sum(result, anticipate());\n    result = $bm_sum(result, smartSmoothResult);\n    if (doFollowThrough)\n        result = $bm_sum(result, followThrough());\n    if (doOverlap)\n        result = $bm_sum(result, overlap());\n}\n$bm_rt = result;",
                    "a": 1
                  },
                  "nm": "Transform",
                  "sk": { "a": 0, "k": 0.0 },
                  "sa": { "a": 0, "k": 0.0 }
                }
              ]
            },
            {
              "ty": "gr",
              "nm": "Group 3",
              "bm": 0,
              "mn": "ADBE Vector Group",
              "it": [
                {
                  "ty": "gr",
                  "nm": "Group 3",
                  "bm": 0,
                  "mn": "ADBE Vector Group",
                  "it": [
                    {
                      "ty": "sh",
                      "nm": "Path 1",
                      "mn": "ADBE Vector Shape - Group",
                      "ind": 0,
                      "ks": {
                        "k": {
                          "i": [
                            [0.0, -3.168],
                            [17.303, 0.0],
                            [0.0, 3.168],
                            [-17.303, 0.0]
                          ],
                          "o": [
                            [0.0, 3.168],
                            [-17.303, 0.0],
                            [0.0, -3.168],
                            [17.303, 0.0]
                          ],
                          "v": [
                            [-32.62, -29.736],
                            [-63.949, -24.001],
                            [-95.279, -29.736],
                            [-63.949, -35.472]
                          ],
                          "c": true
                        },
                        "a": 0
                      }
                    },
                    {
                      "ty": "fl",
                      "nm": "Fill 1",
                      "bm": 0,
                      "mn": "ADBE Vector Graphic - Fill",
                      "c": { "a": 0, "k": [0.0, 0.0, 0.0, 1.0] },
                      "o": { "a": 0, "k": 100.0 },
                      "r": 1
                    },
                    {
                      "ty": "tr",
                      "o": { "a": 0, "k": 100.0 },
                      "r": { "a": 0, "k": 0.0 },
                      "p": { "a": 0, "k": [0.0, 0.0] },
                      "a": { "a": 0, "k": [0.0, 0.0] },
                      "s": { "a": 0, "k": [100.0, 100.0] },
                      "nm": "Transform",
                      "sk": { "a": 0, "k": 0.0 },
                      "sa": { "a": 0, "k": 0.0 }
                    }
                  ]
                },
                {
                  "ty": "tr",
                  "o": {
                    "a": 1,
                    "k": [
                      {
                        "i": { "x": [0.667], "y": [1] },
                        "o": { "x": [0.333], "y": [0] },
                        "t": 50,
                        "s": [10.0]
                      },
                      { "t": 54, "s": [0.0] }
                    ]
                  },
                  "r": { "a": 0, "k": 0.0 },
                  "p": {
                    "a": 0,
                    "k": [-63.95, -29.736],
                    "x": "var $bm_rt;\nvar fx = effect('\u015dlosilo pli pura 4');\nvar doAnticipation = fx(1).value;\nvar doInterpolation = fx(2).value;\nvar doFollowThrough = fx(3).value;\nvar damping = $bm_div(fx(15).value, 10);\nvar elasticity = $bm_div(fx(13).value, 10);\nvar bounce = fx(17).value;\nvar anticipationDuration = fx(5).value;\nvar anticipationQuantity = $bm_div(fx(6).value, 100);\nvar slowIn = $bm_div(fx(9).value, 100);\nvar slowOut = $bm_div(fx(10).value, 100);\nvar spatialMode = fx(21).value;\nvar spatialDoInterpolation = fx(20).value;\nvar moBlurPrecision = fx(32).value;\nvar elasticityRandom = fx(14).value;\nvar dampingRandom = fx(16).value;\nvar softBody = fx(28).value;\nvar flexibility = $bm_div(fx(29).value, 100);\nvar doOverlap = fx(23).value;\nvar overlapDuration = fx(24).value;\nvar overlapRandom = fx(25).value;\nvar threshold = $bm_div($bm_div(1, moBlurPrecision), 1000);\nvar zeroValue;\nif ($bm_isInstanceOfArray(value)) {\n    if (value.length == 2)\n        zeroValue = [\n            0,\n            0\n        ];\n    else if (value.length == 3)\n        zeroValue = [\n            0,\n            0,\n            0\n        ];\n    else if (value.length == 4)\n        zeroValue = [\n            0,\n            0,\n            0,\n            0\n        ];\n} else\n    zeroValue = 0;\nvar isThisSpatial = isSpatial(thisProperty);\nvar isThisPosition = thisProperty === $bm_transform.position;\nvar simulate = false;\nif (isThisSpatial) {\n    doInterpolation = doInterpolation && spatialDoInterpolation;\n    if (isThisPosition && thisProperty.numKeys > 0) {\n        doOverlap = false;\n        simulate = false;\n    } else {\n        simulate = spatialMode == 2;\n        doOverlap = overlapDuration != 0 && doOverlap && simulate;\n    }\n} else {\n    doOverlap = false;\n}\nif (!doOverlap) {\n    overlapDuration = 0;\n}\nif (simulate && softBody && isThisSpatial && !isThisPosition && (doFollowThrough || doOverlap)) {\n    var distanceRatio = $bm_div(length(valueAtTime(0), $bm_transform.anchorPoint), $bm_div(thisLayer.width, 2));\n    distanceRatio = $bm_div($bm_sum(1, $bm_mul(distanceRatio, flexibility)), 2);\n    if (doFollowThrough) {\n        elasticity = $bm_div(elasticity, distanceRatio);\n        damping = $bm_div(damping, distanceRatio);\n    }\n    if (doOverlap) {\n        overlapDuration = $bm_mul(overlapDuration, distanceRatio);\n    }\n}\nseedRandom(0, true);\nif (doFollowThrough) {\n    if (elasticityRandom > 0)\n        elasticity = addNoise(elasticity, elasticityRandom);\n    if (dampingRandom > 0)\n        damping = addNoise(damping, dampingRandom);\n}\nif (doOverlap) {\n    if (doOverlap && overlapRandom > 0)\n        overlapDuration = addNoise(overlapDuration, overlapRandom);\n}\nvar result = value;\nfunction isSpatial(prop) {\n    if (!(prop.value instanceof Array))\n        return false;\n    if (prop.value.length != 2 && prop.value.length != 3)\n        return false;\n    try {\n        if (typeof prop.speed !== 'undefined')\n            return true;\n    } catch (e) {\n        return false;\n    }\n}\nfunction addNoise(val, quantity) {\n    var randomValue = random(0.9, 1.1);\n    var noiseValue = noise($bm_mul(valueAtTime(0), randomValue));\n    noiseValue = $bm_mul(noiseValue, $bm_div(quantity, 100));\n    return $bm_mul(val, $bm_sum(noiseValue, 1));\n}\nfunction isAfterLastKey() {\n    if (numKeys == 0)\n        return false;\n    var nKey = nearestKey(time);\n    return nKey.time <= time && nKey.index == numKeys;\n}\nfunction isStill(t, threshold) {\n    var d = $bm_sub(valueAtTime(t), valueAtTime($bm_sum(t, framesToTime(1))));\n    if ($bm_isInstanceOfArray(d)) {\n        for (var i = 0; i < d.length; i++) {\n            d[i] = Math.abs(d[i]);\n            if (d[i] >= threshold) {\n                return false;\n            }\n        }\n        return true;\n    } else {\n        d = Math.abs(d);\n        return d < threshold;\n    }\n}\nfunction bezierInterpolation(t, tMin, tMax, value1, value2, bezierPoints) {\n    if (arguments.length !== 5 && arguments.length !== 6)\n        return t;\n    var a = $bm_sub(value2, value1);\n    var b = $bm_sub(tMax, tMin);\n    if (b == 0)\n        return t;\n    var c = clamp($bm_div($bm_sub(t, tMin), b), 0, 1);\n    if (!(bezierPoints instanceof Array) || bezierPoints.length !== 4)\n        bezierPoints = [\n            0.33,\n            0,\n            0.66,\n            1\n        ];\n    return $bm_sum($bm_mul(a, h(c, bezierPoints)), value1);\n    function h(f, g) {\n        var x = $bm_mul(3, g[0]);\n        var j = $bm_sub($bm_mul(3, $bm_sub(g[2], g[0])), x);\n        var k = $bm_sub($bm_sub(1, x), j);\n        var l = $bm_mul(3, g[1]);\n        var m = $bm_sub($bm_mul(3, $bm_sub(g[3], g[1])), l);\n        var n = $bm_sub($bm_sub(1, l), m);\n        var d = f;\n        for (var i = 0; i < 5; i++) {\n            var z = $bm_sub($bm_mul(d, $bm_sum(x, $bm_mul(d, $bm_sum(j, $bm_mul(d, k))))), f);\n            if (Math.abs(z) < 0.001)\n                break;\n            d = $bm_sub(d, $bm_div(z, $bm_sum(x, $bm_mul(d, $bm_sum($bm_mul(2, j), $bm_mul($bm_mul(3, k), d))))));\n        }\n        return $bm_mul(d, $bm_sum(l, $bm_mul(d, $bm_sum(m, $bm_mul(d, n)))));\n    }\n}\nfunction getPropWorldSpeed(t, prop) {\n    return length(getPropWorldVelocity(t, prop));\n}\nfunction getPrevKey(t) {\n    if (numKeys == 0)\n        return null;\n    var nKey = nearestKey(t);\n    if (nKey.time <= t)\n        return nKey;\n    if (nKey.index > 1)\n        return key($bm_sub(nKey.index, 1));\n    return null;\n}\nfunction getNextKey(t) {\n    if (numKeys == 0)\n        return null;\n    var nKey = nearestKey(t);\n    if (nKey.time >= t)\n        return nKey;\n    if (nKey.index < numKeys)\n        return key($bm_sum(nKey.index, 1));\n    return null;\n}\nfunction getPropWorldVelocity(t, prop) {\n    return $bm_mul($bm_sub(getPropWorldValue($bm_sum(t, 0.005), prop), getPropWorldValue($bm_sub(t, 0.005), prop)), 100);\n}\nfunction getLayerWorldPos(t, l) {\n    return l.toWorld(l.anchorPoint, t);\n}\nfunction getPropWorldValue(t, prop) {\n    if (isPosition(prop))\n        return getLayerWorldPos(t, thisLayer);\n    return thisLayer.toWorld(prop.valueAtTime(t), t);\n}\nfunction isPosition(prop) {\n    return prop === $bm_transform.position;\n}\nfunction isKeyTop(k, axis) {\n    var prevSpeed = velocityAtTime($bm_sub(k.time, threshold));\n    var nextSpeed = velocityAtTime($bm_sum(k.time, threshold));\n    if ($bm_isInstanceOfArray(value)) {\n        prevSpeed = prevSpeed[axis];\n        nextSpeed = nextSpeed[axis];\n    }\n    if (Math.abs(prevSpeed) < 0.01 || Math.abs(nextSpeed) < 0.01)\n        return true;\n    return $bm_mul(prevSpeed, nextSpeed) < 0;\n}\nfunction anticipate() {\n    var anticipation = zeroValue;\n    if (isAfterLastKey())\n        return anticipation;\n    if (numKeys < 2)\n        return anticipation;\n    var nextKey = getNextKey(time);\n    var aKey = nextKey;\n    if (!isStill(aKey.time - 0.1, 0.1)) {\n        aKey = getPrevKey(time);\n        if (!isStill(aKey.time - 0.1, 0.1))\n            return anticipation;\n    }\n    if (aKey.index == numKeys)\n        return anticipation;\n    var anticipationMiddle = aKey.time;\n    var anticipationStart = $bm_sub(anticipationMiddle, anticipationDuration);\n    var anticipationEnd = key(aKey.index + 1).time;\n    var startValue = anticipation;\n    var midValue = $bm_mul($bm_sum($bm_neg(valueAtTime($bm_sum(anticipationMiddle, anticipationDuration))), aKey.value), anticipationQuantity);\n    var endValue = anticipation;\n    if (time < anticipationStart) {\n        return anticipation;\n    } else if (time < anticipationMiddle) {\n        if ($bm_isInstanceOfArray(value)) {\n            for (var i = 0; i < value.length; i++) {\n                anticipation[i] = bezierInterpolation(time, anticipationStart, anticipationMiddle, startValue[i], midValue[i], [\n                    slowOut,\n                    0,\n                    slowIn,\n                    1\n                ]);\n            }\n            return anticipation;\n        } else {\n            return bezierInterpolation(time, anticipationStart, anticipationMiddle, startValue, midValue, [\n                slowOut,\n                0,\n                slowIn,\n                1\n            ]);\n        }\n    } else if (time <= anticipationEnd) {\n        if ($bm_isInstanceOfArray(value)) {\n            for (var i = 0; i < value.length; i++) {\n                anticipation[i] = bezierInterpolation(time, anticipationMiddle, anticipationEnd, midValue[i], endValue[i], [\n                    slowOut,\n                    0,\n                    slowIn,\n                    1\n                ]);\n            }\n            return anticipation;\n        } else {\n            return bezierInterpolation(time, anticipationMiddle, anticipationEnd, midValue, endValue, [\n                slowOut,\n                0,\n                slowIn,\n                1\n            ]);\n        }\n    } else {\n        return anticipation;\n    }\n}\nfunction followThroughAtTime(t) {\n    var fThrough = zeroValue;\n    if (elasticity == 0)\n        return fThrough;\n    var propSpeed;\n    if (!simulate) {\n        if (numKeys < 2)\n            return fThrough;\n        if (nearestKey(t).index == 1)\n            return fThrough;\n        propSpeed = length(velocityAtTime(t));\n        if (propSpeed >= threshold)\n            return fThrough;\n    } else {\n        propSpeed = getPropWorldSpeed(t, thisProperty);\n        if (propSpeed >= threshold)\n            return fThrough;\n    }\n    var fThroughStart = 0;\n    var fThroughTime = 0;\n    if (simulate) {\n        var speedI = getPropWorldSpeed(t, thisProperty);\n        var i = t;\n        while (speedI < threshold && i > 0) {\n            i = $bm_sub(i, $bm_div(thisComp.frameDuration, moBlurPrecision));\n            speedI = getPropWorldSpeed(i, thisProperty);\n        }\n        fThroughStart = i;\n    } else {\n        var fThroughKey = getPrevKey(t);\n        fThroughStart = fThroughKey.time;\n    }\n    if (fThroughStart == 0)\n        return fThrough;\n    fThroughTime = $bm_sub(t, fThroughStart);\n    if (simulate)\n        fThrough = $bm_div(getPropWorldVelocity($bm_sub(fThroughStart, thisComp.frameDuration), thisProperty), 2);\n    else\n        fThrough = $bm_div(velocityAtTime($bm_sub(fThroughStart, thisComp.frameDuration)), 2);\n    if (bounce) {\n        var cycleDamp = Math.exp($bm_mul($bm_mul(fThroughTime, damping), 0.1));\n        var damp = $bm_div(Math.exp($bm_mul(fThroughTime, damping)), $bm_div(elasticity, 2));\n        var cycleDuration = $bm_div(1, $bm_mul(elasticity, 2));\n        cycleDuration = Math.round(timeToFrames(cycleDuration));\n        cycleDuration = framesToTime(cycleDuration);\n        var midDuration = $bm_div(cycleDuration, 2);\n        var maxValue = $bm_mul(fThrough, midDuration);\n        var cycvarime = fThroughTime;\n        var numEndCycles = 1;\n        while (cycvarime > cycleDuration) {\n            cycvarime = $bm_sub(cycvarime, cycleDuration);\n            cycleDuration = $bm_div(cycleDuration, cycleDamp);\n            cycleDuration = Math.round(timeToFrames(cycleDuration));\n            if (cycleDuration < 2) {\n                cycleDuration = 2;\n                numEndCycles++;\n            }\n            cycleDuration = framesToTime(cycleDuration);\n            midDuration = $bm_div(cycleDuration, 2);\n            maxValue = $bm_div($bm_mul(fThrough, midDuration), damp);\n            if (numEndCycles > 100 / damping && maxValue < threshold)\n                return zeroValue;\n        }\n        if (cycvarime < midDuration)\n            fThrough = bezierInterpolation(cycvarime, 0, midDuration, 0, maxValue, [\n                0,\n                0.1,\n                slowIn,\n                1\n            ]);\n        else\n            fThrough = bezierInterpolation(cycvarime, midDuration, cycleDuration, maxValue, 0, [\n                $bm_sub(1, slowIn),\n                0,\n                1,\n                0.9\n            ]);\n    } else {\n        var damp = Math.exp($bm_mul(fThroughTime, damping));\n        var sinus = $bm_mul($bm_mul($bm_mul(elasticity, fThroughTime), 2), Math.PI);\n        sinus = Math.sin(sinus);\n        sinus = $bm_mul($bm_div(0.3, elasticity), sinus);\n        sinus = $bm_div(sinus, damp);\n        if (Math.abs(sinus) < $bm_div(threshold, 100))\n            return 0;\n        fThrough = $bm_mul(fThrough, sinus);\n        if (threshold > 0) {\n            fThrough = $bm_mul(fThrough, $bm_sub(1, $bm_div(propSpeed, threshold)));\n        }\n    }\n    if (bounce) {\n        var prevValue = valueAtTime($bm_sub(fThroughStart, thisComp.frameDuration));\n        var startValue = valueAtTime(fThroughStart);\n        if ($bm_isInstanceOfArray(value)) {\n            for (var i = 0; i < prevValue.length; i++) {\n                if (prevValue[i] > startValue[i])\n                    fThrough[i] = Math.abs(fThrough[i]);\n                if (prevValue[i] < startValue[i])\n                    fThrough[i] = $bm_neg(Math.abs(fThrough[i]));\n            }\n        } else {\n            if (prevValue > startValue)\n                fThrough = Math.abs(fThrough);\n            if (prevValue < startValue)\n                fThrough = $bm_neg(Math.abs(fThrough));\n        }\n    }\n    if (simulate) {\n        if (!isThisPosition) {\n            fThrough = $bm_sum(fThrough, getLayerWorldPos(time, thisLayer));\n            fThrough = $bm_sub(thisLayer.fromWorld(fThrough), thisLayer.anchorPoint);\n        } else if (thisLayer.hasParent) {\n            fThrough = $bm_sum(fThrough, getLayerWorldPos(time, thisLayer.parent));\n            fThrough = $bm_sub(thisLayer.parent.fromWorld(fThrough), thisLayer.parent.anchorPoint);\n        }\n    }\n    return fThrough;\n}\nfunction followThrough() {\n    var propSpeed = length(velocity);\n    if (propSpeed < threshold)\n        return followThroughAtTime($bm_sub(time, overlapDuration));\n    var fThrough = zeroValue;\n    var t = time;\n    while (t > 0) {\n        t = $bm_sub(t, thisComp.frameDuration);\n        if (simulate)\n            propSpeed = getPropWorldSpeed($bm_sub(t, overlapDuration), thisProperty);\n        else\n            propSpeed = length(velocityAtTime(t));\n        if (propSpeed < threshold) {\n            fThrough = followThroughAtTime($bm_sub(t, overlapDuration));\n            break;\n        }\n    }\n    return linear(time, t, $bm_sum(t, $bm_mul(anticipationDuration, 2)), fThrough, zeroValue);\n}\nfunction smartSmooth(axis) {\n    var startKey = nearestKey(time);\n    var endKey = startKey;\n    if (time == startKey.time)\n        return 0;\n    if (time < startKey.time && startKey.index == 1)\n        return 0;\n    if (time > startKey.time && startKey.index == numKeys)\n        return 0;\n    if (time < startKey.time)\n        startKey = key($bm_sub(startKey.index, 1));\n    if (time > startKey.time)\n        endKey = key($bm_sum(startKey.index, 1));\n    var sI = 0.66;\n    var sO = 0.33;\n    var sIV = 1;\n    var sOV = 0;\n    var sVal = startKey.value;\n    var eVal = endKey.value;\n    if ($bm_isInstanceOfArray(value)) {\n        sVal = sVal[axis];\n        eVal = eVal[axis];\n    }\n    var sTime = startKey.time;\n    var eTime = endKey.time;\n    if (isKeyTop(startKey, axis))\n        sO = slowOut;\n    else {\n        var prevKey = key($bm_sub(startKey.index, 1));\n        var pVal = prevKey.value;\n        if ($bm_isInstanceOfArray(value))\n            pVal = pVal[axis];\n        sOV = $bm_div($bm_sub(sVal, pVal), $bm_sub(eVal, pVal));\n    }\n    if (isKeyTop(endKey, axis)) {\n        sI = slowIn;\n        if (endKey.index != numKeys) {\n            var nextKey = key($bm_sum(endKey.index, 1));\n            var nVal = nextKey.value;\n            if ($bm_isInstanceOfArray(value))\n                nVal = nVal[axis];\n            if (Math.abs(nVal - eVal) < 0.01 && doFollowThrough)\n                sI = 1;\n        }\n    } else {\n        var nextKey = key($bm_sum(endKey.index, 1));\n        var nVal = nextKey.value;\n        if ($bm_isInstanceOfArray(value))\n            nVal = nVal[axis];\n        sIV = $bm_div($bm_sub(eVal, sVal), $bm_sub(nVal, sVal));\n    }\n    if (endKey.index == numKeys && doFollowThrough) {\n        sI = 1;\n    }\n    var val = value;\n    if ($bm_isInstanceOfArray(value))\n        val = val[axis];\n    return $bm_sub(bezierInterpolation(time, sTime, eTime, sVal, eVal, [\n        sO,\n        sOV,\n        sI,\n        sIV\n    ]), val);\n}\nfunction overlap() {\n    var ol = zeroValue;\n    if (isThisPosition && !hasParent)\n        return zeroValue;\n    ol = $bm_sub(getPropWorldValue($bm_sub(time, overlapDuration), thisProperty), getPropWorldValue(time, thisProperty));\n    var motionRatio = $bm_div($bm_div(length(zeroValue, ol), thisLayer.width), 2);\n    if (isThisPosition) {\n        var originalDistance = length(valueAtTime(0));\n        motionRatio = $bm_div(length(zeroValue, ol), thisComp.width);\n    }\n    ol = $bm_sum(ol, getPropWorldValue(time, thisProperty));\n    ol = $bm_sum(ol, $bm_mul($bm_mul($bm_sub(getPropWorldValue($bm_sub(time, overlapDuration), thisLayer.anchorPoint), ol), motionRatio), flexibility));\n    ol = thisLayer.fromWorld(ol);\n    if (!isThisPosition)\n        ol = $bm_sub(ol, value);\n    else {\n        ol = linear(flexibility, 0, 100, $bm_div(ol, 2), 0);\n        var prevParentWorldPos = getLayerWorldPos($bm_sub(time, overlapDuration), parent);\n        ol = $bm_sum(ol, $bm_mul($bm_mul($bm_mul(thisLayer.fromWorld(prevParentWorldPos), motionRatio), flexibility), 5));\n    }\n    return ol;\n}\nvar okToGo = false;\nif (simulate && fx.enabled)\n    okToGo = true;\nelse if (numKeys > 1 && fx.enabled)\n    okToGo = true;\nif (okToGo) {\n    var smartSmoothResult = zeroValue;\n    if (doInterpolation) {\n        if ($bm_isInstanceOfArray(value)) {\n            if (value.length == 2)\n                smartSmoothResult = [\n                    smartSmooth(0),\n                    smartSmooth(1)\n                ];\n            else if (value.length == 3)\n                smartSmoothResult = [\n                    smartSmooth(0),\n                    smartSmooth(1),\n                    smartSmooth(2)\n                ];\n            else if (value.length == 4)\n                smartSmoothResult = [\n                    smartSmooth(0),\n                    smartSmooth(1),\n                    smartSmooth(2),\n                    smartSmooth(3)\n                ];\n        } else {\n            smartSmoothResult = smartSmooth(0);\n        }\n    }\n    if (doAnticipation)\n        result = $bm_sum(result, anticipate());\n    result = $bm_sum(result, smartSmoothResult);\n    if (doFollowThrough)\n        result = $bm_sum(result, followThrough());\n    if (doOverlap)\n        result = $bm_sum(result, overlap());\n}\n$bm_rt = result;"
                  },
                  "a": { "a": 0, "k": [-63.95, -29.736] },
                  "s": {
                    "k": [
                      {
                        "i": { "x": [0.667, 0.667], "y": [1.0, 1.0] },
                        "o": { "x": [0.333, 0.333], "y": [0.0, 0.0] },
                        "t": 37,
                        "s": [100, 100]
                      },
                      { "t": 50, "s": [160, 160] }
                    ],
                    "x": "var $bm_rt;\nvar fx = effect('\u015dlosilo pli pura 4');\nvar doAnticipation = fx(1).value;\nvar doInterpolation = fx(2).value;\nvar doFollowThrough = fx(3).value;\nvar damping = $bm_div(fx(15).value, 10);\nvar elasticity = $bm_div(fx(13).value, 10);\nvar bounce = fx(17).value;\nvar anticipationDuration = fx(5).value;\nvar anticipationQuantity = $bm_div(fx(6).value, 100);\nvar slowIn = $bm_div(fx(9).value, 100);\nvar slowOut = $bm_div(fx(10).value, 100);\nvar spatialMode = fx(21).value;\nvar spatialDoInterpolation = fx(20).value;\nvar moBlurPrecision = fx(32).value;\nvar elasticityRandom = fx(14).value;\nvar dampingRandom = fx(16).value;\nvar softBody = fx(28).value;\nvar flexibility = $bm_div(fx(29).value, 100);\nvar doOverlap = fx(23).value;\nvar overlapDuration = fx(24).value;\nvar overlapRandom = fx(25).value;\nvar threshold = $bm_div($bm_div(1, moBlurPrecision), 1000);\nvar zeroValue;\nif ($bm_isInstanceOfArray(value)) {\n    if (value.length == 2)\n        zeroValue = [\n            0,\n            0\n        ];\n    else if (value.length == 3)\n        zeroValue = [\n            0,\n            0,\n            0\n        ];\n    else if (value.length == 4)\n        zeroValue = [\n            0,\n            0,\n            0,\n            0\n        ];\n} else\n    zeroValue = 0;\nvar isThisSpatial = isSpatial(thisProperty);\nvar isThisPosition = thisProperty === $bm_transform.position;\nvar simulate = false;\nif (isThisSpatial) {\n    doInterpolation = doInterpolation && spatialDoInterpolation;\n    if (isThisPosition && thisProperty.numKeys > 0) {\n        doOverlap = false;\n        simulate = false;\n    } else {\n        simulate = spatialMode == 2;\n        doOverlap = overlapDuration != 0 && doOverlap && simulate;\n    }\n} else {\n    doOverlap = false;\n}\nif (!doOverlap) {\n    overlapDuration = 0;\n}\nif (simulate && softBody && isThisSpatial && !isThisPosition && (doFollowThrough || doOverlap)) {\n    var distanceRatio = $bm_div(length(valueAtTime(0), $bm_transform.anchorPoint), $bm_div(thisLayer.width, 2));\n    distanceRatio = $bm_div($bm_sum(1, $bm_mul(distanceRatio, flexibility)), 2);\n    if (doFollowThrough) {\n        elasticity = $bm_div(elasticity, distanceRatio);\n        damping = $bm_div(damping, distanceRatio);\n    }\n    if (doOverlap) {\n        overlapDuration = $bm_mul(overlapDuration, distanceRatio);\n    }\n}\nseedRandom(0, true);\nif (doFollowThrough) {\n    if (elasticityRandom > 0)\n        elasticity = addNoise(elasticity, elasticityRandom);\n    if (dampingRandom > 0)\n        damping = addNoise(damping, dampingRandom);\n}\nif (doOverlap) {\n    if (doOverlap && overlapRandom > 0)\n        overlapDuration = addNoise(overlapDuration, overlapRandom);\n}\nvar result = value;\nfunction isSpatial(prop) {\n    if (!(prop.value instanceof Array))\n        return false;\n    if (prop.value.length != 2 && prop.value.length != 3)\n        return false;\n    try {\n        if (typeof prop.speed !== 'undefined')\n            return true;\n    } catch (e) {\n        return false;\n    }\n}\nfunction addNoise(val, quantity) {\n    var randomValue = random(0.9, 1.1);\n    var noiseValue = noise($bm_mul(valueAtTime(0), randomValue));\n    noiseValue = $bm_mul(noiseValue, $bm_div(quantity, 100));\n    return $bm_mul(val, $bm_sum(noiseValue, 1));\n}\nfunction isAfterLastKey() {\n    if (numKeys == 0)\n        return false;\n    var nKey = nearestKey(time);\n    return nKey.time <= time && nKey.index == numKeys;\n}\nfunction isStill(t, threshold) {\n    var d = $bm_sub(valueAtTime(t), valueAtTime($bm_sum(t, framesToTime(1))));\n    if ($bm_isInstanceOfArray(d)) {\n        for (var i = 0; i < d.length; i++) {\n            d[i] = Math.abs(d[i]);\n            if (d[i] >= threshold) {\n                return false;\n            }\n        }\n        return true;\n    } else {\n        d = Math.abs(d);\n        return d < threshold;\n    }\n}\nfunction bezierInterpolation(t, tMin, tMax, value1, value2, bezierPoints) {\n    if (arguments.length !== 5 && arguments.length !== 6)\n        return t;\n    var a = $bm_sub(value2, value1);\n    var b = $bm_sub(tMax, tMin);\n    if (b == 0)\n        return t;\n    var c = clamp($bm_div($bm_sub(t, tMin), b), 0, 1);\n    if (!(bezierPoints instanceof Array) || bezierPoints.length !== 4)\n        bezierPoints = [\n            0.33,\n            0,\n            0.66,\n            1\n        ];\n    return $bm_sum($bm_mul(a, h(c, bezierPoints)), value1);\n    function h(f, g) {\n        var x = $bm_mul(3, g[0]);\n        var j = $bm_sub($bm_mul(3, $bm_sub(g[2], g[0])), x);\n        var k = $bm_sub($bm_sub(1, x), j);\n        var l = $bm_mul(3, g[1]);\n        var m = $bm_sub($bm_mul(3, $bm_sub(g[3], g[1])), l);\n        var n = $bm_sub($bm_sub(1, l), m);\n        var d = f;\n        for (var i = 0; i < 5; i++) {\n            var z = $bm_sub($bm_mul(d, $bm_sum(x, $bm_mul(d, $bm_sum(j, $bm_mul(d, k))))), f);\n            if (Math.abs(z) < 0.001)\n                break;\n            d = $bm_sub(d, $bm_div(z, $bm_sum(x, $bm_mul(d, $bm_sum($bm_mul(2, j), $bm_mul($bm_mul(3, k), d))))));\n        }\n        return $bm_mul(d, $bm_sum(l, $bm_mul(d, $bm_sum(m, $bm_mul(d, n)))));\n    }\n}\nfunction getPropWorldSpeed(t, prop) {\n    return length(getPropWorldVelocity(t, prop));\n}\nfunction getPrevKey(t) {\n    if (numKeys == 0)\n        return null;\n    var nKey = nearestKey(t);\n    if (nKey.time <= t)\n        return nKey;\n    if (nKey.index > 1)\n        return key($bm_sub(nKey.index, 1));\n    return null;\n}\nfunction getNextKey(t) {\n    if (numKeys == 0)\n        return null;\n    var nKey = nearestKey(t);\n    if (nKey.time >= t)\n        return nKey;\n    if (nKey.index < numKeys)\n        return key($bm_sum(nKey.index, 1));\n    return null;\n}\nfunction getPropWorldVelocity(t, prop) {\n    return $bm_mul($bm_sub(getPropWorldValue($bm_sum(t, 0.005), prop), getPropWorldValue($bm_sub(t, 0.005), prop)), 100);\n}\nfunction getLayerWorldPos(t, l) {\n    return l.toWorld(l.anchorPoint, t);\n}\nfunction getPropWorldValue(t, prop) {\n    if (isPosition(prop))\n        return getLayerWorldPos(t, thisLayer);\n    return thisLayer.toWorld(prop.valueAtTime(t), t);\n}\nfunction isPosition(prop) {\n    return prop === $bm_transform.position;\n}\nfunction isKeyTop(k, axis) {\n    var prevSpeed = velocityAtTime($bm_sub(k.time, threshold));\n    var nextSpeed = velocityAtTime($bm_sum(k.time, threshold));\n    if ($bm_isInstanceOfArray(value)) {\n        prevSpeed = prevSpeed[axis];\n        nextSpeed = nextSpeed[axis];\n    }\n    if (Math.abs(prevSpeed) < 0.01 || Math.abs(nextSpeed) < 0.01)\n        return true;\n    return $bm_mul(prevSpeed, nextSpeed) < 0;\n}\nfunction anticipate() {\n    var anticipation = zeroValue;\n    if (isAfterLastKey())\n        return anticipation;\n    if (numKeys < 2)\n        return anticipation;\n    var nextKey = getNextKey(time);\n    var aKey = nextKey;\n    if (!isStill(aKey.time - 0.1, 0.1)) {\n        aKey = getPrevKey(time);\n        if (!isStill(aKey.time - 0.1, 0.1))\n            return anticipation;\n    }\n    if (aKey.index == numKeys)\n        return anticipation;\n    var anticipationMiddle = aKey.time;\n    var anticipationStart = $bm_sub(anticipationMiddle, anticipationDuration);\n    var anticipationEnd = key(aKey.index + 1).time;\n    var startValue = anticipation;\n    var midValue = $bm_mul($bm_sum($bm_neg(valueAtTime($bm_sum(anticipationMiddle, anticipationDuration))), aKey.value), anticipationQuantity);\n    var endValue = anticipation;\n    if (time < anticipationStart) {\n        return anticipation;\n    } else if (time < anticipationMiddle) {\n        if ($bm_isInstanceOfArray(value)) {\n            for (var i = 0; i < value.length; i++) {\n                anticipation[i] = bezierInterpolation(time, anticipationStart, anticipationMiddle, startValue[i], midValue[i], [\n                    slowOut,\n                    0,\n                    slowIn,\n                    1\n                ]);\n            }\n            return anticipation;\n        } else {\n            return bezierInterpolation(time, anticipationStart, anticipationMiddle, startValue, midValue, [\n                slowOut,\n                0,\n                slowIn,\n                1\n            ]);\n        }\n    } else if (time <= anticipationEnd) {\n        if ($bm_isInstanceOfArray(value)) {\n            for (var i = 0; i < value.length; i++) {\n                anticipation[i] = bezierInterpolation(time, anticipationMiddle, anticipationEnd, midValue[i], endValue[i], [\n                    slowOut,\n                    0,\n                    slowIn,\n                    1\n                ]);\n            }\n            return anticipation;\n        } else {\n            return bezierInterpolation(time, anticipationMiddle, anticipationEnd, midValue, endValue, [\n                slowOut,\n                0,\n                slowIn,\n                1\n            ]);\n        }\n    } else {\n        return anticipation;\n    }\n}\nfunction followThroughAtTime(t) {\n    var fThrough = zeroValue;\n    if (elasticity == 0)\n        return fThrough;\n    var propSpeed;\n    if (!simulate) {\n        if (numKeys < 2)\n            return fThrough;\n        if (nearestKey(t).index == 1)\n            return fThrough;\n        propSpeed = length(velocityAtTime(t));\n        if (propSpeed >= threshold)\n            return fThrough;\n    } else {\n        propSpeed = getPropWorldSpeed(t, thisProperty);\n        if (propSpeed >= threshold)\n            return fThrough;\n    }\n    var fThroughStart = 0;\n    var fThroughTime = 0;\n    if (simulate) {\n        var speedI = getPropWorldSpeed(t, thisProperty);\n        var i = t;\n        while (speedI < threshold && i > 0) {\n            i = $bm_sub(i, $bm_div(thisComp.frameDuration, moBlurPrecision));\n            speedI = getPropWorldSpeed(i, thisProperty);\n        }\n        fThroughStart = i;\n    } else {\n        var fThroughKey = getPrevKey(t);\n        fThroughStart = fThroughKey.time;\n    }\n    if (fThroughStart == 0)\n        return fThrough;\n    fThroughTime = $bm_sub(t, fThroughStart);\n    if (simulate)\n        fThrough = $bm_div(getPropWorldVelocity($bm_sub(fThroughStart, thisComp.frameDuration), thisProperty), 2);\n    else\n        fThrough = $bm_div(velocityAtTime($bm_sub(fThroughStart, thisComp.frameDuration)), 2);\n    if (bounce) {\n        var cycleDamp = Math.exp($bm_mul($bm_mul(fThroughTime, damping), 0.1));\n        var damp = $bm_div(Math.exp($bm_mul(fThroughTime, damping)), $bm_div(elasticity, 2));\n        var cycleDuration = $bm_div(1, $bm_mul(elasticity, 2));\n        cycleDuration = Math.round(timeToFrames(cycleDuration));\n        cycleDuration = framesToTime(cycleDuration);\n        var midDuration = $bm_div(cycleDuration, 2);\n        var maxValue = $bm_mul(fThrough, midDuration);\n        var cycvarime = fThroughTime;\n        var numEndCycles = 1;\n        while (cycvarime > cycleDuration) {\n            cycvarime = $bm_sub(cycvarime, cycleDuration);\n            cycleDuration = $bm_div(cycleDuration, cycleDamp);\n            cycleDuration = Math.round(timeToFrames(cycleDuration));\n            if (cycleDuration < 2) {\n                cycleDuration = 2;\n                numEndCycles++;\n            }\n            cycleDuration = framesToTime(cycleDuration);\n            midDuration = $bm_div(cycleDuration, 2);\n            maxValue = $bm_div($bm_mul(fThrough, midDuration), damp);\n            if (numEndCycles > 100 / damping && maxValue < threshold)\n                return zeroValue;\n        }\n        if (cycvarime < midDuration)\n            fThrough = bezierInterpolation(cycvarime, 0, midDuration, 0, maxValue, [\n                0,\n                0.1,\n                slowIn,\n                1\n            ]);\n        else\n            fThrough = bezierInterpolation(cycvarime, midDuration, cycleDuration, maxValue, 0, [\n                $bm_sub(1, slowIn),\n                0,\n                1,\n                0.9\n            ]);\n    } else {\n        var damp = Math.exp($bm_mul(fThroughTime, damping));\n        var sinus = $bm_mul($bm_mul($bm_mul(elasticity, fThroughTime), 2), Math.PI);\n        sinus = Math.sin(sinus);\n        sinus = $bm_mul($bm_div(0.3, elasticity), sinus);\n        sinus = $bm_div(sinus, damp);\n        if (Math.abs(sinus) < $bm_div(threshold, 100))\n            return 0;\n        fThrough = $bm_mul(fThrough, sinus);\n        if (threshold > 0) {\n            fThrough = $bm_mul(fThrough, $bm_sub(1, $bm_div(propSpeed, threshold)));\n        }\n    }\n    if (bounce) {\n        var prevValue = valueAtTime($bm_sub(fThroughStart, thisComp.frameDuration));\n        var startValue = valueAtTime(fThroughStart);\n        if ($bm_isInstanceOfArray(value)) {\n            for (var i = 0; i < prevValue.length; i++) {\n                if (prevValue[i] > startValue[i])\n                    fThrough[i] = Math.abs(fThrough[i]);\n                if (prevValue[i] < startValue[i])\n                    fThrough[i] = $bm_neg(Math.abs(fThrough[i]));\n            }\n        } else {\n            if (prevValue > startValue)\n                fThrough = Math.abs(fThrough);\n            if (prevValue < startValue)\n                fThrough = $bm_neg(Math.abs(fThrough));\n        }\n    }\n    if (simulate) {\n        if (!isThisPosition) {\n            fThrough = $bm_sum(fThrough, getLayerWorldPos(time, thisLayer));\n            fThrough = $bm_sub(thisLayer.fromWorld(fThrough), thisLayer.anchorPoint);\n        } else if (thisLayer.hasParent) {\n            fThrough = $bm_sum(fThrough, getLayerWorldPos(time, thisLayer.parent));\n            fThrough = $bm_sub(thisLayer.parent.fromWorld(fThrough), thisLayer.parent.anchorPoint);\n        }\n    }\n    return fThrough;\n}\nfunction followThrough() {\n    var propSpeed = length(velocity);\n    if (propSpeed < threshold)\n        return followThroughAtTime($bm_sub(time, overlapDuration));\n    var fThrough = zeroValue;\n    var t = time;\n    while (t > 0) {\n        t = $bm_sub(t, thisComp.frameDuration);\n        if (simulate)\n            propSpeed = getPropWorldSpeed($bm_sub(t, overlapDuration), thisProperty);\n        else\n            propSpeed = length(velocityAtTime(t));\n        if (propSpeed < threshold) {\n            fThrough = followThroughAtTime($bm_sub(t, overlapDuration));\n            break;\n        }\n    }\n    return linear(time, t, $bm_sum(t, $bm_mul(anticipationDuration, 2)), fThrough, zeroValue);\n}\nfunction smartSmooth(axis) {\n    var startKey = nearestKey(time);\n    var endKey = startKey;\n    if (time == startKey.time)\n        return 0;\n    if (time < startKey.time && startKey.index == 1)\n        return 0;\n    if (time > startKey.time && startKey.index == numKeys)\n        return 0;\n    if (time < startKey.time)\n        startKey = key($bm_sub(startKey.index, 1));\n    if (time > startKey.time)\n        endKey = key($bm_sum(startKey.index, 1));\n    var sI = 0.66;\n    var sO = 0.33;\n    var sIV = 1;\n    var sOV = 0;\n    var sVal = startKey.value;\n    var eVal = endKey.value;\n    if ($bm_isInstanceOfArray(value)) {\n        sVal = sVal[axis];\n        eVal = eVal[axis];\n    }\n    var sTime = startKey.time;\n    var eTime = endKey.time;\n    if (isKeyTop(startKey, axis))\n        sO = slowOut;\n    else {\n        var prevKey = key($bm_sub(startKey.index, 1));\n        var pVal = prevKey.value;\n        if ($bm_isInstanceOfArray(value))\n            pVal = pVal[axis];\n        sOV = $bm_div($bm_sub(sVal, pVal), $bm_sub(eVal, pVal));\n    }\n    if (isKeyTop(endKey, axis)) {\n        sI = slowIn;\n        if (endKey.index != numKeys) {\n            var nextKey = key($bm_sum(endKey.index, 1));\n            var nVal = nextKey.value;\n            if ($bm_isInstanceOfArray(value))\n                nVal = nVal[axis];\n            if (Math.abs(nVal - eVal) < 0.01 && doFollowThrough)\n                sI = 1;\n        }\n    } else {\n        var nextKey = key($bm_sum(endKey.index, 1));\n        var nVal = nextKey.value;\n        if ($bm_isInstanceOfArray(value))\n            nVal = nVal[axis];\n        sIV = $bm_div($bm_sub(eVal, sVal), $bm_sub(nVal, sVal));\n    }\n    if (endKey.index == numKeys && doFollowThrough) {\n        sI = 1;\n    }\n    var val = value;\n    if ($bm_isInstanceOfArray(value))\n        val = val[axis];\n    return $bm_sub(bezierInterpolation(time, sTime, eTime, sVal, eVal, [\n        sO,\n        sOV,\n        sI,\n        sIV\n    ]), val);\n}\nfunction overlap() {\n    var ol = zeroValue;\n    if (isThisPosition && !hasParent)\n        return zeroValue;\n    ol = $bm_sub(getPropWorldValue($bm_sub(time, overlapDuration), thisProperty), getPropWorldValue(time, thisProperty));\n    var motionRatio = $bm_div($bm_div(length(zeroValue, ol), thisLayer.width), 2);\n    if (isThisPosition) {\n        var originalDistance = length(valueAtTime(0));\n        motionRatio = $bm_div(length(zeroValue, ol), thisComp.width);\n    }\n    ol = $bm_sum(ol, getPropWorldValue(time, thisProperty));\n    ol = $bm_sum(ol, $bm_mul($bm_mul($bm_sub(getPropWorldValue($bm_sub(time, overlapDuration), thisLayer.anchorPoint), ol), motionRatio), flexibility));\n    ol = thisLayer.fromWorld(ol);\n    if (!isThisPosition)\n        ol = $bm_sub(ol, value);\n    else {\n        ol = linear(flexibility, 0, 100, $bm_div(ol, 2), 0);\n        var prevParentWorldPos = getLayerWorldPos($bm_sub(time, overlapDuration), parent);\n        ol = $bm_sum(ol, $bm_mul($bm_mul($bm_mul(thisLayer.fromWorld(prevParentWorldPos), motionRatio), flexibility), 5));\n    }\n    return ol;\n}\nvar okToGo = false;\nif (simulate && fx.enabled)\n    okToGo = true;\nelse if (numKeys > 1 && fx.enabled)\n    okToGo = true;\nif (okToGo) {\n    var smartSmoothResult = zeroValue;\n    if (doInterpolation) {\n        if ($bm_isInstanceOfArray(value)) {\n            if (value.length == 2)\n                smartSmoothResult = [\n                    smartSmooth(0),\n                    smartSmooth(1)\n                ];\n            else if (value.length == 3)\n                smartSmoothResult = [\n                    smartSmooth(0),\n                    smartSmooth(1),\n                    smartSmooth(2)\n                ];\n            else if (value.length == 4)\n                smartSmoothResult = [\n                    smartSmooth(0),\n                    smartSmooth(1),\n                    smartSmooth(2),\n                    smartSmooth(3)\n                ];\n        } else {\n            smartSmoothResult = smartSmooth(0);\n        }\n    }\n    if (doAnticipation)\n        result = $bm_sum(result, anticipate());\n    result = $bm_sum(result, smartSmoothResult);\n    if (doFollowThrough)\n        result = $bm_sum(result, followThrough());\n    if (doOverlap)\n        result = $bm_sum(result, overlap());\n}\n$bm_rt = result;",
                    "a": 1
                  },
                  "nm": "Transform",
                  "sk": { "a": 0, "k": 0.0 },
                  "sa": { "a": 0, "k": 0.0 }
                }
              ]
            },
            {
              "ty": "tr",
              "o": { "a": 0, "k": 100.0 },
              "r": { "a": 0, "k": 0.0 },
              "p": { "a": 0, "k": [0.0, 0.0] },
              "a": { "a": 0, "k": [0.0, 0.0] },
              "s": { "a": 0, "k": [100.0, 100.0] },
              "nm": "Transform",
              "sk": { "a": 0, "k": 0.0 },
              "sa": { "a": 0, "k": 0.0 }
            }
          ]
        }
      ],
      "ip": 0,
      "op": 250,
      "st": 0.0,
      "ef": [
        {
          "ty": 5,
          "ix": 1,
          "nm": "\u015dlosilo pli pura",
          "mn": "Pseudo/Duik Kleaner v3.2",
          "ef": [
            {
              "ix": 1,
              "mn": "Pseudo/Duik Kleaner v3.2-0001",
              "nm": "Anticipation",
              "ty": 7,
              "v": { "a": 0, "k": 0.0 }
            },
            {
              "ix": 2,
              "mn": "Pseudo/Duik Kleaner v3.2-0002",
              "nm": "Smart Interpolation",
              "ty": 7,
              "v": { "a": 0, "k": 0.0 }
            },
            {
              "ix": 3,
              "mn": "Pseudo/Duik Kleaner v3.2-0003",
              "nm": "Follow Through",
              "ty": 7,
              "v": { "a": 0, "k": 1.0 }
            },
            {
              "ix": 4,
              "mn": "Pseudo/Duik Kleaner v3.2-0004",
              "nm": "Anticipation",
              "ty": 6,
              "v": 0
            },
            {
              "ix": 5,
              "mn": "Pseudo/Duik Kleaner v3.2-0005",
              "nm": "Duration (s)",
              "ty": 0,
              "v": { "a": 0, "k": 0.3 }
            },
            {
              "ix": 6,
              "mn": "Pseudo/Duik Kleaner v3.2-0006",
              "nm": "Amplitude",
              "ty": 0,
              "v": { "a": 0, "k": 50.0 }
            },
            { "ix": 7, "mn": "Pseudo/Duik Kleaner v3.2-0007", "nm": "", "ty": 6, "v": 0 },
            {
              "ix": 8,
              "mn": "Pseudo/Duik Kleaner v3.2-0008",
              "nm": "Interpolation",
              "ty": 6,
              "v": 0
            },
            {
              "ix": 9,
              "mn": "Pseudo/Duik Kleaner v3.2-0009",
              "nm": "Slow In",
              "ty": 0,
              "v": { "a": 0, "k": 60.0 }
            },
            {
              "ix": 10,
              "mn": "Pseudo/Duik Kleaner v3.2-0010",
              "nm": "Slow Out",
              "ty": 0,
              "v": { "a": 0, "k": 25.0 }
            },
            { "ix": 11, "mn": "Pseudo/Duik Kleaner v3.2-0011", "nm": "", "ty": 6, "v": 0 },
            {
              "ix": 12,
              "mn": "Pseudo/Duik Kleaner v3.2-0012",
              "nm": "Follow Through",
              "ty": 6,
              "v": 0
            },
            {
              "ix": 13,
              "mn": "Pseudo/Duik Kleaner v3.2-0013",
              "nm": "Elasticity",
              "ty": 0,
              "v": { "a": 0, "k": 10.0 }
            },
            {
              "ix": 14,
              "mn": "Pseudo/Duik Kleaner v3.2-0014",
              "nm": "Elasticity random",
              "ty": 0,
              "v": { "a": 0, "k": 0.0 }
            },
            {
              "ix": 15,
              "mn": "Pseudo/Duik Kleaner v3.2-0015",
              "nm": "Damping",
              "ty": 0,
              "v": { "a": 0, "k": 50.0 }
            },
            {
              "ix": 16,
              "mn": "Pseudo/Duik Kleaner v3.2-0016",
              "nm": "Damping random",
              "ty": 0,
              "v": { "a": 0, "k": 0.0 }
            },
            {
              "ix": 17,
              "mn": "Pseudo/Duik Kleaner v3.2-0017",
              "nm": "Bounce",
              "ty": 7,
              "v": { "a": 0, "k": 0.0 }
            },
            { "ix": 18, "mn": "Pseudo/Duik Kleaner v3.2-0018", "nm": "", "ty": 6, "v": 0 },
            {
              "ix": 19,
              "mn": "Pseudo/Duik Kleaner v3.2-0019",
              "nm": "Spatial Options",
              "ty": 6,
              "v": 0
            },
            {
              "ix": 20,
              "mn": "Pseudo/Duik Kleaner v3.2-0020",
              "nm": "Smart Interpolation",
              "ty": 7,
              "v": { "a": 0, "k": 0.0 }
            },
            {
              "ix": 21,
              "mn": "Pseudo/Duik Kleaner v3.2-0021",
              "nm": "Mode",
              "ty": 7,
              "v": { "a": 0, "k": 1.0 }
            },
            {
              "ix": 22,
              "mn": "Pseudo/Duik Kleaner v3.2-0022",
              "nm": "Overlap (simulation)",
              "ty": 6,
              "v": 0
            },
            {
              "ix": 23,
              "mn": "Pseudo/Duik Kleaner v3.2-0023",
              "nm": "Overlap",
              "ty": 7,
              "v": { "a": 0, "k": 1.0 }
            },
            {
              "ix": 24,
              "mn": "Pseudo/Duik Kleaner v3.2-0024",
              "nm": "Delay (s)",
              "ty": 0,
              "v": { "a": 0, "k": 0.05 }
            },
            {
              "ix": 25,
              "mn": "Pseudo/Duik Kleaner v3.2-0025",
              "nm": "Overlap random",
              "ty": 0,
              "v": { "a": 0, "k": 0.0 }
            },
            { "ix": 26, "mn": "Pseudo/Duik Kleaner v3.2-0026", "nm": "", "ty": 6, "v": 0 },
            {
              "ix": 27,
              "mn": "Pseudo/Duik Kleaner v3.2-0027",
              "nm": "Soft Body (simulation)",
              "ty": 6,
              "v": 0
            },
            {
              "ix": 28,
              "mn": "Pseudo/Duik Kleaner v3.2-0028",
              "nm": "Soft Body",
              "ty": 7,
              "v": { "a": 0, "k": 1.0 }
            },
            {
              "ix": 29,
              "mn": "Pseudo/Duik Kleaner v3.2-0029",
              "nm": "Soft-Body Flexibility",
              "ty": 0,
              "v": { "a": 0, "k": 100.0 }
            },
            { "ix": 30, "mn": "Pseudo/Duik Kleaner v3.2-0030", "nm": "", "ty": 6, "v": 0 },
            { "ix": 31, "mn": "Pseudo/Duik Kleaner v3.2-0031", "nm": "", "ty": 6, "v": 0 },
            {
              "ix": 32,
              "mn": "Pseudo/Duik Kleaner v3.2-0032",
              "nm": "Precision",
              "ty": 0,
              "v": { "a": 0, "k": 1.0 }
            }
          ],
          "en": 1
        },
        {
          "ty": 5,
          "ix": 2,
          "nm": "\u015dlosilo pli pura 2",
          "mn": "Pseudo/Duik Kleaner v3.2",
          "ef": [
            {
              "ix": 1,
              "mn": "Pseudo/Duik Kleaner v3.2-0001",
              "nm": "Anticipation",
              "ty": 7,
              "v": { "a": 0, "k": 0.0 }
            },
            {
              "ix": 2,
              "mn": "Pseudo/Duik Kleaner v3.2-0002",
              "nm": "Smart Interpolation",
              "ty": 7,
              "v": { "a": 0, "k": 0.0 }
            },
            {
              "ix": 3,
              "mn": "Pseudo/Duik Kleaner v3.2-0003",
              "nm": "Follow Through",
              "ty": 7,
              "v": { "a": 0, "k": 1.0 }
            },
            {
              "ix": 4,
              "mn": "Pseudo/Duik Kleaner v3.2-0004",
              "nm": "Anticipation",
              "ty": 6,
              "v": 0
            },
            {
              "ix": 5,
              "mn": "Pseudo/Duik Kleaner v3.2-0005",
              "nm": "Duration (s)",
              "ty": 0,
              "v": { "a": 0, "k": 0.3 }
            },
            {
              "ix": 6,
              "mn": "Pseudo/Duik Kleaner v3.2-0006",
              "nm": "Amplitude",
              "ty": 0,
              "v": { "a": 0, "k": 50.0 }
            },
            { "ix": 7, "mn": "Pseudo/Duik Kleaner v3.2-0007", "nm": "", "ty": 6, "v": 0 },
            {
              "ix": 8,
              "mn": "Pseudo/Duik Kleaner v3.2-0008",
              "nm": "Interpolation",
              "ty": 6,
              "v": 0
            },
            {
              "ix": 9,
              "mn": "Pseudo/Duik Kleaner v3.2-0009",
              "nm": "Slow In",
              "ty": 0,
              "v": { "a": 0, "k": 60.0 }
            },
            {
              "ix": 10,
              "mn": "Pseudo/Duik Kleaner v3.2-0010",
              "nm": "Slow Out",
              "ty": 0,
              "v": { "a": 0, "k": 25.0 }
            },
            { "ix": 11, "mn": "Pseudo/Duik Kleaner v3.2-0011", "nm": "", "ty": 6, "v": 0 },
            {
              "ix": 12,
              "mn": "Pseudo/Duik Kleaner v3.2-0012",
              "nm": "Follow Through",
              "ty": 6,
              "v": 0
            },
            {
              "ix": 13,
              "mn": "Pseudo/Duik Kleaner v3.2-0013",
              "nm": "Elasticity",
              "ty": 0,
              "v": { "a": 0, "k": 10.0 }
            },
            {
              "ix": 14,
              "mn": "Pseudo/Duik Kleaner v3.2-0014",
              "nm": "Elasticity random",
              "ty": 0,
              "v": { "a": 0, "k": 0.0 }
            },
            {
              "ix": 15,
              "mn": "Pseudo/Duik Kleaner v3.2-0015",
              "nm": "Damping",
              "ty": 0,
              "v": { "a": 0, "k": 50.0 }
            },
            {
              "ix": 16,
              "mn": "Pseudo/Duik Kleaner v3.2-0016",
              "nm": "Damping random",
              "ty": 0,
              "v": { "a": 0, "k": 0.0 }
            },
            {
              "ix": 17,
              "mn": "Pseudo/Duik Kleaner v3.2-0017",
              "nm": "Bounce",
              "ty": 7,
              "v": { "a": 0, "k": 0.0 }
            },
            { "ix": 18, "mn": "Pseudo/Duik Kleaner v3.2-0018", "nm": "", "ty": 6, "v": 0 },
            {
              "ix": 19,
              "mn": "Pseudo/Duik Kleaner v3.2-0019",
              "nm": "Spatial Options",
              "ty": 6,
              "v": 0
            },
            {
              "ix": 20,
              "mn": "Pseudo/Duik Kleaner v3.2-0020",
              "nm": "Smart Interpolation",
              "ty": 7,
              "v": { "a": 0, "k": 0.0 }
            },
            {
              "ix": 21,
              "mn": "Pseudo/Duik Kleaner v3.2-0021",
              "nm": "Mode",
              "ty": 7,
              "v": { "a": 0, "k": 1.0 }
            },
            {
              "ix": 22,
              "mn": "Pseudo/Duik Kleaner v3.2-0022",
              "nm": "Overlap (simulation)",
              "ty": 6,
              "v": 0
            },
            {
              "ix": 23,
              "mn": "Pseudo/Duik Kleaner v3.2-0023",
              "nm": "Overlap",
              "ty": 7,
              "v": { "a": 0, "k": 1.0 }
            },
            {
              "ix": 24,
              "mn": "Pseudo/Duik Kleaner v3.2-0024",
              "nm": "Delay (s)",
              "ty": 0,
              "v": { "a": 0, "k": 0.05 }
            },
            {
              "ix": 25,
              "mn": "Pseudo/Duik Kleaner v3.2-0025",
              "nm": "Overlap random",
              "ty": 0,
              "v": { "a": 0, "k": 0.0 }
            },
            { "ix": 26, "mn": "Pseudo/Duik Kleaner v3.2-0026", "nm": "", "ty": 6, "v": 0 },
            {
              "ix": 27,
              "mn": "Pseudo/Duik Kleaner v3.2-0027",
              "nm": "Soft Body (simulation)",
              "ty": 6,
              "v": 0
            },
            {
              "ix": 28,
              "mn": "Pseudo/Duik Kleaner v3.2-0028",
              "nm": "Soft Body",
              "ty": 7,
              "v": { "a": 0, "k": 1.0 }
            },
            {
              "ix": 29,
              "mn": "Pseudo/Duik Kleaner v3.2-0029",
              "nm": "Soft-Body Flexibility",
              "ty": 0,
              "v": { "a": 0, "k": 100.0 }
            },
            { "ix": 30, "mn": "Pseudo/Duik Kleaner v3.2-0030", "nm": "", "ty": 6, "v": 0 },
            { "ix": 31, "mn": "Pseudo/Duik Kleaner v3.2-0031", "nm": "", "ty": 6, "v": 0 },
            {
              "ix": 32,
              "mn": "Pseudo/Duik Kleaner v3.2-0032",
              "nm": "Precision",
              "ty": 0,
              "v": { "a": 0, "k": 1.0 }
            }
          ],
          "en": 1
        },
        {
          "ty": 5,
          "ix": 3,
          "nm": "\u015dlosilo pli pura 3",
          "mn": "Pseudo/Duik Kleaner v3.2",
          "ef": [
            {
              "ix": 1,
              "mn": "Pseudo/Duik Kleaner v3.2-0001",
              "nm": "Anticipation",
              "ty": 7,
              "v": { "a": 0, "k": 0.0 }
            },
            {
              "ix": 2,
              "mn": "Pseudo/Duik Kleaner v3.2-0002",
              "nm": "Smart Interpolation",
              "ty": 7,
              "v": { "a": 0, "k": 0.0 }
            },
            {
              "ix": 3,
              "mn": "Pseudo/Duik Kleaner v3.2-0003",
              "nm": "Follow Through",
              "ty": 7,
              "v": { "a": 0, "k": 1.0 }
            },
            {
              "ix": 4,
              "mn": "Pseudo/Duik Kleaner v3.2-0004",
              "nm": "Anticipation",
              "ty": 6,
              "v": 0
            },
            {
              "ix": 5,
              "mn": "Pseudo/Duik Kleaner v3.2-0005",
              "nm": "Duration (s)",
              "ty": 0,
              "v": { "a": 0, "k": 0.3 }
            },
            {
              "ix": 6,
              "mn": "Pseudo/Duik Kleaner v3.2-0006",
              "nm": "Amplitude",
              "ty": 0,
              "v": { "a": 0, "k": 50.0 }
            },
            { "ix": 7, "mn": "Pseudo/Duik Kleaner v3.2-0007", "nm": "", "ty": 6, "v": 0 },
            {
              "ix": 8,
              "mn": "Pseudo/Duik Kleaner v3.2-0008",
              "nm": "Interpolation",
              "ty": 6,
              "v": 0
            },
            {
              "ix": 9,
              "mn": "Pseudo/Duik Kleaner v3.2-0009",
              "nm": "Slow In",
              "ty": 0,
              "v": { "a": 0, "k": 60.0 }
            },
            {
              "ix": 10,
              "mn": "Pseudo/Duik Kleaner v3.2-0010",
              "nm": "Slow Out",
              "ty": 0,
              "v": { "a": 0, "k": 25.0 }
            },
            { "ix": 11, "mn": "Pseudo/Duik Kleaner v3.2-0011", "nm": "", "ty": 6, "v": 0 },
            {
              "ix": 12,
              "mn": "Pseudo/Duik Kleaner v3.2-0012",
              "nm": "Follow Through",
              "ty": 6,
              "v": 0
            },
            {
              "ix": 13,
              "mn": "Pseudo/Duik Kleaner v3.2-0013",
              "nm": "Elasticity",
              "ty": 0,
              "v": { "a": 0, "k": 10.0 }
            },
            {
              "ix": 14,
              "mn": "Pseudo/Duik Kleaner v3.2-0014",
              "nm": "Elasticity random",
              "ty": 0,
              "v": { "a": 0, "k": 0.0 }
            },
            {
              "ix": 15,
              "mn": "Pseudo/Duik Kleaner v3.2-0015",
              "nm": "Damping",
              "ty": 0,
              "v": { "a": 0, "k": 50.0 }
            },
            {
              "ix": 16,
              "mn": "Pseudo/Duik Kleaner v3.2-0016",
              "nm": "Damping random",
              "ty": 0,
              "v": { "a": 0, "k": 0.0 }
            },
            {
              "ix": 17,
              "mn": "Pseudo/Duik Kleaner v3.2-0017",
              "nm": "Bounce",
              "ty": 7,
              "v": { "a": 0, "k": 0.0 }
            },
            { "ix": 18, "mn": "Pseudo/Duik Kleaner v3.2-0018", "nm": "", "ty": 6, "v": 0 },
            {
              "ix": 19,
              "mn": "Pseudo/Duik Kleaner v3.2-0019",
              "nm": "Spatial Options",
              "ty": 6,
              "v": 0
            },
            {
              "ix": 20,
              "mn": "Pseudo/Duik Kleaner v3.2-0020",
              "nm": "Smart Interpolation",
              "ty": 7,
              "v": { "a": 0, "k": 0.0 }
            },
            {
              "ix": 21,
              "mn": "Pseudo/Duik Kleaner v3.2-0021",
              "nm": "Mode",
              "ty": 7,
              "v": { "a": 0, "k": 1.0 }
            },
            {
              "ix": 22,
              "mn": "Pseudo/Duik Kleaner v3.2-0022",
              "nm": "Overlap (simulation)",
              "ty": 6,
              "v": 0
            },
            {
              "ix": 23,
              "mn": "Pseudo/Duik Kleaner v3.2-0023",
              "nm": "Overlap",
              "ty": 7,
              "v": { "a": 0, "k": 1.0 }
            },
            {
              "ix": 24,
              "mn": "Pseudo/Duik Kleaner v3.2-0024",
              "nm": "Delay (s)",
              "ty": 0,
              "v": { "a": 0, "k": 0.05 }
            },
            {
              "ix": 25,
              "mn": "Pseudo/Duik Kleaner v3.2-0025",
              "nm": "Overlap random",
              "ty": 0,
              "v": { "a": 0, "k": 0.0 }
            },
            { "ix": 26, "mn": "Pseudo/Duik Kleaner v3.2-0026", "nm": "", "ty": 6, "v": 0 },
            {
              "ix": 27,
              "mn": "Pseudo/Duik Kleaner v3.2-0027",
              "nm": "Soft Body (simulation)",
              "ty": 6,
              "v": 0
            },
            {
              "ix": 28,
              "mn": "Pseudo/Duik Kleaner v3.2-0028",
              "nm": "Soft Body",
              "ty": 7,
              "v": { "a": 0, "k": 1.0 }
            },
            {
              "ix": 29,
              "mn": "Pseudo/Duik Kleaner v3.2-0029",
              "nm": "Soft-Body Flexibility",
              "ty": 0,
              "v": { "a": 0, "k": 100.0 }
            },
            { "ix": 30, "mn": "Pseudo/Duik Kleaner v3.2-0030", "nm": "", "ty": 6, "v": 0 },
            { "ix": 31, "mn": "Pseudo/Duik Kleaner v3.2-0031", "nm": "", "ty": 6, "v": 0 },
            {
              "ix": 32,
              "mn": "Pseudo/Duik Kleaner v3.2-0032",
              "nm": "Precision",
              "ty": 0,
              "v": { "a": 0, "k": 1.0 }
            }
          ],
          "en": 1
        },
        {
          "ty": 5,
          "ix": 4,
          "nm": "\u015dlosilo pli pura 4",
          "mn": "Pseudo/Duik Kleaner v3.2",
          "ef": [
            {
              "ix": 1,
              "mn": "Pseudo/Duik Kleaner v3.2-0001",
              "nm": "Anticipation",
              "ty": 7,
              "v": { "a": 0, "k": 0.0 }
            },
            {
              "ix": 2,
              "mn": "Pseudo/Duik Kleaner v3.2-0002",
              "nm": "Smart Interpolation",
              "ty": 7,
              "v": { "a": 0, "k": 0.0 }
            },
            {
              "ix": 3,
              "mn": "Pseudo/Duik Kleaner v3.2-0003",
              "nm": "Follow Through",
              "ty": 7,
              "v": { "a": 0, "k": 1.0 }
            },
            {
              "ix": 4,
              "mn": "Pseudo/Duik Kleaner v3.2-0004",
              "nm": "Anticipation",
              "ty": 6,
              "v": 0
            },
            {
              "ix": 5,
              "mn": "Pseudo/Duik Kleaner v3.2-0005",
              "nm": "Duration (s)",
              "ty": 0,
              "v": { "a": 0, "k": 0.3 }
            },
            {
              "ix": 6,
              "mn": "Pseudo/Duik Kleaner v3.2-0006",
              "nm": "Amplitude",
              "ty": 0,
              "v": { "a": 0, "k": 50.0 }
            },
            { "ix": 7, "mn": "Pseudo/Duik Kleaner v3.2-0007", "nm": "", "ty": 6, "v": 0 },
            {
              "ix": 8,
              "mn": "Pseudo/Duik Kleaner v3.2-0008",
              "nm": "Interpolation",
              "ty": 6,
              "v": 0
            },
            {
              "ix": 9,
              "mn": "Pseudo/Duik Kleaner v3.2-0009",
              "nm": "Slow In",
              "ty": 0,
              "v": { "a": 0, "k": 60.0 }
            },
            {
              "ix": 10,
              "mn": "Pseudo/Duik Kleaner v3.2-0010",
              "nm": "Slow Out",
              "ty": 0,
              "v": { "a": 0, "k": 25.0 }
            },
            { "ix": 11, "mn": "Pseudo/Duik Kleaner v3.2-0011", "nm": "", "ty": 6, "v": 0 },
            {
              "ix": 12,
              "mn": "Pseudo/Duik Kleaner v3.2-0012",
              "nm": "Follow Through",
              "ty": 6,
              "v": 0
            },
            {
              "ix": 13,
              "mn": "Pseudo/Duik Kleaner v3.2-0013",
              "nm": "Elasticity",
              "ty": 0,
              "v": { "a": 0, "k": 10.0 }
            },
            {
              "ix": 14,
              "mn": "Pseudo/Duik Kleaner v3.2-0014",
              "nm": "Elasticity random",
              "ty": 0,
              "v": { "a": 0, "k": 0.0 }
            },
            {
              "ix": 15,
              "mn": "Pseudo/Duik Kleaner v3.2-0015",
              "nm": "Damping",
              "ty": 0,
              "v": { "a": 0, "k": 50.0 }
            },
            {
              "ix": 16,
              "mn": "Pseudo/Duik Kleaner v3.2-0016",
              "nm": "Damping random",
              "ty": 0,
              "v": { "a": 0, "k": 0.0 }
            },
            {
              "ix": 17,
              "mn": "Pseudo/Duik Kleaner v3.2-0017",
              "nm": "Bounce",
              "ty": 7,
              "v": { "a": 0, "k": 0.0 }
            },
            { "ix": 18, "mn": "Pseudo/Duik Kleaner v3.2-0018", "nm": "", "ty": 6, "v": 0 },
            {
              "ix": 19,
              "mn": "Pseudo/Duik Kleaner v3.2-0019",
              "nm": "Spatial Options",
              "ty": 6,
              "v": 0
            },
            {
              "ix": 20,
              "mn": "Pseudo/Duik Kleaner v3.2-0020",
              "nm": "Smart Interpolation",
              "ty": 7,
              "v": { "a": 0, "k": 0.0 }
            },
            {
              "ix": 21,
              "mn": "Pseudo/Duik Kleaner v3.2-0021",
              "nm": "Mode",
              "ty": 7,
              "v": { "a": 0, "k": 1.0 }
            },
            {
              "ix": 22,
              "mn": "Pseudo/Duik Kleaner v3.2-0022",
              "nm": "Overlap (simulation)",
              "ty": 6,
              "v": 0
            },
            {
              "ix": 23,
              "mn": "Pseudo/Duik Kleaner v3.2-0023",
              "nm": "Overlap",
              "ty": 7,
              "v": { "a": 0, "k": 1.0 }
            },
            {
              "ix": 24,
              "mn": "Pseudo/Duik Kleaner v3.2-0024",
              "nm": "Delay (s)",
              "ty": 0,
              "v": { "a": 0, "k": 0.05 }
            },
            {
              "ix": 25,
              "mn": "Pseudo/Duik Kleaner v3.2-0025",
              "nm": "Overlap random",
              "ty": 0,
              "v": { "a": 0, "k": 0.0 }
            },
            { "ix": 26, "mn": "Pseudo/Duik Kleaner v3.2-0026", "nm": "", "ty": 6, "v": 0 },
            {
              "ix": 27,
              "mn": "Pseudo/Duik Kleaner v3.2-0027",
              "nm": "Soft Body (simulation)",
              "ty": 6,
              "v": 0
            },
            {
              "ix": 28,
              "mn": "Pseudo/Duik Kleaner v3.2-0028",
              "nm": "Soft Body",
              "ty": 7,
              "v": { "a": 0, "k": 1.0 }
            },
            {
              "ix": 29,
              "mn": "Pseudo/Duik Kleaner v3.2-0029",
              "nm": "Soft-Body Flexibility",
              "ty": 0,
              "v": { "a": 0, "k": 100.0 }
            },
            { "ix": 30, "mn": "Pseudo/Duik Kleaner v3.2-0030", "nm": "", "ty": 6, "v": 0 },
            { "ix": 31, "mn": "Pseudo/Duik Kleaner v3.2-0031", "nm": "", "ty": 6, "v": 0 },
            {
              "ix": 32,
              "mn": "Pseudo/Duik Kleaner v3.2-0032",
              "nm": "Precision",
              "ty": 0,
              "v": { "a": 0, "k": 1.0 }
            }
          ],
          "en": 1
        }
      ]
    },
    {
      "ind": 2,
      "ty": 4,
      "nm": "Layer 2",
      "sr": 1.0,
      "ks": {
        "o": { "a": 0, "k": 100.0 },
        "r": { "a": 0, "k": 0.0 },
        "p": { "a": 0, "k": [256.001, 290.095, 0.0], "l": 2 },
        "a": { "a": 0, "k": [0.001, 34.095, 0.0], "l": 2 },
        "s": { "a": 0, "k": [100.0, 100.0, 100.0], "l": 2 }
      },
      "shapes": [
        {
          "ty": "gr",
          "nm": "Group 8",
          "bm": 0,
          "mn": "ADBE Vector Group",
          "it": [
            {
              "ty": "gr",
              "nm": "Group 2",
              "bm": 0,
              "mn": "ADBE Vector Group",
              "it": [
                {
                  "ty": "gr",
                  "nm": "Group 1",
                  "bm": 0,
                  "mn": "ADBE Vector Group",
                  "it": [
                    {
                      "ty": "gr",
                      "nm": "Group 1",
                      "bm": 0,
                      "mn": "ADBE Vector Group",
                      "it": [
                        {
                          "ty": "sh",
                          "nm": "Path 1",
                          "mn": "ADBE Vector Shape - Group",
                          "ind": 0,
                          "ks": {
                            "k": {
                              "i": [
                                [0.824, -0.232],
                                [-0.232, -0.824],
                                [-0.824, 0.232],
                                [0.232, 0.824]
                              ],
                              "o": [
                                [-0.824, 0.232],
                                [0.232, 0.824],
                                [0.824, -0.232],
                                [-0.232, -0.824]
                              ],
                              "v": [
                                [63.302, -25.795],
                                [62.231, -23.883],
                                [64.143, -22.811],
                                [65.214, -24.723]
                              ],
                              "c": true
                            },
                            "a": 0
                          }
                        },
                        {
                          "ty": "fl",
                          "nm": "Fill 1",
                          "bm": 0,
                          "mn": "ADBE Vector Graphic - Fill",
                          "c": { "a": 0, "k": [0.0, 0.0, 0.0, 1.0] },
                          "o": { "a": 0, "k": 100.0 },
                          "r": 1
                        },
                        {
                          "ty": "tr",
                          "o": { "a": 0, "k": 100.0 },
                          "r": { "a": 0, "k": 0.0 },
                          "p": { "a": 0, "k": [0.0, 0.0] },
                          "a": { "a": 0, "k": [0.0, 0.0] },
                          "s": { "a": 0, "k": [100.0, 100.0] },
                          "nm": "Transform",
                          "sk": { "a": 0, "k": 0.0 },
                          "sa": { "a": 0, "k": 0.0 }
                        }
                      ]
                    },
                    {
                      "ty": "gr",
                      "nm": "Group 2",
                      "bm": 0,
                      "mn": "ADBE Vector Group",
                      "it": [
                        {
                          "ty": "sh",
                          "nm": "Path 1",
                          "mn": "ADBE Vector Shape - Group",
                          "ind": 0,
                          "ks": {
                            "k": {
                              "i": [
                                [0.232, 0.824],
                                [0.824, -0.232],
                                [-0.232, -0.824],
                                [-0.824, 0.232]
                              ],
                              "o": [
                                [-0.232, -0.824],
                                [-0.824, 0.232],
                                [0.232, 0.824],
                                [0.824, -0.232]
                              ],
                              "v": [
                                [84.709, -20.822],
                                [82.797, -21.893],
                                [81.726, -19.981],
                                [83.638, -18.91]
                              ],
                              "c": true
                            },
                            "a": 0
                          }
                        },
                        {
                          "ty": "fl",
                          "nm": "Fill 1",
                          "bm": 0,
                          "mn": "ADBE Vector Graphic - Fill",
                          "c": { "a": 0, "k": [0.0, 0.0, 0.0, 1.0] },
                          "o": { "a": 0, "k": 100.0 },
                          "r": 1
                        },
                        {
                          "ty": "tr",
                          "o": { "a": 0, "k": 100.0 },
                          "r": { "a": 0, "k": 0.0 },
                          "p": { "a": 0, "k": [0.0, 0.0] },
                          "a": { "a": 0, "k": [0.0, 0.0] },
                          "s": { "a": 0, "k": [100.0, 100.0] },
                          "nm": "Transform",
                          "sk": { "a": 0, "k": 0.0 },
                          "sa": { "a": 0, "k": 0.0 }
                        }
                      ]
                    },
                    {
                      "ty": "tr",
                      "o": { "a": 0, "k": 100.0 },
                      "r": { "a": 0, "k": 0.0 },
                      "p": {
                        "k": [
                          {
                            "i": { "x": 0.667, "y": 1.0 },
                            "o": { "x": 0.333, "y": 0.0 },
                            "t": 28,
                            "s": [73.65, -20.734],
                            "ti": [0.452, 0.283],
                            "to": [-0.452, -0.283]
                          },
                          {
                            "i": { "x": 0.667, "y": 0.667 },
                            "o": { "x": 0.333, "y": 0.333 },
                            "t": 37,
                            "s": [70.936, -22.432],
                            "ti": [0, 0],
                            "to": [0, 0]
                          },
                          {
                            "i": { "x": 0.667, "y": 1.0 },
                            "o": { "x": 0.333, "y": 0.0 },
                            "t": 89,
                            "s": [70.936, -22.432],
                            "ti": [-0.452, -0.283],
                            "to": [0.452, 0.283]
                          },
                          { "t": 96, "s": [73.65, -20.734] }
                        ],
                        "a": 1
                      },
                      "a": { "a": 0, "k": [73.65, -20.734] },
                      "s": { "a": 0, "k": [100.0, 100.0] },
                      "nm": "Transform",
                      "sk": { "a": 0, "k": 0.0 },
                      "sa": { "a": 0, "k": 0.0 }
                    }
                  ]
                },
                {
                  "ty": "gr",
                  "nm": "Group 2",
                  "bm": 0,
                  "mn": "ADBE Vector Group",
                  "it": [
                    {
                      "ty": "gr",
                      "nm": "Group 1",
                      "bm": 0,
                      "mn": "ADBE Vector Group",
                      "it": [
                        {
                          "ty": "sh",
                          "nm": "Path 1",
                          "mn": "ADBE Vector Shape - Group",
                          "ind": 0,
                          "ks": {
                            "k": {
                              "i": [
                                [0.0, 0.0],
                                [-0.008, 0.104]
                              ],
                              "o": [
                                [0.008, -0.104],
                                [0.0, 0.0]
                              ],
                              "v": [
                                [97.468, -55.038],
                                [97.491, -55.349]
                              ],
                              "c": false
                            },
                            "a": 0
                          }
                        },
                        {
                          "ty": "st",
                          "nm": "Stroke 1",
                          "bm": 0,
                          "mn": "ADBE Vector Graphic - Stroke",
                          "lc": 2,
                          "lj": 2,
                          "o": { "a": 0, "k": 100.0 },
                          "w": { "a": 0, "k": 0.684 },
                          "c": { "a": 0, "k": [0.0, 0.0, 0.0, 1.0] }
                        },
                        {
                          "ty": "tr",
                          "o": { "a": 0, "k": 100.0 },
                          "r": { "a": 0, "k": 0.0 },
                          "p": { "a": 0, "k": [0.0, 0.0] },
                          "a": { "a": 0, "k": [0.0, 0.0] },
                          "s": { "a": 0, "k": [100.0, 100.0] },
                          "nm": "Transform",
                          "sk": { "a": 0, "k": 0.0 },
                          "sa": { "a": 0, "k": 0.0 }
                        }
                      ]
                    },
                    {
                      "ty": "gr",
                      "nm": "Group 2",
                      "bm": 0,
                      "mn": "ADBE Vector Group",
                      "it": [
                        {
                          "ty": "sh",
                          "nm": "Path 1",
                          "mn": "ADBE Vector Shape - Group",
                          "ind": 0,
                          "ks": {
                            "k": {
                              "i": [
                                [0.0, 0.0],
                                [-0.519, -0.296],
                                [0.112, -0.587],
                                [0.453, -0.408],
                                [0.154, -0.59],
                                [-0.61, -0.007]
                              ],
                              "o": [
                                [0.448, -0.394],
                                [0.519, 0.296],
                                [-0.114, 0.599],
                                [-0.453, 0.408],
                                [-0.154, 0.59],
                                [0.0, 0.0]
                              ],
                              "v": [
                                [115.818, -15.522],
                                [117.489, -15.692],
                                [118.191, -14.167],
                                [117.153, -12.703],
                                [116.062, -11.269],
                                [116.882, -9.911]
                              ],
                              "c": false
                            },
                            "a": 0
                          }
                        },
                        {
                          "ty": "st",
                          "nm": "Stroke 1",
                          "bm": 0,
                          "mn": "ADBE Vector Graphic - Stroke",
                          "lc": 2,
                          "lj": 2,
                          "o": { "a": 0, "k": 100.0 },
                          "w": { "a": 0, "k": 0.684 },
                          "c": {
                            "a": 0,
                            "k": [0.101960785687, 0.086274512112, 0.082352943718, 1.0]
                          }
                        },
                        {
                          "ty": "tr",
                          "o": { "a": 0, "k": 100.0 },
                          "r": { "a": 0, "k": 0.0 },
                          "p": { "a": 0, "k": [0.0, 0.0] },
                          "a": { "a": 0, "k": [0.0, 0.0] },
                          "s": { "a": 0, "k": [100.0, 100.0] },
                          "nm": "Transform",
                          "sk": { "a": 0, "k": 0.0 },
                          "sa": { "a": 0, "k": 0.0 }
                        }
                      ]
                    },
                    {
                      "ty": "gr",
                      "nm": "Group 3",
                      "bm": 0,
                      "mn": "ADBE Vector Group",
                      "it": [
                        {
                          "ty": "sh",
                          "nm": "Path 1",
                          "mn": "ADBE Vector Shape - Group",
                          "ind": 0,
                          "ks": {
                            "k": {
                              "i": [
                                [-1.053, -0.039],
                                [-0.044, 0.003],
                                [-0.298, 0.722],
                                [0.839, 7.182],
                                [4.051, 5.168],
                                [5.656, 1.932],
                                [7.734, -3.884],
                                [4.052, -6.971],
                                [-0.445, -0.19],
                                [-6.474, -0.61],
                                [-5.407, 2.032],
                                [-0.963, 3.28],
                                [-1.2, -1.886],
                                [-1.322, -1.135],
                                [-1.302, 0.034],
                                [0.122, 0.509],
                                [-0.223, 0.984],
                                [0.223, 1.582],
                                [-0.723, -1.697],
                                [-0.585, -2.409],
                                [0.849, -3.969]
                              ],
                              "o": [
                                [0.042, 0.002],
                                [0.779, -0.058],
                                [2.758, -6.688],
                                [-0.746, -6.389],
                                [-3.682, -4.697],
                                [-8.1, -2.767],
                                [-7.396, 3.714],
                                [-0.243, 0.418],
                                [6.01, 2.562],
                                [5.621, 0.53],
                                [-1.229, -3.111],
                                [-0.682, 2.323],
                                [0.935, 1.47],
                                [0.954, 0.819],
                                [0.02, -0.516],
                                [-0.239, -0.994],
                                [0.351, -1.548],
                                [0.24, 1.703],
                                [0.973, 2.282],
                                [0.98, 4.037],
                                [-0.231, 1.082]
                              ],
                              "v": [
                                [108.158, -8.475],
                                [108.288, -8.478],
                                [109.825, -10.079],
                                [112.73, -31.347],
                                [107.047, -48.376],
                                [92.683, -58.666],
                                [64.954, -57.675],
                                [52.179, -39.719],
                                [52.557, -38.575],
                                [71.33, -32.665],
                                [90.77, -32.397],
                                [88.987, -43.81],
                                [91.817, -35.151],
                                [95.225, -31.212],
                                [99.346, -28.734],
                                [98.962, -30.214],
                                [99.195, -33.001],
                                [99.516, -37.581],
                                [102.748, -31.648],
                                [105.042, -24.58],
                                [106.909, -11.103]
                              ],
                              "c": true
                            },
                            "a": 0
                          }
                        },
                        {
                          "ty": "fl",
                          "nm": "Fill 1",
                          "bm": 0,
                          "mn": "ADBE Vector Graphic - Fill",
                          "c": { "a": 0, "k": [0.0, 0.0, 0.0, 1.0] },
                          "o": { "a": 0, "k": 100.0 },
                          "r": 1
                        },
                        {
                          "ty": "tr",
                          "o": { "a": 0, "k": 100.0 },
                          "r": { "a": 0, "k": 0.0 },
                          "p": { "a": 0, "k": [0.0, 0.0] },
                          "a": { "a": 0, "k": [0.0, 0.0] },
                          "s": { "a": 0, "k": [100.0, 100.0] },
                          "nm": "Transform",
                          "sk": { "a": 0, "k": 0.0 },
                          "sa": { "a": 0, "k": 0.0 }
                        }
                      ]
                    },
                    {
                      "ty": "gr",
                      "nm": "Group 4",
                      "bm": 0,
                      "mn": "ADBE Vector Group",
                      "it": [
                        {
                          "ty": "sh",
                          "nm": "Path 1",
                          "mn": "ADBE Vector Shape - Group",
                          "ind": 0,
                          "ks": {
                            "k": {
                              "i": [
                                [0.0, 0.0],
                                [-2.127, 0.875],
                                [0.331, 2.276]
                              ],
                              "o": [
                                [1.367, 1.85],
                                [2.127, -0.875],
                                [0.0, 0.0]
                              ],
                              "v": [
                                [71.11, -5.473],
                                [77.281, -3.751],
                                [80.453, -9.316]
                              ],
                              "c": false
                            },
                            "a": 0
                          }
                        },
                        {
                          "ty": "tm",
                          "nm": "Trim Paths 1",
                          "mn": "ADBE Vector Filter - Trim",
                          "s": {
                            "a": 1,
                            "k": [
                              {
                                "i": { "x": [0.667], "y": [1] },
                                "o": { "x": [0.333], "y": [0] },
                                "t": 44,
                                "s": [0.0]
                              },
                              {
                                "i": { "x": [0.667], "y": [1] },
                                "o": { "x": [0.333], "y": [0] },
                                "t": 51.826,
                                "s": [40.0]
                              },
                              {
                                "i": { "x": [0.667], "y": [1] },
                                "o": { "x": [0.333], "y": [0] },
                                "t": 59,
                                "s": [0.0]
                              },
                              {
                                "i": { "x": [0.667], "y": [1] },
                                "o": { "x": [0.333], "y": [0] },
                                "t": 66.826,
                                "s": [40.0]
                              },
                              {
                                "i": { "x": [0.667], "y": [1] },
                                "o": { "x": [0.333], "y": [0] },
                                "t": 74,
                                "s": [0.0]
                              },
                              {
                                "i": { "x": [0.667], "y": [1] },
                                "o": { "x": [0.333], "y": [0] },
                                "t": 81.826,
                                "s": [40.0]
                              },
                              {
                                "i": { "x": [0.667], "y": [1] },
                                "o": { "x": [0.333], "y": [0] },
                                "t": 89,
                                "s": [0.0]
                              },
                              {
                                "i": { "x": [0.667], "y": [1] },
                                "o": { "x": [0.333], "y": [0] },
                                "t": 96.826,
                                "s": [40.0]
                              },
                              { "t": 104, "s": [0.0] }
                            ]
                          },
                          "e": {
                            "a": 1,
                            "k": [
                              {
                                "i": { "x": [0.667], "y": [1] },
                                "o": { "x": [0.333], "y": [0] },
                                "t": 44,
                                "s": [100.0]
                              },
                              {
                                "i": { "x": [0.667], "y": [1] },
                                "o": { "x": [0.333], "y": [0] },
                                "t": 51.826,
                                "s": [60.0]
                              },
                              {
                                "i": { "x": [0.667], "y": [1] },
                                "o": { "x": [0.333], "y": [0] },
                                "t": 59,
                                "s": [100.0]
                              },
                              {
                                "i": { "x": [0.667], "y": [1] },
                                "o": { "x": [0.333], "y": [0] },
                                "t": 66.826,
                                "s": [60.0]
                              },
                              {
                                "i": { "x": [0.667], "y": [1] },
                                "o": { "x": [0.333], "y": [0] },
                                "t": 74,
                                "s": [100.0]
                              },
                              {
                                "i": { "x": [0.667], "y": [1] },
                                "o": { "x": [0.333], "y": [0] },
                                "t": 81.826,
                                "s": [60.0]
                              },
                              {
                                "i": { "x": [0.667], "y": [1] },
                                "o": { "x": [0.333], "y": [0] },
                                "t": 89,
                                "s": [100.0]
                              },
                              {
                                "i": { "x": [0.667], "y": [1] },
                                "o": { "x": [0.333], "y": [0] },
                                "t": 96.826,
                                "s": [60.0]
                              },
                              { "t": 104, "s": [100.0] }
                            ]
                          },
                          "o": { "a": 0, "k": 0.0 },
                          "m": 1
                        },
                        {
                          "ty": "st",
                          "nm": "Stroke 1",
                          "bm": 0,
                          "mn": "ADBE Vector Graphic - Stroke",
                          "lc": 2,
                          "lj": 2,
                          "o": { "a": 0, "k": 100.0 },
                          "w": { "a": 0, "k": 0.684 },
                          "c": {
                            "a": 0,
                            "k": [0.101960785687, 0.086274512112, 0.082352943718, 1.0]
                          }
                        },
                        {
                          "ty": "tr",
                          "o": { "a": 0, "k": 100.0 },
                          "r": { "a": 0, "k": 0.0 },
                          "p": { "a": 0, "k": [75.509, -6.086] },
                          "a": { "a": 0, "k": [75.509, -6.086] },
                          "s": { "a": 0, "k": [100.0, 100.0] },
                          "nm": "Transform",
                          "sk": { "a": 0, "k": 0.0 },
                          "sa": { "a": 0, "k": 0.0 }
                        }
                      ]
                    },
                    {
                      "ty": "gr",
                      "nm": "Group 5",
                      "bm": 0,
                      "mn": "ADBE Vector Group",
                      "it": [
                        {
                          "ty": "sh",
                          "nm": "Path 1",
                          "mn": "ADBE Vector Shape - Group",
                          "ind": 0,
                          "ks": {
                            "k": {
                              "i": [
                                [0.0, 0.0],
                                [0.102, -0.894],
                                [-0.757, -0.487]
                              ],
                              "o": [
                                [-0.847, 0.304],
                                [-0.102, 0.894],
                                [0.0, 0.0]
                              ],
                              "v": [
                                [65.367, -15.999],
                                [63.776, -13.99],
                                [64.875, -11.674]
                              ],
                              "c": false
                            },
                            "a": 0
                          }
                        },
                        {
                          "ty": "st",
                          "nm": "Stroke 1",
                          "bm": 0,
                          "mn": "ADBE Vector Graphic - Stroke",
                          "lc": 2,
                          "lj": 2,
                          "o": { "a": 0, "k": 100.0 },
                          "w": { "a": 0, "k": 0.684 },
                          "c": {
                            "a": 0,
                            "k": [0.101960785687, 0.086274512112, 0.082352943718, 1.0]
                          }
                        },
                        {
                          "ty": "tr",
                          "o": { "a": 0, "k": 100.0 },
                          "r": { "a": 0, "k": 0.0 },
                          "p": { "a": 0, "k": [0.0, 0.0] },
                          "a": { "a": 0, "k": [0.0, 0.0] },
                          "s": { "a": 0, "k": [100.0, 100.0] },
                          "nm": "Transform",
                          "sk": { "a": 0, "k": 0.0 },
                          "sa": { "a": 0, "k": 0.0 }
                        }
                      ]
                    },
                    {
                      "ty": "gr",
                      "nm": "Group 9",
                      "bm": 0,
                      "mn": "ADBE Vector Group",
                      "it": [
                        {
                          "ty": "gr",
                          "nm": "Group 6",
                          "bm": 0,
                          "mn": "ADBE Vector Group",
                          "it": [
                            {
                              "ty": "sh",
                              "nm": "Path 1",
                              "mn": "ADBE Vector Shape - Group",
                              "ind": 0,
                              "ks": {
                                "k": {
                                  "i": [
                                    [0.738, -1.153],
                                    [2.883, 1.846],
                                    [-0.738, 1.153],
                                    [-2.883, -1.846]
                                  ],
                                  "o": [
                                    [-0.738, 1.153],
                                    [-2.883, -1.846],
                                    [0.738, -1.153],
                                    [2.883, 1.846]
                                  ],
                                  "v": [
                                    [91.123, -21.506],
                                    [84.566, -22.76],
                                    [80.682, -28.191],
                                    [87.24, -26.937]
                                  ],
                                  "c": true
                                },
                                "a": 0
                              }
                            },
                            {
                              "ty": "fl",
                              "nm": "Fill 1",
                              "bm": 0,
                              "mn": "ADBE Vector Graphic - Fill",
                              "c": { "a": 0, "k": [0.0, 0.0, 0.0, 1.0] },
                              "o": { "a": 0, "k": 100.0 },
                              "r": 1
                            },
                            {
                              "ty": "tr",
                              "o": { "a": 0, "k": 100.0 },
                              "r": { "a": 0, "k": 0.0 },
                              "p": { "a": 0, "k": [0.0, 0.0] },
                              "a": { "a": 0, "k": [0.0, 0.0] },
                              "s": { "a": 0, "k": [100.0, 100.0] },
                              "nm": "Transform",
                              "sk": { "a": 0, "k": 0.0 },
                              "sa": { "a": 0, "k": 0.0 }
                            }
                          ]
                        },
                        {
                          "ty": "gr",
                          "nm": "Group 7",
                          "bm": 0,
                          "mn": "ADBE Vector Group",
                          "it": [
                            {
                              "ty": "sh",
                              "nm": "Path 1",
                              "mn": "ADBE Vector Shape - Group",
                              "ind": 0,
                              "ks": {
                                "k": {
                                  "i": [
                                    [0.16, -1.433],
                                    [2.975, 0.333],
                                    [-0.16, 1.433],
                                    [-2.975, -0.333]
                                  ],
                                  "o": [
                                    [-0.16, 1.433],
                                    [-2.975, -0.332],
                                    [0.16, -1.433],
                                    [2.975, 0.333]
                                  ],
                                  "v": [
                                    [69.484, -28.63],
                                    [63.807, -26.637],
                                    [58.71, -29.834],
                                    [64.387, -31.826]
                                  ],
                                  "c": true
                                },
                                "a": 0
                              }
                            },
                            {
                              "ty": "fl",
                              "nm": "Fill 1",
                              "bm": 0,
                              "mn": "ADBE Vector Graphic - Fill",
                              "c": { "a": 0, "k": [0.0, 0.0, 0.0, 1.0] },
                              "o": { "a": 0, "k": 100.0 },
                              "r": 1
                            },
                            {
                              "ty": "tr",
                              "o": { "a": 0, "k": 100.0 },
                              "r": { "a": 0, "k": 0.0 },
                              "p": { "a": 0, "k": [0.0, 0.0] },
                              "a": { "a": 0, "k": [0.0, 0.0] },
                              "s": { "a": 0, "k": [100.0, 100.0] },
                              "nm": "Transform",
                              "sk": { "a": 0, "k": 0.0 },
                              "sa": { "a": 0, "k": 0.0 }
                            }
                          ]
                        },
                        {
                          "ty": "tr",
                          "o": { "a": 0, "k": 100.0 },
                          "r": { "a": 0, "k": 0.0 },
                          "p": {
                            "k": [
                              {
                                "i": { "x": 0.667, "y": 1.0 },
                                "o": { "x": 0.333, "y": 0.0 },
                                "t": 28,
                                "s": [74.997, -26.401],
                                "ti": [-0.076, 0.428],
                                "to": [0.076, -0.428]
                              },
                              {
                                "i": { "x": 0.667, "y": 0.667 },
                                "o": { "x": 0.333, "y": 0.333 },
                                "t": 37,
                                "s": [75.454, -28.971],
                                "ti": [0, 0],
                                "to": [0, 0]
                              },
                              {
                                "i": { "x": 0.667, "y": 1.0 },
                                "o": { "x": 0.333, "y": 0.0 },
                                "t": 89,
                                "s": [75.454, -28.971],
                                "ti": [0.076, -0.428],
                                "to": [-0.076, 0.428]
                              },
                              { "t": 96, "s": [74.997, -26.401] }
                            ],
                            "a": 1
                          },
                          "a": { "a": 0, "k": [74.997, -26.401] },
                          "s": { "a": 0, "k": [100.0, 100.0] },
                          "nm": "Transform",
                          "sk": { "a": 0, "k": 0.0 },
                          "sa": { "a": 0, "k": 0.0 }
                        }
                      ]
                    },
                    {
                      "ty": "gr",
                      "nm": "Group 8",
                      "bm": 0,
                      "mn": "ADBE Vector Group",
                      "it": [
                        {
                          "ty": "sh",
                          "nm": "Path 1",
                          "mn": "ADBE Vector Shape - Group",
                          "ind": 0,
                          "ks": {
                            "k": {
                              "i": [
                                [0.0, 0.0],
                                [-1.796, -4.177],
                                [-1.887, -2.187],
                                [3.767, -4.9],
                                [2.813, -0.407],
                                [1.607, 2.345],
                                [4.432, -3.793],
                                [5.036, -1.251],
                                [5.781, 3.057],
                                [-6.648, 15.187],
                                [-2.67, 4.025]
                              ],
                              "o": [
                                [3.026, 3.119],
                                [2.456, -1.751],
                                [4.3, 4.98],
                                [-1.733, 2.254],
                                [-2.813, 0.407],
                                [-1.471, 4.872],
                                [-3.929, 3.362],
                                [-6.347, 1.576],
                                [-18.731, -9.907],
                                [1.937, -4.424],
                                [0.0, 0.0]
                              ],
                              "v": [
                                [106.244, -35.77],
                                [112.888, -24.151],
                                [121.631, -22.195],
                                [120.981, -4.656],
                                [113.926, -0.249],
                                [106.422, -3.281],
                                [98.471, 9.585],
                                [84.648, 16.427],
                                [65.561, 14.488],
                                [60.553, -38.642],
                                [67.475, -51.351]
                              ],
                              "c": false
                            },
                            "a": 0
                          }
                        },
                        {
                          "ty": "st",
                          "nm": "Stroke 1",
                          "bm": 0,
                          "mn": "ADBE Vector Graphic - Stroke",
                          "lc": 2,
                          "lj": 2,
                          "o": { "a": 0, "k": 100.0 },
                          "w": { "a": 0, "k": 0.684 },
                          "c": { "a": 0, "k": [0.0, 0.0, 0.0, 1.0] }
                        },
                        {
                          "ty": "fl",
                          "nm": "Fill 1",
                          "bm": 0,
                          "mn": "ADBE Vector Graphic - Fill",
                          "c": { "a": 0, "k": [1.0, 1.0, 1.0, 1.0] },
                          "o": { "a": 0, "k": 100.0 },
                          "r": 1
                        },
                        {
                          "ty": "tr",
                          "o": { "a": 0, "k": 100.0 },
                          "r": { "a": 0, "k": 0.0 },
                          "p": { "a": 0, "k": [0.0, 0.0] },
                          "a": { "a": 0, "k": [0.0, 0.0] },
                          "s": { "a": 0, "k": [100.0, 100.0] },
                          "nm": "Transform",
                          "sk": { "a": 0, "k": 0.0 },
                          "sa": { "a": 0, "k": 0.0 }
                        }
                      ]
                    },
                    {
                      "ty": "tr",
                      "o": { "a": 0, "k": 100.0 },
                      "r": { "a": 0, "k": 0.0 },
                      "p": { "a": 0, "k": [0.0, 0.0] },
                      "a": { "a": 0, "k": [0.0, 0.0] },
                      "s": { "a": 0, "k": [100.0, 100.0] },
                      "nm": "Transform",
                      "sk": { "a": 0, "k": 0.0 },
                      "sa": { "a": 0, "k": 0.0 }
                    }
                  ]
                },
                {
                  "ty": "tr",
                  "o": { "a": 0, "k": 100.0 },
                  "r": { "a": 0, "k": 0.0 },
                  "p": { "a": 0, "k": [0.0, 0.0] },
                  "a": { "a": 0, "k": [0.0, 0.0] },
                  "s": { "a": 0, "k": [100.0, 100.0] },
                  "nm": "Transform",
                  "sk": { "a": 0, "k": 0.0 },
                  "sa": { "a": 0, "k": 0.0 }
                }
              ]
            },
            {
              "ty": "gr",
              "nm": "Group 6",
              "bm": 0,
              "mn": "ADBE Vector Group",
              "it": [
                {
                  "ty": "gr",
                  "nm": "Group 1",
                  "bm": 0,
                  "mn": "ADBE Vector Group",
                  "it": [
                    {
                      "ty": "sh",
                      "nm": "Path 1",
                      "mn": "ADBE Vector Shape - Group",
                      "ind": 0,
                      "ks": {
                        "k": {
                          "i": [
                            [0.0, 0.0],
                            [-8.177, 7.479],
                            [-11.082, -0.011],
                            [-3.626, -10.472],
                            [1.201, -6.821],
                            [-1.086, -6.84],
                            [-6.724, -1.662]
                          ],
                          "o": [
                            [6.097, -9.253],
                            [8.177, -7.479],
                            [11.082, 0.011],
                            [2.266, 6.545],
                            [-1.201, 6.821],
                            [1.086, 6.84],
                            [0.0, 0.0]
                          ],
                          "v": [
                            [86.266, -58.084],
                            [106.725, -84.174],
                            [136.495, -97.167],
                            [162.613, -80.169],
                            [162.804, -59.625],
                            [161.182, -39.016],
                            [173.375, -23.669]
                          ],
                          "c": false
                        },
                        "a": 0
                      }
                    },
                    {
                      "ty": "st",
                      "nm": "Stroke 1",
                      "bm": 0,
                      "mn": "ADBE Vector Graphic - Stroke",
                      "lc": 2,
                      "lj": 2,
                      "o": { "a": 0, "k": 100.0 },
                      "w": { "a": 0, "k": 0.684 },
                      "c": { "a": 0, "k": [0.101960785687, 0.086274512112, 0.082352943718, 1.0] }
                    },
                    {
                      "ty": "tr",
                      "o": { "a": 0, "k": 100.0 },
                      "r": { "a": 0, "k": 0.0 },
                      "p": { "a": 0, "k": [0.0, 0.0] },
                      "a": { "a": 0, "k": [0.0, 0.0] },
                      "s": { "a": 0, "k": [100.0, 100.0] },
                      "nm": "Transform",
                      "sk": { "a": 0, "k": 0.0 },
                      "sa": { "a": 0, "k": 0.0 }
                    }
                  ]
                },
                {
                  "ty": "gr",
                  "nm": "Group 2",
                  "bm": 0,
                  "mn": "ADBE Vector Group",
                  "it": [
                    {
                      "ty": "sh",
                      "nm": "Path 1",
                      "mn": "ADBE Vector Shape - Group",
                      "ind": 0,
                      "ks": {
                        "k": {
                          "i": [
                            [0.0, 0.0],
                            [-6.415, 6.396],
                            [-9.005, 0.982],
                            [-5.373, -7.293],
                            [0.042, -7.586],
                            [-0.993, -7.521],
                            [-1.68, -5.217],
                            [-4.797, 1.271],
                            [7.805, 1.628],
                            [3.674, 7.885],
                            [8.127, 6.205],
                            [4.906, -0.156],
                            [2.781, -4.045]
                          ],
                          "o": [
                            [4.189, -8.031],
                            [6.415, -6.396],
                            [9.005, -0.982],
                            [4.5, 6.107],
                            [-0.042, 7.586],
                            [0.729, 5.524],
                            [1.581, 4.908],
                            [-4.589, 6.52],
                            [-9.332, -1.947],
                            [-4.095, -8.789],
                            [-3.901, -2.979],
                            [-4.906, 0.156],
                            [0.0, 0.0]
                          ],
                          "v": [
                            [87.735, -57.929],
                            [103.085, -80.222],
                            [126.765, -92.469],
                            [150.846, -82.788],
                            [156.368, -61.119],
                            [156.324, -38.388],
                            [160.854, -22.285],
                            [173.534, -15.885],
                            [152.519, -7.591],
                            [135.457, -24.83],
                            [120.921, -48.884],
                            [107.266, -53.583],
                            [94.669, -47.046]
                          ],
                          "c": false
                        },
                        "a": 0
                      }
                    },
                    {
                      "ty": "fl",
                      "nm": "Fill 1",
                      "bm": 0,
                      "mn": "ADBE Vector Graphic - Fill",
                      "c": { "a": 0, "k": [0.0, 0.0, 0.0, 1.0] },
                      "o": { "a": 0, "k": 100.0 },
                      "r": 1
                    },
                    {
                      "ty": "tr",
                      "o": { "a": 0, "k": 100.0 },
                      "r": { "a": 0, "k": 0.0 },
                      "p": { "a": 0, "k": [0.0, 0.0] },
                      "a": { "a": 0, "k": [0.0, 0.0] },
                      "s": { "a": 0, "k": [100.0, 100.0] },
                      "nm": "Transform",
                      "sk": { "a": 0, "k": 0.0 },
                      "sa": { "a": 0, "k": 0.0 }
                    }
                  ]
                },
                {
                  "ty": "tr",
                  "o": { "a": 0, "k": 100.0 },
                  "r": {
                    "a": 1,
                    "k": [
                      {
                        "i": { "x": [0.667], "y": [1] },
                        "o": { "x": [0.333], "y": [0] },
                        "t": 25,
                        "s": [0.0]
                      },
                      {
                        "i": { "x": [0.667], "y": [1] },
                        "o": { "x": [0.333], "y": [0] },
                        "t": 31,
                        "s": [-17.0]
                      },
                      {
                        "i": { "x": [0.667], "y": [1] },
                        "o": { "x": [0.333], "y": [0] },
                        "t": 37,
                        "s": [0.0]
                      },
                      {
                        "i": { "x": [0.667], "y": [1] },
                        "o": { "x": [0.333], "y": [0] },
                        "t": 95,
                        "s": [0.0]
                      },
                      {
                        "i": { "x": [0.667], "y": [1] },
                        "o": { "x": [0.333], "y": [0] },
                        "t": 101,
                        "s": [-17.0]
                      },
                      { "t": 107, "s": [0.0] }
                    ],
                    "x": "var $bm_rt;\nvar fx = effect('\u015dlosilo pli pura 6');\nvar doAnticipation = fx(1).value;\nvar doInterpolation = fx(2).value;\nvar doFollowThrough = fx(3).value;\nvar damping = $bm_div(fx(15).value, 10);\nvar elasticity = $bm_div(fx(13).value, 10);\nvar bounce = fx(17).value;\nvar anticipationDuration = fx(5).value;\nvar anticipationQuantity = $bm_div(fx(6).value, 100);\nvar slowIn = $bm_div(fx(9).value, 100);\nvar slowOut = $bm_div(fx(10).value, 100);\nvar spatialMode = fx(21).value;\nvar spatialDoInterpolation = fx(20).value;\nvar moBlurPrecision = fx(32).value;\nvar elasticityRandom = fx(14).value;\nvar dampingRandom = fx(16).value;\nvar softBody = fx(28).value;\nvar flexibility = $bm_div(fx(29).value, 100);\nvar doOverlap = fx(23).value;\nvar overlapDuration = fx(24).value;\nvar overlapRandom = fx(25).value;\nvar threshold = $bm_div($bm_div(1, moBlurPrecision), 1000);\nvar zeroValue;\nif ($bm_isInstanceOfArray(value)) {\n    if (value.length == 2)\n        zeroValue = [\n            0,\n            0\n        ];\n    else if (value.length == 3)\n        zeroValue = [\n            0,\n            0,\n            0\n        ];\n    else if (value.length == 4)\n        zeroValue = [\n            0,\n            0,\n            0,\n            0\n        ];\n} else\n    zeroValue = 0;\nvar isThisSpatial = isSpatial(thisProperty);\nvar isThisPosition = thisProperty === $bm_transform.position;\nvar simulate = false;\nif (isThisSpatial) {\n    doInterpolation = doInterpolation && spatialDoInterpolation;\n    if (isThisPosition && thisProperty.numKeys > 0) {\n        doOverlap = false;\n        simulate = false;\n    } else {\n        simulate = spatialMode == 2;\n        doOverlap = overlapDuration != 0 && doOverlap && simulate;\n    }\n} else {\n    doOverlap = false;\n}\nif (!doOverlap) {\n    overlapDuration = 0;\n}\nif (simulate && softBody && isThisSpatial && !isThisPosition && (doFollowThrough || doOverlap)) {\n    var distanceRatio = $bm_div(length(valueAtTime(0), $bm_transform.anchorPoint), $bm_div(thisLayer.width, 2));\n    distanceRatio = $bm_div($bm_sum(1, $bm_mul(distanceRatio, flexibility)), 2);\n    if (doFollowThrough) {\n        elasticity = $bm_div(elasticity, distanceRatio);\n        damping = $bm_div(damping, distanceRatio);\n    }\n    if (doOverlap) {\n        overlapDuration = $bm_mul(overlapDuration, distanceRatio);\n    }\n}\nseedRandom(0, true);\nif (doFollowThrough) {\n    if (elasticityRandom > 0)\n        elasticity = addNoise(elasticity, elasticityRandom);\n    if (dampingRandom > 0)\n        damping = addNoise(damping, dampingRandom);\n}\nif (doOverlap) {\n    if (doOverlap && overlapRandom > 0)\n        overlapDuration = addNoise(overlapDuration, overlapRandom);\n}\nvar result = value;\nfunction isSpatial(prop) {\n    if (!(prop.value instanceof Array))\n        return false;\n    if (prop.value.length != 2 && prop.value.length != 3)\n        return false;\n    try {\n        if (typeof prop.speed !== 'undefined')\n            return true;\n    } catch (e) {\n        return false;\n    }\n}\nfunction addNoise(val, quantity) {\n    var randomValue = random(0.9, 1.1);\n    var noiseValue = noise($bm_mul(valueAtTime(0), randomValue));\n    noiseValue = $bm_mul(noiseValue, $bm_div(quantity, 100));\n    return $bm_mul(val, $bm_sum(noiseValue, 1));\n}\nfunction isAfterLastKey() {\n    if (numKeys == 0)\n        return false;\n    var nKey = nearestKey(time);\n    return nKey.time <= time && nKey.index == numKeys;\n}\nfunction isStill(t, threshold) {\n    var d = $bm_sub(valueAtTime(t), valueAtTime($bm_sum(t, framesToTime(1))));\n    if ($bm_isInstanceOfArray(d)) {\n        for (var i = 0; i < d.length; i++) {\n            d[i] = Math.abs(d[i]);\n            if (d[i] >= threshold) {\n                return false;\n            }\n        }\n        return true;\n    } else {\n        d = Math.abs(d);\n        return d < threshold;\n    }\n}\nfunction bezierInterpolation(t, tMin, tMax, value1, value2, bezierPoints) {\n    if (arguments.length !== 5 && arguments.length !== 6)\n        return t;\n    var a = $bm_sub(value2, value1);\n    var b = $bm_sub(tMax, tMin);\n    if (b == 0)\n        return t;\n    var c = clamp($bm_div($bm_sub(t, tMin), b), 0, 1);\n    if (!(bezierPoints instanceof Array) || bezierPoints.length !== 4)\n        bezierPoints = [\n            0.33,\n            0,\n            0.66,\n            1\n        ];\n    return $bm_sum($bm_mul(a, h(c, bezierPoints)), value1);\n    function h(f, g) {\n        var x = $bm_mul(3, g[0]);\n        var j = $bm_sub($bm_mul(3, $bm_sub(g[2], g[0])), x);\n        var k = $bm_sub($bm_sub(1, x), j);\n        var l = $bm_mul(3, g[1]);\n        var m = $bm_sub($bm_mul(3, $bm_sub(g[3], g[1])), l);\n        var n = $bm_sub($bm_sub(1, l), m);\n        var d = f;\n        for (var i = 0; i < 5; i++) {\n            var z = $bm_sub($bm_mul(d, $bm_sum(x, $bm_mul(d, $bm_sum(j, $bm_mul(d, k))))), f);\n            if (Math.abs(z) < 0.001)\n                break;\n            d = $bm_sub(d, $bm_div(z, $bm_sum(x, $bm_mul(d, $bm_sum($bm_mul(2, j), $bm_mul($bm_mul(3, k), d))))));\n        }\n        return $bm_mul(d, $bm_sum(l, $bm_mul(d, $bm_sum(m, $bm_mul(d, n)))));\n    }\n}\nfunction getPropWorldSpeed(t, prop) {\n    return length(getPropWorldVelocity(t, prop));\n}\nfunction getPrevKey(t) {\n    if (numKeys == 0)\n        return null;\n    var nKey = nearestKey(t);\n    if (nKey.time <= t)\n        return nKey;\n    if (nKey.index > 1)\n        return key($bm_sub(nKey.index, 1));\n    return null;\n}\nfunction getNextKey(t) {\n    if (numKeys == 0)\n        return null;\n    var nKey = nearestKey(t);\n    if (nKey.time >= t)\n        return nKey;\n    if (nKey.index < numKeys)\n        return key($bm_sum(nKey.index, 1));\n    return null;\n}\nfunction getPropWorldVelocity(t, prop) {\n    return $bm_mul($bm_sub(getPropWorldValue($bm_sum(t, 0.005), prop), getPropWorldValue($bm_sub(t, 0.005), prop)), 100);\n}\nfunction getLayerWorldPos(t, l) {\n    return l.toWorld(l.anchorPoint, t);\n}\nfunction getPropWorldValue(t, prop) {\n    if (isPosition(prop))\n        return getLayerWorldPos(t, thisLayer);\n    return thisLayer.toWorld(prop.valueAtTime(t), t);\n}\nfunction isPosition(prop) {\n    return prop === $bm_transform.position;\n}\nfunction isKeyTop(k, axis) {\n    var prevSpeed = velocityAtTime($bm_sub(k.time, threshold));\n    var nextSpeed = velocityAtTime($bm_sum(k.time, threshold));\n    if ($bm_isInstanceOfArray(value)) {\n        prevSpeed = prevSpeed[axis];\n        nextSpeed = nextSpeed[axis];\n    }\n    if (Math.abs(prevSpeed) < 0.01 || Math.abs(nextSpeed) < 0.01)\n        return true;\n    return $bm_mul(prevSpeed, nextSpeed) < 0;\n}\nfunction anticipate() {\n    var anticipation = zeroValue;\n    if (isAfterLastKey())\n        return anticipation;\n    if (numKeys < 2)\n        return anticipation;\n    var nextKey = getNextKey(time);\n    var aKey = nextKey;\n    if (!isStill(aKey.time - 0.1, 0.1)) {\n        aKey = getPrevKey(time);\n        if (!isStill(aKey.time - 0.1, 0.1))\n            return anticipation;\n    }\n    if (aKey.index == numKeys)\n        return anticipation;\n    var anticipationMiddle = aKey.time;\n    var anticipationStart = $bm_sub(anticipationMiddle, anticipationDuration);\n    var anticipationEnd = key(aKey.index + 1).time;\n    var startValue = anticipation;\n    var midValue = $bm_mul($bm_sum($bm_neg(valueAtTime($bm_sum(anticipationMiddle, anticipationDuration))), aKey.value), anticipationQuantity);\n    var endValue = anticipation;\n    if (time < anticipationStart) {\n        return anticipation;\n    } else if (time < anticipationMiddle) {\n        if ($bm_isInstanceOfArray(value)) {\n            for (var i = 0; i < value.length; i++) {\n                anticipation[i] = bezierInterpolation(time, anticipationStart, anticipationMiddle, startValue[i], midValue[i], [\n                    slowOut,\n                    0,\n                    slowIn,\n                    1\n                ]);\n            }\n            return anticipation;\n        } else {\n            return bezierInterpolation(time, anticipationStart, anticipationMiddle, startValue, midValue, [\n                slowOut,\n                0,\n                slowIn,\n                1\n            ]);\n        }\n    } else if (time <= anticipationEnd) {\n        if ($bm_isInstanceOfArray(value)) {\n            for (var i = 0; i < value.length; i++) {\n                anticipation[i] = bezierInterpolation(time, anticipationMiddle, anticipationEnd, midValue[i], endValue[i], [\n                    slowOut,\n                    0,\n                    slowIn,\n                    1\n                ]);\n            }\n            return anticipation;\n        } else {\n            return bezierInterpolation(time, anticipationMiddle, anticipationEnd, midValue, endValue, [\n                slowOut,\n                0,\n                slowIn,\n                1\n            ]);\n        }\n    } else {\n        return anticipation;\n    }\n}\nfunction followThroughAtTime(t) {\n    var fThrough = zeroValue;\n    if (elasticity == 0)\n        return fThrough;\n    var propSpeed;\n    if (!simulate) {\n        if (numKeys < 2)\n            return fThrough;\n        if (nearestKey(t).index == 1)\n            return fThrough;\n        propSpeed = length(velocityAtTime(t));\n        if (propSpeed >= threshold)\n            return fThrough;\n    } else {\n        propSpeed = getPropWorldSpeed(t, thisProperty);\n        if (propSpeed >= threshold)\n            return fThrough;\n    }\n    var fThroughStart = 0;\n    var fThroughTime = 0;\n    if (simulate) {\n        var speedI = getPropWorldSpeed(t, thisProperty);\n        var i = t;\n        while (speedI < threshold && i > 0) {\n            i = $bm_sub(i, $bm_div(thisComp.frameDuration, moBlurPrecision));\n            speedI = getPropWorldSpeed(i, thisProperty);\n        }\n        fThroughStart = i;\n    } else {\n        var fThroughKey = getPrevKey(t);\n        fThroughStart = fThroughKey.time;\n    }\n    if (fThroughStart == 0)\n        return fThrough;\n    fThroughTime = $bm_sub(t, fThroughStart);\n    if (simulate)\n        fThrough = $bm_div(getPropWorldVelocity($bm_sub(fThroughStart, thisComp.frameDuration), thisProperty), 2);\n    else\n        fThrough = $bm_div(velocityAtTime($bm_sub(fThroughStart, thisComp.frameDuration)), 2);\n    if (bounce) {\n        var cycleDamp = Math.exp($bm_mul($bm_mul(fThroughTime, damping), 0.1));\n        var damp = $bm_div(Math.exp($bm_mul(fThroughTime, damping)), $bm_div(elasticity, 2));\n        var cycleDuration = $bm_div(1, $bm_mul(elasticity, 2));\n        cycleDuration = Math.round(timeToFrames(cycleDuration));\n        cycleDuration = framesToTime(cycleDuration);\n        var midDuration = $bm_div(cycleDuration, 2);\n        var maxValue = $bm_mul(fThrough, midDuration);\n        var cycvarime = fThroughTime;\n        var numEndCycles = 1;\n        while (cycvarime > cycleDuration) {\n            cycvarime = $bm_sub(cycvarime, cycleDuration);\n            cycleDuration = $bm_div(cycleDuration, cycleDamp);\n            cycleDuration = Math.round(timeToFrames(cycleDuration));\n            if (cycleDuration < 2) {\n                cycleDuration = 2;\n                numEndCycles++;\n            }\n            cycleDuration = framesToTime(cycleDuration);\n            midDuration = $bm_div(cycleDuration, 2);\n            maxValue = $bm_div($bm_mul(fThrough, midDuration), damp);\n            if (numEndCycles > 100 / damping && maxValue < threshold)\n                return zeroValue;\n        }\n        if (cycvarime < midDuration)\n            fThrough = bezierInterpolation(cycvarime, 0, midDuration, 0, maxValue, [\n                0,\n                0.1,\n                slowIn,\n                1\n            ]);\n        else\n            fThrough = bezierInterpolation(cycvarime, midDuration, cycleDuration, maxValue, 0, [\n                $bm_sub(1, slowIn),\n                0,\n                1,\n                0.9\n            ]);\n    } else {\n        var damp = Math.exp($bm_mul(fThroughTime, damping));\n        var sinus = $bm_mul($bm_mul($bm_mul(elasticity, fThroughTime), 2), Math.PI);\n        sinus = Math.sin(sinus);\n        sinus = $bm_mul($bm_div(0.3, elasticity), sinus);\n        sinus = $bm_div(sinus, damp);\n        if (Math.abs(sinus) < $bm_div(threshold, 100))\n            return 0;\n        fThrough = $bm_mul(fThrough, sinus);\n        if (threshold > 0) {\n            fThrough = $bm_mul(fThrough, $bm_sub(1, $bm_div(propSpeed, threshold)));\n        }\n    }\n    if (bounce) {\n        var prevValue = valueAtTime($bm_sub(fThroughStart, thisComp.frameDuration));\n        var startValue = valueAtTime(fThroughStart);\n        if ($bm_isInstanceOfArray(value)) {\n            for (var i = 0; i < prevValue.length; i++) {\n                if (prevValue[i] > startValue[i])\n                    fThrough[i] = Math.abs(fThrough[i]);\n                if (prevValue[i] < startValue[i])\n                    fThrough[i] = $bm_neg(Math.abs(fThrough[i]));\n            }\n        } else {\n            if (prevValue > startValue)\n                fThrough = Math.abs(fThrough);\n            if (prevValue < startValue)\n                fThrough = $bm_neg(Math.abs(fThrough));\n        }\n    }\n    if (simulate) {\n        if (!isThisPosition) {\n            fThrough = $bm_sum(fThrough, getLayerWorldPos(time, thisLayer));\n            fThrough = $bm_sub(thisLayer.fromWorld(fThrough), thisLayer.anchorPoint);\n        } else if (thisLayer.hasParent) {\n            fThrough = $bm_sum(fThrough, getLayerWorldPos(time, thisLayer.parent));\n            fThrough = $bm_sub(thisLayer.parent.fromWorld(fThrough), thisLayer.parent.anchorPoint);\n        }\n    }\n    return fThrough;\n}\nfunction followThrough() {\n    var propSpeed = length(velocity);\n    if (propSpeed < threshold)\n        return followThroughAtTime($bm_sub(time, overlapDuration));\n    var fThrough = zeroValue;\n    var t = time;\n    while (t > 0) {\n        t = $bm_sub(t, thisComp.frameDuration);\n        if (simulate)\n            propSpeed = getPropWorldSpeed($bm_sub(t, overlapDuration), thisProperty);\n        else\n            propSpeed = length(velocityAtTime(t));\n        if (propSpeed < threshold) {\n            fThrough = followThroughAtTime($bm_sub(t, overlapDuration));\n            break;\n        }\n    }\n    return linear(time, t, $bm_sum(t, $bm_mul(anticipationDuration, 2)), fThrough, zeroValue);\n}\nfunction smartSmooth(axis) {\n    var startKey = nearestKey(time);\n    var endKey = startKey;\n    if (time == startKey.time)\n        return 0;\n    if (time < startKey.time && startKey.index == 1)\n        return 0;\n    if (time > startKey.time && startKey.index == numKeys)\n        return 0;\n    if (time < startKey.time)\n        startKey = key($bm_sub(startKey.index, 1));\n    if (time > startKey.time)\n        endKey = key($bm_sum(startKey.index, 1));\n    var sI = 0.66;\n    var sO = 0.33;\n    var sIV = 1;\n    var sOV = 0;\n    var sVal = startKey.value;\n    var eVal = endKey.value;\n    if ($bm_isInstanceOfArray(value)) {\n        sVal = sVal[axis];\n        eVal = eVal[axis];\n    }\n    var sTime = startKey.time;\n    var eTime = endKey.time;\n    if (isKeyTop(startKey, axis))\n        sO = slowOut;\n    else {\n        var prevKey = key($bm_sub(startKey.index, 1));\n        var pVal = prevKey.value;\n        if ($bm_isInstanceOfArray(value))\n            pVal = pVal[axis];\n        sOV = $bm_div($bm_sub(sVal, pVal), $bm_sub(eVal, pVal));\n    }\n    if (isKeyTop(endKey, axis)) {\n        sI = slowIn;\n        if (endKey.index != numKeys) {\n            var nextKey = key($bm_sum(endKey.index, 1));\n            var nVal = nextKey.value;\n            if ($bm_isInstanceOfArray(value))\n                nVal = nVal[axis];\n            if (Math.abs(nVal - eVal) < 0.01 && doFollowThrough)\n                sI = 1;\n        }\n    } else {\n        var nextKey = key($bm_sum(endKey.index, 1));\n        var nVal = nextKey.value;\n        if ($bm_isInstanceOfArray(value))\n            nVal = nVal[axis];\n        sIV = $bm_div($bm_sub(eVal, sVal), $bm_sub(nVal, sVal));\n    }\n    if (endKey.index == numKeys && doFollowThrough) {\n        sI = 1;\n    }\n    var val = value;\n    if ($bm_isInstanceOfArray(value))\n        val = val[axis];\n    return $bm_sub(bezierInterpolation(time, sTime, eTime, sVal, eVal, [\n        sO,\n        sOV,\n        sI,\n        sIV\n    ]), val);\n}\nfunction overlap() {\n    var ol = zeroValue;\n    if (isThisPosition && !hasParent)\n        return zeroValue;\n    ol = $bm_sub(getPropWorldValue($bm_sub(time, overlapDuration), thisProperty), getPropWorldValue(time, thisProperty));\n    var motionRatio = $bm_div($bm_div(length(zeroValue, ol), thisLayer.width), 2);\n    if (isThisPosition) {\n        var originalDistance = length(valueAtTime(0));\n        motionRatio = $bm_div(length(zeroValue, ol), thisComp.width);\n    }\n    ol = $bm_sum(ol, getPropWorldValue(time, thisProperty));\n    ol = $bm_sum(ol, $bm_mul($bm_mul($bm_sub(getPropWorldValue($bm_sub(time, overlapDuration), thisLayer.anchorPoint), ol), motionRatio), flexibility));\n    ol = thisLayer.fromWorld(ol);\n    if (!isThisPosition)\n        ol = $bm_sub(ol, value);\n    else {\n        ol = linear(flexibility, 0, 100, $bm_div(ol, 2), 0);\n        var prevParentWorldPos = getLayerWorldPos($bm_sub(time, overlapDuration), parent);\n        ol = $bm_sum(ol, $bm_mul($bm_mul($bm_mul(thisLayer.fromWorld(prevParentWorldPos), motionRatio), flexibility), 5));\n    }\n    return ol;\n}\nvar okToGo = false;\nif (simulate && fx.enabled)\n    okToGo = true;\nelse if (numKeys > 1 && fx.enabled)\n    okToGo = true;\nif (okToGo) {\n    var smartSmoothResult = zeroValue;\n    if (doInterpolation) {\n        if ($bm_isInstanceOfArray(value)) {\n            if (value.length == 2)\n                smartSmoothResult = [\n                    smartSmooth(0),\n                    smartSmooth(1)\n                ];\n            else if (value.length == 3)\n                smartSmoothResult = [\n                    smartSmooth(0),\n                    smartSmooth(1),\n                    smartSmooth(2)\n                ];\n            else if (value.length == 4)\n                smartSmoothResult = [\n                    smartSmooth(0),\n                    smartSmooth(1),\n                    smartSmooth(2),\n                    smartSmooth(3)\n                ];\n        } else {\n            smartSmoothResult = smartSmooth(0);\n        }\n    }\n    if (doAnticipation)\n        result = $bm_sum(result, anticipate());\n    result = $bm_sum(result, smartSmoothResult);\n    if (doFollowThrough)\n        result = $bm_sum(result, followThrough());\n    if (doOverlap)\n        result = $bm_sum(result, overlap());\n}\n$bm_rt = result;"
                  },
                  "p": { "a": 0, "k": [86.383, -56.745] },
                  "a": { "a": 0, "k": [86.383, -56.745] },
                  "s": { "a": 0, "k": [100.0, 100.0] },
                  "nm": "Transform",
                  "sk": { "a": 0, "k": 0.0 },
                  "sa": {
                    "a": 0,
                    "k": 0.0,
                    "x": "var $bm_rt;\nvar fx = effect('\u015dlosilo pli pura 5');\nvar doAnticipation = fx(1).value;\nvar doInterpolation = fx(2).value;\nvar doFollowThrough = fx(3).value;\nvar damping = $bm_div(fx(15).value, 10);\nvar elasticity = $bm_div(fx(13).value, 10);\nvar bounce = fx(17).value;\nvar anticipationDuration = fx(5).value;\nvar anticipationQuantity = $bm_div(fx(6).value, 100);\nvar slowIn = $bm_div(fx(9).value, 100);\nvar slowOut = $bm_div(fx(10).value, 100);\nvar spatialMode = fx(21).value;\nvar spatialDoInterpolation = fx(20).value;\nvar moBlurPrecision = fx(32).value;\nvar elasticityRandom = fx(14).value;\nvar dampingRandom = fx(16).value;\nvar softBody = fx(28).value;\nvar flexibility = $bm_div(fx(29).value, 100);\nvar doOverlap = fx(23).value;\nvar overlapDuration = fx(24).value;\nvar overlapRandom = fx(25).value;\nvar threshold = $bm_div($bm_div(1, moBlurPrecision), 1000);\nvar zeroValue;\nif ($bm_isInstanceOfArray(value)) {\n    if (value.length == 2)\n        zeroValue = [\n            0,\n            0\n        ];\n    else if (value.length == 3)\n        zeroValue = [\n            0,\n            0,\n            0\n        ];\n    else if (value.length == 4)\n        zeroValue = [\n            0,\n            0,\n            0,\n            0\n        ];\n} else\n    zeroValue = 0;\nvar isThisSpatial = isSpatial(thisProperty);\nvar isThisPosition = thisProperty === $bm_transform.position;\nvar simulate = false;\nif (isThisSpatial) {\n    doInterpolation = doInterpolation && spatialDoInterpolation;\n    if (isThisPosition && thisProperty.numKeys > 0) {\n        doOverlap = false;\n        simulate = false;\n    } else {\n        simulate = spatialMode == 2;\n        doOverlap = overlapDuration != 0 && doOverlap && simulate;\n    }\n} else {\n    doOverlap = false;\n}\nif (!doOverlap) {\n    overlapDuration = 0;\n}\nif (simulate && softBody && isThisSpatial && !isThisPosition && (doFollowThrough || doOverlap)) {\n    var distanceRatio = $bm_div(length(valueAtTime(0), $bm_transform.anchorPoint), $bm_div(thisLayer.width, 2));\n    distanceRatio = $bm_div($bm_sum(1, $bm_mul(distanceRatio, flexibility)), 2);\n    if (doFollowThrough) {\n        elasticity = $bm_div(elasticity, distanceRatio);\n        damping = $bm_div(damping, distanceRatio);\n    }\n    if (doOverlap) {\n        overlapDuration = $bm_mul(overlapDuration, distanceRatio);\n    }\n}\nseedRandom(0, true);\nif (doFollowThrough) {\n    if (elasticityRandom > 0)\n        elasticity = addNoise(elasticity, elasticityRandom);\n    if (dampingRandom > 0)\n        damping = addNoise(damping, dampingRandom);\n}\nif (doOverlap) {\n    if (doOverlap && overlapRandom > 0)\n        overlapDuration = addNoise(overlapDuration, overlapRandom);\n}\nvar result = value;\nfunction isSpatial(prop) {\n    if (!(prop.value instanceof Array))\n        return false;\n    if (prop.value.length != 2 && prop.value.length != 3)\n        return false;\n    try {\n        if (typeof prop.speed !== 'undefined')\n            return true;\n    } catch (e) {\n        return false;\n    }\n}\nfunction addNoise(val, quantity) {\n    var randomValue = random(0.9, 1.1);\n    var noiseValue = noise($bm_mul(valueAtTime(0), randomValue));\n    noiseValue = $bm_mul(noiseValue, $bm_div(quantity, 100));\n    return $bm_mul(val, $bm_sum(noiseValue, 1));\n}\nfunction isAfterLastKey() {\n    if (numKeys == 0)\n        return false;\n    var nKey = nearestKey(time);\n    return nKey.time <= time && nKey.index == numKeys;\n}\nfunction isStill(t, threshold) {\n    var d = $bm_sub(valueAtTime(t), valueAtTime($bm_sum(t, framesToTime(1))));\n    if ($bm_isInstanceOfArray(d)) {\n        for (var i = 0; i < d.length; i++) {\n            d[i] = Math.abs(d[i]);\n            if (d[i] >= threshold) {\n                return false;\n            }\n        }\n        return true;\n    } else {\n        d = Math.abs(d);\n        return d < threshold;\n    }\n}\nfunction bezierInterpolation(t, tMin, tMax, value1, value2, bezierPoints) {\n    if (arguments.length !== 5 && arguments.length !== 6)\n        return t;\n    var a = $bm_sub(value2, value1);\n    var b = $bm_sub(tMax, tMin);\n    if (b == 0)\n        return t;\n    var c = clamp($bm_div($bm_sub(t, tMin), b), 0, 1);\n    if (!(bezierPoints instanceof Array) || bezierPoints.length !== 4)\n        bezierPoints = [\n            0.33,\n            0,\n            0.66,\n            1\n        ];\n    return $bm_sum($bm_mul(a, h(c, bezierPoints)), value1);\n    function h(f, g) {\n        var x = $bm_mul(3, g[0]);\n        var j = $bm_sub($bm_mul(3, $bm_sub(g[2], g[0])), x);\n        var k = $bm_sub($bm_sub(1, x), j);\n        var l = $bm_mul(3, g[1]);\n        var m = $bm_sub($bm_mul(3, $bm_sub(g[3], g[1])), l);\n        var n = $bm_sub($bm_sub(1, l), m);\n        var d = f;\n        for (var i = 0; i < 5; i++) {\n            var z = $bm_sub($bm_mul(d, $bm_sum(x, $bm_mul(d, $bm_sum(j, $bm_mul(d, k))))), f);\n            if (Math.abs(z) < 0.001)\n                break;\n            d = $bm_sub(d, $bm_div(z, $bm_sum(x, $bm_mul(d, $bm_sum($bm_mul(2, j), $bm_mul($bm_mul(3, k), d))))));\n        }\n        return $bm_mul(d, $bm_sum(l, $bm_mul(d, $bm_sum(m, $bm_mul(d, n)))));\n    }\n}\nfunction getPropWorldSpeed(t, prop) {\n    return length(getPropWorldVelocity(t, prop));\n}\nfunction getPrevKey(t) {\n    if (numKeys == 0)\n        return null;\n    var nKey = nearestKey(t);\n    if (nKey.time <= t)\n        return nKey;\n    if (nKey.index > 1)\n        return key($bm_sub(nKey.index, 1));\n    return null;\n}\nfunction getNextKey(t) {\n    if (numKeys == 0)\n        return null;\n    var nKey = nearestKey(t);\n    if (nKey.time >= t)\n        return nKey;\n    if (nKey.index < numKeys)\n        return key($bm_sum(nKey.index, 1));\n    return null;\n}\nfunction getPropWorldVelocity(t, prop) {\n    return $bm_mul($bm_sub(getPropWorldValue($bm_sum(t, 0.005), prop), getPropWorldValue($bm_sub(t, 0.005), prop)), 100);\n}\nfunction getLayerWorldPos(t, l) {\n    return l.toWorld(l.anchorPoint, t);\n}\nfunction getPropWorldValue(t, prop) {\n    if (isPosition(prop))\n        return getLayerWorldPos(t, thisLayer);\n    return thisLayer.toWorld(prop.valueAtTime(t), t);\n}\nfunction isPosition(prop) {\n    return prop === $bm_transform.position;\n}\nfunction isKeyTop(k, axis) {\n    var prevSpeed = velocityAtTime($bm_sub(k.time, threshold));\n    var nextSpeed = velocityAtTime($bm_sum(k.time, threshold));\n    if ($bm_isInstanceOfArray(value)) {\n        prevSpeed = prevSpeed[axis];\n        nextSpeed = nextSpeed[axis];\n    }\n    if (Math.abs(prevSpeed) < 0.01 || Math.abs(nextSpeed) < 0.01)\n        return true;\n    return $bm_mul(prevSpeed, nextSpeed) < 0;\n}\nfunction anticipate() {\n    var anticipation = zeroValue;\n    if (isAfterLastKey())\n        return anticipation;\n    if (numKeys < 2)\n        return anticipation;\n    var nextKey = getNextKey(time);\n    var aKey = nextKey;\n    if (!isStill(aKey.time - 0.1, 0.1)) {\n        aKey = getPrevKey(time);\n        if (!isStill(aKey.time - 0.1, 0.1))\n            return anticipation;\n    }\n    if (aKey.index == numKeys)\n        return anticipation;\n    var anticipationMiddle = aKey.time;\n    var anticipationStart = $bm_sub(anticipationMiddle, anticipationDuration);\n    var anticipationEnd = key(aKey.index + 1).time;\n    var startValue = anticipation;\n    var midValue = $bm_mul($bm_sum($bm_neg(valueAtTime($bm_sum(anticipationMiddle, anticipationDuration))), aKey.value), anticipationQuantity);\n    var endValue = anticipation;\n    if (time < anticipationStart) {\n        return anticipation;\n    } else if (time < anticipationMiddle) {\n        if ($bm_isInstanceOfArray(value)) {\n            for (var i = 0; i < value.length; i++) {\n                anticipation[i] = bezierInterpolation(time, anticipationStart, anticipationMiddle, startValue[i], midValue[i], [\n                    slowOut,\n                    0,\n                    slowIn,\n                    1\n                ]);\n            }\n            return anticipation;\n        } else {\n            return bezierInterpolation(time, anticipationStart, anticipationMiddle, startValue, midValue, [\n                slowOut,\n                0,\n                slowIn,\n                1\n            ]);\n        }\n    } else if (time <= anticipationEnd) {\n        if ($bm_isInstanceOfArray(value)) {\n            for (var i = 0; i < value.length; i++) {\n                anticipation[i] = bezierInterpolation(time, anticipationMiddle, anticipationEnd, midValue[i], endValue[i], [\n                    slowOut,\n                    0,\n                    slowIn,\n                    1\n                ]);\n            }\n            return anticipation;\n        } else {\n            return bezierInterpolation(time, anticipationMiddle, anticipationEnd, midValue, endValue, [\n                slowOut,\n                0,\n                slowIn,\n                1\n            ]);\n        }\n    } else {\n        return anticipation;\n    }\n}\nfunction followThroughAtTime(t) {\n    var fThrough = zeroValue;\n    if (elasticity == 0)\n        return fThrough;\n    var propSpeed;\n    if (!simulate) {\n        if (numKeys < 2)\n            return fThrough;\n        if (nearestKey(t).index == 1)\n            return fThrough;\n        propSpeed = length(velocityAtTime(t));\n        if (propSpeed >= threshold)\n            return fThrough;\n    } else {\n        propSpeed = getPropWorldSpeed(t, thisProperty);\n        if (propSpeed >= threshold)\n            return fThrough;\n    }\n    var fThroughStart = 0;\n    var fThroughTime = 0;\n    if (simulate) {\n        var speedI = getPropWorldSpeed(t, thisProperty);\n        var i = t;\n        while (speedI < threshold && i > 0) {\n            i = $bm_sub(i, $bm_div(thisComp.frameDuration, moBlurPrecision));\n            speedI = getPropWorldSpeed(i, thisProperty);\n        }\n        fThroughStart = i;\n    } else {\n        var fThroughKey = getPrevKey(t);\n        fThroughStart = fThroughKey.time;\n    }\n    if (fThroughStart == 0)\n        return fThrough;\n    fThroughTime = $bm_sub(t, fThroughStart);\n    if (simulate)\n        fThrough = $bm_div(getPropWorldVelocity($bm_sub(fThroughStart, thisComp.frameDuration), thisProperty), 2);\n    else\n        fThrough = $bm_div(velocityAtTime($bm_sub(fThroughStart, thisComp.frameDuration)), 2);\n    if (bounce) {\n        var cycleDamp = Math.exp($bm_mul($bm_mul(fThroughTime, damping), 0.1));\n        var damp = $bm_div(Math.exp($bm_mul(fThroughTime, damping)), $bm_div(elasticity, 2));\n        var cycleDuration = $bm_div(1, $bm_mul(elasticity, 2));\n        cycleDuration = Math.round(timeToFrames(cycleDuration));\n        cycleDuration = framesToTime(cycleDuration);\n        var midDuration = $bm_div(cycleDuration, 2);\n        var maxValue = $bm_mul(fThrough, midDuration);\n        var cycvarime = fThroughTime;\n        var numEndCycles = 1;\n        while (cycvarime > cycleDuration) {\n            cycvarime = $bm_sub(cycvarime, cycleDuration);\n            cycleDuration = $bm_div(cycleDuration, cycleDamp);\n            cycleDuration = Math.round(timeToFrames(cycleDuration));\n            if (cycleDuration < 2) {\n                cycleDuration = 2;\n                numEndCycles++;\n            }\n            cycleDuration = framesToTime(cycleDuration);\n            midDuration = $bm_div(cycleDuration, 2);\n            maxValue = $bm_div($bm_mul(fThrough, midDuration), damp);\n            if (numEndCycles > 100 / damping && maxValue < threshold)\n                return zeroValue;\n        }\n        if (cycvarime < midDuration)\n            fThrough = bezierInterpolation(cycvarime, 0, midDuration, 0, maxValue, [\n                0,\n                0.1,\n                slowIn,\n                1\n            ]);\n        else\n            fThrough = bezierInterpolation(cycvarime, midDuration, cycleDuration, maxValue, 0, [\n                $bm_sub(1, slowIn),\n                0,\n                1,\n                0.9\n            ]);\n    } else {\n        var damp = Math.exp($bm_mul(fThroughTime, damping));\n        var sinus = $bm_mul($bm_mul($bm_mul(elasticity, fThroughTime), 2), Math.PI);\n        sinus = Math.sin(sinus);\n        sinus = $bm_mul($bm_div(0.3, elasticity), sinus);\n        sinus = $bm_div(sinus, damp);\n        if (Math.abs(sinus) < $bm_div(threshold, 100))\n            return 0;\n        fThrough = $bm_mul(fThrough, sinus);\n        if (threshold > 0) {\n            fThrough = $bm_mul(fThrough, $bm_sub(1, $bm_div(propSpeed, threshold)));\n        }\n    }\n    if (bounce) {\n        var prevValue = valueAtTime($bm_sub(fThroughStart, thisComp.frameDuration));\n        var startValue = valueAtTime(fThroughStart);\n        if ($bm_isInstanceOfArray(value)) {\n            for (var i = 0; i < prevValue.length; i++) {\n                if (prevValue[i] > startValue[i])\n                    fThrough[i] = Math.abs(fThrough[i]);\n                if (prevValue[i] < startValue[i])\n                    fThrough[i] = $bm_neg(Math.abs(fThrough[i]));\n            }\n        } else {\n            if (prevValue > startValue)\n                fThrough = Math.abs(fThrough);\n            if (prevValue < startValue)\n                fThrough = $bm_neg(Math.abs(fThrough));\n        }\n    }\n    if (simulate) {\n        if (!isThisPosition) {\n            fThrough = $bm_sum(fThrough, getLayerWorldPos(time, thisLayer));\n            fThrough = $bm_sub(thisLayer.fromWorld(fThrough), thisLayer.anchorPoint);\n        } else if (thisLayer.hasParent) {\n            fThrough = $bm_sum(fThrough, getLayerWorldPos(time, thisLayer.parent));\n            fThrough = $bm_sub(thisLayer.parent.fromWorld(fThrough), thisLayer.parent.anchorPoint);\n        }\n    }\n    return fThrough;\n}\nfunction followThrough() {\n    var propSpeed = length(velocity);\n    if (propSpeed < threshold)\n        return followThroughAtTime($bm_sub(time, overlapDuration));\n    var fThrough = zeroValue;\n    var t = time;\n    while (t > 0) {\n        t = $bm_sub(t, thisComp.frameDuration);\n        if (simulate)\n            propSpeed = getPropWorldSpeed($bm_sub(t, overlapDuration), thisProperty);\n        else\n            propSpeed = length(velocityAtTime(t));\n        if (propSpeed < threshold) {\n            fThrough = followThroughAtTime($bm_sub(t, overlapDuration));\n            break;\n        }\n    }\n    return linear(time, t, $bm_sum(t, $bm_mul(anticipationDuration, 2)), fThrough, zeroValue);\n}\nfunction smartSmooth(axis) {\n    var startKey = nearestKey(time);\n    var endKey = startKey;\n    if (time == startKey.time)\n        return 0;\n    if (time < startKey.time && startKey.index == 1)\n        return 0;\n    if (time > startKey.time && startKey.index == numKeys)\n        return 0;\n    if (time < startKey.time)\n        startKey = key($bm_sub(startKey.index, 1));\n    if (time > startKey.time)\n        endKey = key($bm_sum(startKey.index, 1));\n    var sI = 0.66;\n    var sO = 0.33;\n    var sIV = 1;\n    var sOV = 0;\n    var sVal = startKey.value;\n    var eVal = endKey.value;\n    if ($bm_isInstanceOfArray(value)) {\n        sVal = sVal[axis];\n        eVal = eVal[axis];\n    }\n    var sTime = startKey.time;\n    var eTime = endKey.time;\n    if (isKeyTop(startKey, axis))\n        sO = slowOut;\n    else {\n        var prevKey = key($bm_sub(startKey.index, 1));\n        var pVal = prevKey.value;\n        if ($bm_isInstanceOfArray(value))\n            pVal = pVal[axis];\n        sOV = $bm_div($bm_sub(sVal, pVal), $bm_sub(eVal, pVal));\n    }\n    if (isKeyTop(endKey, axis)) {\n        sI = slowIn;\n        if (endKey.index != numKeys) {\n            var nextKey = key($bm_sum(endKey.index, 1));\n            var nVal = nextKey.value;\n            if ($bm_isInstanceOfArray(value))\n                nVal = nVal[axis];\n            if (Math.abs(nVal - eVal) < 0.01 && doFollowThrough)\n                sI = 1;\n        }\n    } else {\n        var nextKey = key($bm_sum(endKey.index, 1));\n        var nVal = nextKey.value;\n        if ($bm_isInstanceOfArray(value))\n            nVal = nVal[axis];\n        sIV = $bm_div($bm_sub(eVal, sVal), $bm_sub(nVal, sVal));\n    }\n    if (endKey.index == numKeys && doFollowThrough) {\n        sI = 1;\n    }\n    var val = value;\n    if ($bm_isInstanceOfArray(value))\n        val = val[axis];\n    return $bm_sub(bezierInterpolation(time, sTime, eTime, sVal, eVal, [\n        sO,\n        sOV,\n        sI,\n        sIV\n    ]), val);\n}\nfunction overlap() {\n    var ol = zeroValue;\n    if (isThisPosition && !hasParent)\n        return zeroValue;\n    ol = $bm_sub(getPropWorldValue($bm_sub(time, overlapDuration), thisProperty), getPropWorldValue(time, thisProperty));\n    var motionRatio = $bm_div($bm_div(length(zeroValue, ol), thisLayer.width), 2);\n    if (isThisPosition) {\n        var originalDistance = length(valueAtTime(0));\n        motionRatio = $bm_div(length(zeroValue, ol), thisComp.width);\n    }\n    ol = $bm_sum(ol, getPropWorldValue(time, thisProperty));\n    ol = $bm_sum(ol, $bm_mul($bm_mul($bm_sub(getPropWorldValue($bm_sub(time, overlapDuration), thisLayer.anchorPoint), ol), motionRatio), flexibility));\n    ol = thisLayer.fromWorld(ol);\n    if (!isThisPosition)\n        ol = $bm_sub(ol, value);\n    else {\n        ol = linear(flexibility, 0, 100, $bm_div(ol, 2), 0);\n        var prevParentWorldPos = getLayerWorldPos($bm_sub(time, overlapDuration), parent);\n        ol = $bm_sum(ol, $bm_mul($bm_mul($bm_mul(thisLayer.fromWorld(prevParentWorldPos), motionRatio), flexibility), 5));\n    }\n    return ol;\n}\nvar okToGo = false;\nif (simulate && fx.enabled)\n    okToGo = true;\nelse if (numKeys > 1 && fx.enabled)\n    okToGo = true;\nif (okToGo) {\n    var smartSmoothResult = zeroValue;\n    if (doInterpolation) {\n        if ($bm_isInstanceOfArray(value)) {\n            if (value.length == 2)\n                smartSmoothResult = [\n                    smartSmooth(0),\n                    smartSmooth(1)\n                ];\n            else if (value.length == 3)\n                smartSmoothResult = [\n                    smartSmooth(0),\n                    smartSmooth(1),\n                    smartSmooth(2)\n                ];\n            else if (value.length == 4)\n                smartSmoothResult = [\n                    smartSmooth(0),\n                    smartSmooth(1),\n                    smartSmooth(2),\n                    smartSmooth(3)\n                ];\n        } else {\n            smartSmoothResult = smartSmooth(0);\n        }\n    }\n    if (doAnticipation)\n        result = $bm_sum(result, anticipate());\n    result = $bm_sum(result, smartSmoothResult);\n    if (doFollowThrough)\n        result = $bm_sum(result, followThrough());\n    if (doOverlap)\n        result = $bm_sum(result, overlap());\n}\n$bm_rt = result;"
                  }
                }
              ]
            },
            {
              "ty": "tr",
              "o": { "a": 0, "k": 100.0 },
              "r": {
                "a": 1,
                "k": [
                  {
                    "i": { "x": [0.667], "y": [1] },
                    "o": { "x": [0.333], "y": [0] },
                    "t": 25,
                    "s": [-9.0]
                  },
                  {
                    "i": { "x": [0.667], "y": [1] },
                    "o": { "x": [0.333], "y": [0] },
                    "t": 33,
                    "s": [5.0]
                  },
                  {
                    "i": { "x": [0.833], "y": [1] },
                    "o": { "x": [0.333], "y": [0] },
                    "t": 53,
                    "s": [5.0]
                  },
                  {
                    "i": { "x": [0.667], "y": [1] },
                    "o": { "x": [0.167], "y": [0] },
                    "t": 61,
                    "s": [-8.0]
                  },
                  {
                    "i": { "x": [0.833], "y": [1] },
                    "o": { "x": [0.333], "y": [0] },
                    "t": 70,
                    "s": [5.0]
                  },
                  {
                    "i": { "x": [0.667], "y": [1] },
                    "o": { "x": [0.167], "y": [0] },
                    "t": 78,
                    "s": [-8.0]
                  },
                  {
                    "i": { "x": [0.833], "y": [1] },
                    "o": { "x": [0.333], "y": [0] },
                    "t": 87,
                    "s": [5.0]
                  },
                  {
                    "i": { "x": [0.833], "y": [1] },
                    "o": { "x": [0.167], "y": [0] },
                    "t": 95,
                    "s": [-8.0]
                  },
                  {
                    "i": { "x": [0.667], "y": [1] },
                    "o": { "x": [0.167], "y": [0] },
                    "t": 107,
                    "s": [-8.0]
                  },
                  { "t": 117, "s": [-9.0] }
                ],
                "x": "var $bm_rt;\nvar fx = effect('\u015dlosilo pli pura 4');\nvar doAnticipation = fx(1).value;\nvar doInterpolation = fx(2).value;\nvar doFollowThrough = fx(3).value;\nvar damping = $bm_div(fx(15).value, 10);\nvar elasticity = $bm_div(fx(13).value, 10);\nvar bounce = fx(17).value;\nvar anticipationDuration = fx(5).value;\nvar anticipationQuantity = $bm_div(fx(6).value, 100);\nvar slowIn = $bm_div(fx(9).value, 100);\nvar slowOut = $bm_div(fx(10).value, 100);\nvar spatialMode = fx(21).value;\nvar spatialDoInterpolation = fx(20).value;\nvar moBlurPrecision = fx(32).value;\nvar elasticityRandom = fx(14).value;\nvar dampingRandom = fx(16).value;\nvar softBody = fx(28).value;\nvar flexibility = $bm_div(fx(29).value, 100);\nvar doOverlap = fx(23).value;\nvar overlapDuration = fx(24).value;\nvar overlapRandom = fx(25).value;\nvar threshold = $bm_div($bm_div(1, moBlurPrecision), 1000);\nvar zeroValue;\nif ($bm_isInstanceOfArray(value)) {\n    if (value.length == 2)\n        zeroValue = [\n            0,\n            0\n        ];\n    else if (value.length == 3)\n        zeroValue = [\n            0,\n            0,\n            0\n        ];\n    else if (value.length == 4)\n        zeroValue = [\n            0,\n            0,\n            0,\n            0\n        ];\n} else\n    zeroValue = 0;\nvar isThisSpatial = isSpatial(thisProperty);\nvar isThisPosition = thisProperty === $bm_transform.position;\nvar simulate = false;\nif (isThisSpatial) {\n    doInterpolation = doInterpolation && spatialDoInterpolation;\n    if (isThisPosition && thisProperty.numKeys > 0) {\n        doOverlap = false;\n        simulate = false;\n    } else {\n        simulate = spatialMode == 2;\n        doOverlap = overlapDuration != 0 && doOverlap && simulate;\n    }\n} else {\n    doOverlap = false;\n}\nif (!doOverlap) {\n    overlapDuration = 0;\n}\nif (simulate && softBody && isThisSpatial && !isThisPosition && (doFollowThrough || doOverlap)) {\n    var distanceRatio = $bm_div(length(valueAtTime(0), $bm_transform.anchorPoint), $bm_div(thisLayer.width, 2));\n    distanceRatio = $bm_div($bm_sum(1, $bm_mul(distanceRatio, flexibility)), 2);\n    if (doFollowThrough) {\n        elasticity = $bm_div(elasticity, distanceRatio);\n        damping = $bm_div(damping, distanceRatio);\n    }\n    if (doOverlap) {\n        overlapDuration = $bm_mul(overlapDuration, distanceRatio);\n    }\n}\nseedRandom(0, true);\nif (doFollowThrough) {\n    if (elasticityRandom > 0)\n        elasticity = addNoise(elasticity, elasticityRandom);\n    if (dampingRandom > 0)\n        damping = addNoise(damping, dampingRandom);\n}\nif (doOverlap) {\n    if (doOverlap && overlapRandom > 0)\n        overlapDuration = addNoise(overlapDuration, overlapRandom);\n}\nvar result = value;\nfunction isSpatial(prop) {\n    if (!(prop.value instanceof Array))\n        return false;\n    if (prop.value.length != 2 && prop.value.length != 3)\n        return false;\n    try {\n        if (typeof prop.speed !== 'undefined')\n            return true;\n    } catch (e) {\n        return false;\n    }\n}\nfunction addNoise(val, quantity) {\n    var randomValue = random(0.9, 1.1);\n    var noiseValue = noise($bm_mul(valueAtTime(0), randomValue));\n    noiseValue = $bm_mul(noiseValue, $bm_div(quantity, 100));\n    return $bm_mul(val, $bm_sum(noiseValue, 1));\n}\nfunction isAfterLastKey() {\n    if (numKeys == 0)\n        return false;\n    var nKey = nearestKey(time);\n    return nKey.time <= time && nKey.index == numKeys;\n}\nfunction isStill(t, threshold) {\n    var d = $bm_sub(valueAtTime(t), valueAtTime($bm_sum(t, framesToTime(1))));\n    if ($bm_isInstanceOfArray(d)) {\n        for (var i = 0; i < d.length; i++) {\n            d[i] = Math.abs(d[i]);\n            if (d[i] >= threshold) {\n                return false;\n            }\n        }\n        return true;\n    } else {\n        d = Math.abs(d);\n        return d < threshold;\n    }\n}\nfunction bezierInterpolation(t, tMin, tMax, value1, value2, bezierPoints) {\n    if (arguments.length !== 5 && arguments.length !== 6)\n        return t;\n    var a = $bm_sub(value2, value1);\n    var b = $bm_sub(tMax, tMin);\n    if (b == 0)\n        return t;\n    var c = clamp($bm_div($bm_sub(t, tMin), b), 0, 1);\n    if (!(bezierPoints instanceof Array) || bezierPoints.length !== 4)\n        bezierPoints = [\n            0.33,\n            0,\n            0.66,\n            1\n        ];\n    return $bm_sum($bm_mul(a, h(c, bezierPoints)), value1);\n    function h(f, g) {\n        var x = $bm_mul(3, g[0]);\n        var j = $bm_sub($bm_mul(3, $bm_sub(g[2], g[0])), x);\n        var k = $bm_sub($bm_sub(1, x), j);\n        var l = $bm_mul(3, g[1]);\n        var m = $bm_sub($bm_mul(3, $bm_sub(g[3], g[1])), l);\n        var n = $bm_sub($bm_sub(1, l), m);\n        var d = f;\n        for (var i = 0; i < 5; i++) {\n            var z = $bm_sub($bm_mul(d, $bm_sum(x, $bm_mul(d, $bm_sum(j, $bm_mul(d, k))))), f);\n            if (Math.abs(z) < 0.001)\n                break;\n            d = $bm_sub(d, $bm_div(z, $bm_sum(x, $bm_mul(d, $bm_sum($bm_mul(2, j), $bm_mul($bm_mul(3, k), d))))));\n        }\n        return $bm_mul(d, $bm_sum(l, $bm_mul(d, $bm_sum(m, $bm_mul(d, n)))));\n    }\n}\nfunction getPropWorldSpeed(t, prop) {\n    return length(getPropWorldVelocity(t, prop));\n}\nfunction getPrevKey(t) {\n    if (numKeys == 0)\n        return null;\n    var nKey = nearestKey(t);\n    if (nKey.time <= t)\n        return nKey;\n    if (nKey.index > 1)\n        return key($bm_sub(nKey.index, 1));\n    return null;\n}\nfunction getNextKey(t) {\n    if (numKeys == 0)\n        return null;\n    var nKey = nearestKey(t);\n    if (nKey.time >= t)\n        return nKey;\n    if (nKey.index < numKeys)\n        return key($bm_sum(nKey.index, 1));\n    return null;\n}\nfunction getPropWorldVelocity(t, prop) {\n    return $bm_mul($bm_sub(getPropWorldValue($bm_sum(t, 0.005), prop), getPropWorldValue($bm_sub(t, 0.005), prop)), 100);\n}\nfunction getLayerWorldPos(t, l) {\n    return l.toWorld(l.anchorPoint, t);\n}\nfunction getPropWorldValue(t, prop) {\n    if (isPosition(prop))\n        return getLayerWorldPos(t, thisLayer);\n    return thisLayer.toWorld(prop.valueAtTime(t), t);\n}\nfunction isPosition(prop) {\n    return prop === $bm_transform.position;\n}\nfunction isKeyTop(k, axis) {\n    var prevSpeed = velocityAtTime($bm_sub(k.time, threshold));\n    var nextSpeed = velocityAtTime($bm_sum(k.time, threshold));\n    if ($bm_isInstanceOfArray(value)) {\n        prevSpeed = prevSpeed[axis];\n        nextSpeed = nextSpeed[axis];\n    }\n    if (Math.abs(prevSpeed) < 0.01 || Math.abs(nextSpeed) < 0.01)\n        return true;\n    return $bm_mul(prevSpeed, nextSpeed) < 0;\n}\nfunction anticipate() {\n    var anticipation = zeroValue;\n    if (isAfterLastKey())\n        return anticipation;\n    if (numKeys < 2)\n        return anticipation;\n    var nextKey = getNextKey(time);\n    var aKey = nextKey;\n    if (!isStill(aKey.time - 0.1, 0.1)) {\n        aKey = getPrevKey(time);\n        if (!isStill(aKey.time - 0.1, 0.1))\n            return anticipation;\n    }\n    if (aKey.index == numKeys)\n        return anticipation;\n    var anticipationMiddle = aKey.time;\n    var anticipationStart = $bm_sub(anticipationMiddle, anticipationDuration);\n    var anticipationEnd = key(aKey.index + 1).time;\n    var startValue = anticipation;\n    var midValue = $bm_mul($bm_sum($bm_neg(valueAtTime($bm_sum(anticipationMiddle, anticipationDuration))), aKey.value), anticipationQuantity);\n    var endValue = anticipation;\n    if (time < anticipationStart) {\n        return anticipation;\n    } else if (time < anticipationMiddle) {\n        if ($bm_isInstanceOfArray(value)) {\n            for (var i = 0; i < value.length; i++) {\n                anticipation[i] = bezierInterpolation(time, anticipationStart, anticipationMiddle, startValue[i], midValue[i], [\n                    slowOut,\n                    0,\n                    slowIn,\n                    1\n                ]);\n            }\n            return anticipation;\n        } else {\n            return bezierInterpolation(time, anticipationStart, anticipationMiddle, startValue, midValue, [\n                slowOut,\n                0,\n                slowIn,\n                1\n            ]);\n        }\n    } else if (time <= anticipationEnd) {\n        if ($bm_isInstanceOfArray(value)) {\n            for (var i = 0; i < value.length; i++) {\n                anticipation[i] = bezierInterpolation(time, anticipationMiddle, anticipationEnd, midValue[i], endValue[i], [\n                    slowOut,\n                    0,\n                    slowIn,\n                    1\n                ]);\n            }\n            return anticipation;\n        } else {\n            return bezierInterpolation(time, anticipationMiddle, anticipationEnd, midValue, endValue, [\n                slowOut,\n                0,\n                slowIn,\n                1\n            ]);\n        }\n    } else {\n        return anticipation;\n    }\n}\nfunction followThroughAtTime(t) {\n    var fThrough = zeroValue;\n    if (elasticity == 0)\n        return fThrough;\n    var propSpeed;\n    if (!simulate) {\n        if (numKeys < 2)\n            return fThrough;\n        if (nearestKey(t).index == 1)\n            return fThrough;\n        propSpeed = length(velocityAtTime(t));\n        if (propSpeed >= threshold)\n            return fThrough;\n    } else {\n        propSpeed = getPropWorldSpeed(t, thisProperty);\n        if (propSpeed >= threshold)\n            return fThrough;\n    }\n    var fThroughStart = 0;\n    var fThroughTime = 0;\n    if (simulate) {\n        var speedI = getPropWorldSpeed(t, thisProperty);\n        var i = t;\n        while (speedI < threshold && i > 0) {\n            i = $bm_sub(i, $bm_div(thisComp.frameDuration, moBlurPrecision));\n            speedI = getPropWorldSpeed(i, thisProperty);\n        }\n        fThroughStart = i;\n    } else {\n        var fThroughKey = getPrevKey(t);\n        fThroughStart = fThroughKey.time;\n    }\n    if (fThroughStart == 0)\n        return fThrough;\n    fThroughTime = $bm_sub(t, fThroughStart);\n    if (simulate)\n        fThrough = $bm_div(getPropWorldVelocity($bm_sub(fThroughStart, thisComp.frameDuration), thisProperty), 2);\n    else\n        fThrough = $bm_div(velocityAtTime($bm_sub(fThroughStart, thisComp.frameDuration)), 2);\n    if (bounce) {\n        var cycleDamp = Math.exp($bm_mul($bm_mul(fThroughTime, damping), 0.1));\n        var damp = $bm_div(Math.exp($bm_mul(fThroughTime, damping)), $bm_div(elasticity, 2));\n        var cycleDuration = $bm_div(1, $bm_mul(elasticity, 2));\n        cycleDuration = Math.round(timeToFrames(cycleDuration));\n        cycleDuration = framesToTime(cycleDuration);\n        var midDuration = $bm_div(cycleDuration, 2);\n        var maxValue = $bm_mul(fThrough, midDuration);\n        var cycvarime = fThroughTime;\n        var numEndCycles = 1;\n        while (cycvarime > cycleDuration) {\n            cycvarime = $bm_sub(cycvarime, cycleDuration);\n            cycleDuration = $bm_div(cycleDuration, cycleDamp);\n            cycleDuration = Math.round(timeToFrames(cycleDuration));\n            if (cycleDuration < 2) {\n                cycleDuration = 2;\n                numEndCycles++;\n            }\n            cycleDuration = framesToTime(cycleDuration);\n            midDuration = $bm_div(cycleDuration, 2);\n            maxValue = $bm_div($bm_mul(fThrough, midDuration), damp);\n            if (numEndCycles > 100 / damping && maxValue < threshold)\n                return zeroValue;\n        }\n        if (cycvarime < midDuration)\n            fThrough = bezierInterpolation(cycvarime, 0, midDuration, 0, maxValue, [\n                0,\n                0.1,\n                slowIn,\n                1\n            ]);\n        else\n            fThrough = bezierInterpolation(cycvarime, midDuration, cycleDuration, maxValue, 0, [\n                $bm_sub(1, slowIn),\n                0,\n                1,\n                0.9\n            ]);\n    } else {\n        var damp = Math.exp($bm_mul(fThroughTime, damping));\n        var sinus = $bm_mul($bm_mul($bm_mul(elasticity, fThroughTime), 2), Math.PI);\n        sinus = Math.sin(sinus);\n        sinus = $bm_mul($bm_div(0.3, elasticity), sinus);\n        sinus = $bm_div(sinus, damp);\n        if (Math.abs(sinus) < $bm_div(threshold, 100))\n            return 0;\n        fThrough = $bm_mul(fThrough, sinus);\n        if (threshold > 0) {\n            fThrough = $bm_mul(fThrough, $bm_sub(1, $bm_div(propSpeed, threshold)));\n        }\n    }\n    if (bounce) {\n        var prevValue = valueAtTime($bm_sub(fThroughStart, thisComp.frameDuration));\n        var startValue = valueAtTime(fThroughStart);\n        if ($bm_isInstanceOfArray(value)) {\n            for (var i = 0; i < prevValue.length; i++) {\n                if (prevValue[i] > startValue[i])\n                    fThrough[i] = Math.abs(fThrough[i]);\n                if (prevValue[i] < startValue[i])\n                    fThrough[i] = $bm_neg(Math.abs(fThrough[i]));\n            }\n        } else {\n            if (prevValue > startValue)\n                fThrough = Math.abs(fThrough);\n            if (prevValue < startValue)\n                fThrough = $bm_neg(Math.abs(fThrough));\n        }\n    }\n    if (simulate) {\n        if (!isThisPosition) {\n            fThrough = $bm_sum(fThrough, getLayerWorldPos(time, thisLayer));\n            fThrough = $bm_sub(thisLayer.fromWorld(fThrough), thisLayer.anchorPoint);\n        } else if (thisLayer.hasParent) {\n            fThrough = $bm_sum(fThrough, getLayerWorldPos(time, thisLayer.parent));\n            fThrough = $bm_sub(thisLayer.parent.fromWorld(fThrough), thisLayer.parent.anchorPoint);\n        }\n    }\n    return fThrough;\n}\nfunction followThrough() {\n    var propSpeed = length(velocity);\n    if (propSpeed < threshold)\n        return followThroughAtTime($bm_sub(time, overlapDuration));\n    var fThrough = zeroValue;\n    var t = time;\n    while (t > 0) {\n        t = $bm_sub(t, thisComp.frameDuration);\n        if (simulate)\n            propSpeed = getPropWorldSpeed($bm_sub(t, overlapDuration), thisProperty);\n        else\n            propSpeed = length(velocityAtTime(t));\n        if (propSpeed < threshold) {\n            fThrough = followThroughAtTime($bm_sub(t, overlapDuration));\n            break;\n        }\n    }\n    return linear(time, t, $bm_sum(t, $bm_mul(anticipationDuration, 2)), fThrough, zeroValue);\n}\nfunction smartSmooth(axis) {\n    var startKey = nearestKey(time);\n    var endKey = startKey;\n    if (time == startKey.time)\n        return 0;\n    if (time < startKey.time && startKey.index == 1)\n        return 0;\n    if (time > startKey.time && startKey.index == numKeys)\n        return 0;\n    if (time < startKey.time)\n        startKey = key($bm_sub(startKey.index, 1));\n    if (time > startKey.time)\n        endKey = key($bm_sum(startKey.index, 1));\n    var sI = 0.66;\n    var sO = 0.33;\n    var sIV = 1;\n    var sOV = 0;\n    var sVal = startKey.value;\n    var eVal = endKey.value;\n    if ($bm_isInstanceOfArray(value)) {\n        sVal = sVal[axis];\n        eVal = eVal[axis];\n    }\n    var sTime = startKey.time;\n    var eTime = endKey.time;\n    if (isKeyTop(startKey, axis))\n        sO = slowOut;\n    else {\n        var prevKey = key($bm_sub(startKey.index, 1));\n        var pVal = prevKey.value;\n        if ($bm_isInstanceOfArray(value))\n            pVal = pVal[axis];\n        sOV = $bm_div($bm_sub(sVal, pVal), $bm_sub(eVal, pVal));\n    }\n    if (isKeyTop(endKey, axis)) {\n        sI = slowIn;\n        if (endKey.index != numKeys) {\n            var nextKey = key($bm_sum(endKey.index, 1));\n            var nVal = nextKey.value;\n            if ($bm_isInstanceOfArray(value))\n                nVal = nVal[axis];\n            if (Math.abs(nVal - eVal) < 0.01 && doFollowThrough)\n                sI = 1;\n        }\n    } else {\n        var nextKey = key($bm_sum(endKey.index, 1));\n        var nVal = nextKey.value;\n        if ($bm_isInstanceOfArray(value))\n            nVal = nVal[axis];\n        sIV = $bm_div($bm_sub(eVal, sVal), $bm_sub(nVal, sVal));\n    }\n    if (endKey.index == numKeys && doFollowThrough) {\n        sI = 1;\n    }\n    var val = value;\n    if ($bm_isInstanceOfArray(value))\n        val = val[axis];\n    return $bm_sub(bezierInterpolation(time, sTime, eTime, sVal, eVal, [\n        sO,\n        sOV,\n        sI,\n        sIV\n    ]), val);\n}\nfunction overlap() {\n    var ol = zeroValue;\n    if (isThisPosition && !hasParent)\n        return zeroValue;\n    ol = $bm_sub(getPropWorldValue($bm_sub(time, overlapDuration), thisProperty), getPropWorldValue(time, thisProperty));\n    var motionRatio = $bm_div($bm_div(length(zeroValue, ol), thisLayer.width), 2);\n    if (isThisPosition) {\n        var originalDistance = length(valueAtTime(0));\n        motionRatio = $bm_div(length(zeroValue, ol), thisComp.width);\n    }\n    ol = $bm_sum(ol, getPropWorldValue(time, thisProperty));\n    ol = $bm_sum(ol, $bm_mul($bm_mul($bm_sub(getPropWorldValue($bm_sub(time, overlapDuration), thisLayer.anchorPoint), ol), motionRatio), flexibility));\n    ol = thisLayer.fromWorld(ol);\n    if (!isThisPosition)\n        ol = $bm_sub(ol, value);\n    else {\n        ol = linear(flexibility, 0, 100, $bm_div(ol, 2), 0);\n        var prevParentWorldPos = getLayerWorldPos($bm_sub(time, overlapDuration), parent);\n        ol = $bm_sum(ol, $bm_mul($bm_mul($bm_mul(thisLayer.fromWorld(prevParentWorldPos), motionRatio), flexibility), 5));\n    }\n    return ol;\n}\nvar okToGo = false;\nif (simulate && fx.enabled)\n    okToGo = true;\nelse if (numKeys > 1 && fx.enabled)\n    okToGo = true;\nif (okToGo) {\n    var smartSmoothResult = zeroValue;\n    if (doInterpolation) {\n        if ($bm_isInstanceOfArray(value)) {\n            if (value.length == 2)\n                smartSmoothResult = [\n                    smartSmooth(0),\n                    smartSmooth(1)\n                ];\n            else if (value.length == 3)\n                smartSmoothResult = [\n                    smartSmooth(0),\n                    smartSmooth(1),\n                    smartSmooth(2)\n                ];\n            else if (value.length == 4)\n                smartSmoothResult = [\n                    smartSmooth(0),\n                    smartSmooth(1),\n                    smartSmooth(2),\n                    smartSmooth(3)\n                ];\n        } else {\n            smartSmoothResult = smartSmooth(0);\n        }\n    }\n    if (doAnticipation)\n        result = $bm_sum(result, anticipate());\n    result = $bm_sum(result, smartSmoothResult);\n    if (doFollowThrough)\n        result = $bm_sum(result, followThrough());\n    if (doOverlap)\n        result = $bm_sum(result, overlap());\n}\n$bm_rt = result;"
              },
              "p": { "a": 0, "k": [76.302, 16.073] },
              "a": { "a": 0, "k": [76.302, 16.073] },
              "s": { "a": 0, "k": [100.0, 100.0] },
              "nm": "Transform",
              "sk": { "a": 0, "k": 0.0 },
              "sa": { "a": 0, "k": 0.0 }
            }
          ]
        },
        {
          "ty": "gr",
          "nm": "Group 3",
          "bm": 0,
          "mn": "ADBE Vector Group",
          "it": [
            {
              "ty": "gr",
              "nm": "Group 1",
              "bm": 0,
              "mn": "ADBE Vector Group",
              "it": [
                {
                  "ty": "sh",
                  "nm": "Path 1",
                  "mn": "ADBE Vector Shape - Group",
                  "ind": 0,
                  "ks": {
                    "k": {
                      "i": [
                        [0.0, 0.0],
                        [-1.13, -7.53]
                      ],
                      "o": [
                        [1.13, 7.53],
                        [0.0, 0.0]
                      ],
                      "v": [
                        [76.84, 133.429],
                        [80.231, 156.018]
                      ],
                      "c": false
                    },
                    "a": 0
                  }
                },
                {
                  "ty": "st",
                  "nm": "Stroke 1",
                  "bm": 0,
                  "mn": "ADBE Vector Graphic - Stroke",
                  "lc": 2,
                  "lj": 2,
                  "o": { "a": 0, "k": 100.0 },
                  "w": { "a": 0, "k": 0.684 },
                  "c": { "a": 0, "k": [0.0, 0.0, 0.0, 1.0] }
                },
                {
                  "ty": "tr",
                  "o": { "a": 0, "k": 100.0 },
                  "r": { "a": 0, "k": 0.0 },
                  "p": { "a": 0, "k": [0.0, 0.0] },
                  "a": { "a": 0, "k": [0.0, 0.0] },
                  "s": { "a": 0, "k": [100.0, 100.0] },
                  "nm": "Transform",
                  "sk": { "a": 0, "k": 0.0 },
                  "sa": { "a": 0, "k": 0.0 }
                }
              ]
            },
            {
              "ty": "gr",
              "nm": "Group 2",
              "bm": 0,
              "mn": "ADBE Vector Group",
              "it": [
                {
                  "ty": "sh",
                  "nm": "Path 1",
                  "mn": "ADBE Vector Shape - Group",
                  "ind": 0,
                  "ks": {
                    "k": {
                      "i": [
                        [0.488, -4.748],
                        [0.125, 4.212],
                        [-1.301, 2.356],
                        [-0.93, 0.701],
                        [-0.979, 0.864],
                        [-1.366, 0.227],
                        [-1.305, -0.79],
                        [1.229, -1.82],
                        [0.99, -2.144]
                      ],
                      "o": [
                        [-2.794, -3.154],
                        [-0.08, -2.688],
                        [0.58, -1.05],
                        [1.045, -0.788],
                        [1.038, -0.916],
                        [1.431, -0.238],
                        [-0.661, 2.133],
                        [-1.322, 1.957],
                        [-2.001, 4.332]
                      ],
                      "v": [
                        [130.426, 79.476],
                        [125.692, 68.028],
                        [127.55, 60.262],
                        [129.668, 57.893],
                        [132.452, 55.212],
                        [136.825, 52.73],
                        [141.884, 54.072],
                        [137.687, 59.571],
                        [134.213, 65.738]
                      ],
                      "c": true
                    },
                    "a": 0
                  }
                },
                {
                  "ty": "fl",
                  "nm": "Fill 1",
                  "bm": 0,
                  "mn": "ADBE Vector Graphic - Fill",
                  "c": { "a": 0, "k": [0.0, 0.0, 0.0, 1.0] },
                  "o": { "a": 0, "k": 100.0 },
                  "r": 1
                },
                {
                  "ty": "tr",
                  "o": { "a": 0, "k": 100.0 },
                  "r": { "a": 0, "k": 0.0 },
                  "p": { "a": 0, "k": [0.0, 0.0] },
                  "a": { "a": 0, "k": [0.0, 0.0] },
                  "s": { "a": 0, "k": [100.0, 100.0] },
                  "nm": "Transform",
                  "sk": { "a": 0, "k": 0.0 },
                  "sa": { "a": 0, "k": 0.0 }
                }
              ]
            },
            {
              "ty": "gr",
              "nm": "Group 3",
              "bm": 0,
              "mn": "ADBE Vector Group",
              "it": [
                {
                  "ty": "sh",
                  "nm": "Path 1",
                  "mn": "ADBE Vector Shape - Group",
                  "ind": 0,
                  "ks": {
                    "k": {
                      "i": [
                        [-4.258, -0.927],
                        [1.82, 10.517],
                        [-4.213, -8.179],
                        [-0.028, 0.576]
                      ],
                      "o": [
                        [-6.83, -8.203],
                        [-0.487, 9.187],
                        [0.028, -0.576],
                        [3.386, 2.743]
                      ],
                      "v": [
                        [118.176, 85.435],
                        [101.218, 54.854],
                        [106.94, 81.527],
                        [107.01, 80.06]
                      ],
                      "c": true
                    },
                    "a": 0
                  }
                },
                {
                  "ty": "fl",
                  "nm": "Fill 1",
                  "bm": 0,
                  "mn": "ADBE Vector Graphic - Fill",
                  "c": { "a": 0, "k": [0.0, 0.0, 0.0, 1.0] },
                  "o": { "a": 0, "k": 100.0 },
                  "r": 1
                },
                {
                  "ty": "tr",
                  "o": { "a": 0, "k": 100.0 },
                  "r": { "a": 0, "k": 0.0 },
                  "p": { "a": 0, "k": [0.0, 0.0] },
                  "a": { "a": 0, "k": [0.0, 0.0] },
                  "s": { "a": 0, "k": [100.0, 100.0] },
                  "nm": "Transform",
                  "sk": { "a": 0, "k": 0.0 },
                  "sa": { "a": 0, "k": 0.0 }
                }
              ]
            },
            {
              "ty": "gr",
              "nm": "Group 4",
              "bm": 0,
              "mn": "ADBE Vector Group",
              "it": [
                {
                  "ty": "sh",
                  "nm": "Path 1",
                  "mn": "ADBE Vector Shape - Group",
                  "ind": 0,
                  "ks": {
                    "k": {
                      "i": [
                        [0.464, -0.004],
                        [0.448, 0.147],
                        [1.138, 0.173],
                        [1.036, -0.653],
                        [1.349, -2.18],
                        [-2.493, -4.547],
                        [-0.387, -1.146],
                        [1.499, -1.263],
                        [4.147, 5.843],
                        [2.367, -8.697],
                        [1.859, 0.734],
                        [13.7, -2.048],
                        [0.363, 1.713],
                        [-2.874, 9.904],
                        [-10.4, 6.224],
                        [-3.947, 0.269],
                        [-1.779, 2.3],
                        [-2.644, 0.896],
                        [-1.727, -0.105],
                        [-10.043, -4.635],
                        [-1.949, -2.606],
                        [0.567, -2.358]
                      ],
                      "o": [
                        [-0.232, 0.002],
                        [-1.063, -0.349],
                        [-1.254, -0.19],
                        [-2.154, 1.358],
                        [-2.629, 4.251],
                        [0.582, 1.06],
                        [0.754, 2.23],
                        [-6.063, 5.109],
                        [2.135, 3.008],
                        [-0.525, 1.929],
                        [-11.855, -4.678],
                        [-1.732, 0.259],
                        [-2.525, -11.922],
                        [3.375, -11.63],
                        [1.812, 3.517],
                        [2.917, -0.199],
                        [1.576, -2.037],
                        [1.638, -0.555],
                        [11.04, 0.671],
                        [2.955, 1.364],
                        [1.428, 1.91],
                        [-0.274, 1.142]
                      ],
                      "v": [
                        [141.749, 54.061],
                        [140.757, 53.821],
                        [137.639, 52.727],
                        [134.292, 53.927],
                        [128.689, 59.375],
                        [127.771, 75.298],
                        [129.558, 78.446],
                        [126.934, 83.207],
                        [106.551, 78.784],
                        [101.479, 110.104],
                        [97.009, 112.294],
                        [60.113, 109.676],
                        [56.38, 107.091],
                        [53.132, 64.279],
                        [73.849, 37.08],
                        [83.614, 42.587],
                        [91.055, 38.523],
                        [96.021, 32.28],
                        [101.16, 31.875],
                        [133.117, 40.072],
                        [141.01, 45.64],
                        [142.632, 52.523]
                      ],
                      "c": true
                    },
                    "a": 0
                  }
                },
                {
                  "ty": "st",
                  "nm": "Stroke 1",
                  "bm": 0,
                  "mn": "ADBE Vector Graphic - Stroke",
                  "lc": 2,
                  "lj": 2,
                  "o": { "a": 0, "k": 100.0 },
                  "w": { "a": 0, "k": 0.684 },
                  "c": { "a": 0, "k": [0.0, 0.0, 0.0, 1.0] }
                },
                {
                  "ty": "fl",
                  "nm": "Fill 1",
                  "bm": 0,
                  "mn": "ADBE Vector Graphic - Fill",
                  "c": { "a": 0, "k": [0.92549020052, 0.92549020052, 0.92549020052, 1.0] },
                  "o": { "a": 0, "k": 100.0 },
                  "r": 1
                },
                {
                  "ty": "tr",
                  "o": { "a": 0, "k": 100.0 },
                  "r": { "a": 0, "k": 0.0 },
                  "p": { "a": 0, "k": [0.0, 0.0] },
                  "a": { "a": 0, "k": [0.0, 0.0] },
                  "s": { "a": 0, "k": [100.0, 100.0] },
                  "nm": "Transform",
                  "sk": { "a": 0, "k": 0.0 },
                  "sa": { "a": 0, "k": 0.0 }
                }
              ]
            },
            {
              "ty": "gr",
              "nm": "Group 5",
              "bm": 0,
              "mn": "ADBE Vector Group",
              "it": [
                {
                  "ty": "sh",
                  "nm": "Path 1",
                  "mn": "ADBE Vector Shape - Group",
                  "ind": 0,
                  "ks": {
                    "k": {
                      "i": [
                        [0.0, 0.0],
                        [8.023, 13.749],
                        [14.874, -2.558],
                        [0.658, -19.28]
                      ],
                      "o": [
                        [1.409, -15.856],
                        [-14.769, -4.183],
                        [-5.831, 18.389],
                        [0.0, 0.0]
                      ],
                      "v": [
                        [110.896, 156.773],
                        [100.648, 110.9],
                        [56.183, 108.5],
                        [46.389, 165.358]
                      ],
                      "c": false
                    },
                    "a": 0
                  }
                },
                {
                  "ty": "st",
                  "nm": "Stroke 1",
                  "bm": 0,
                  "mn": "ADBE Vector Graphic - Stroke",
                  "lc": 2,
                  "lj": 2,
                  "o": { "a": 0, "k": 100.0 },
                  "w": { "a": 0, "k": 0.684 },
                  "c": { "a": 0, "k": [0.0, 0.0, 0.0, 1.0] }
                },
                {
                  "ty": "fl",
                  "nm": "Fill 1",
                  "bm": 0,
                  "mn": "ADBE Vector Graphic - Fill",
                  "c": { "a": 0, "k": [1.0, 1.0, 1.0, 1.0] },
                  "o": { "a": 0, "k": 100.0 },
                  "r": 1
                },
                {
                  "ty": "tr",
                  "o": { "a": 0, "k": 100.0 },
                  "r": { "a": 0, "k": 0.0 },
                  "p": { "a": 0, "k": [0.0, 0.0] },
                  "a": { "a": 0, "k": [0.0, 0.0] },
                  "s": { "a": 0, "k": [100.0, 100.0] },
                  "nm": "Transform",
                  "sk": { "a": 0, "k": 0.0 },
                  "sa": { "a": 0, "k": 0.0 }
                }
              ]
            },
            {
              "ty": "gr",
              "nm": "Group 6",
              "bm": 0,
              "mn": "ADBE Vector Group",
              "it": [
                {
                  "ty": "sh",
                  "nm": "Path 1",
                  "mn": "ADBE Vector Shape - Group",
                  "ind": 0,
                  "ks": {
                    "k": {
                      "i": [
                        [-0.107, 0.015],
                        [0.458, -0.437],
                        [0.0, 0.0],
                        [0.676, -0.822],
                        [2.775, -1.901],
                        [0.95, 0.072],
                        [0.0, 0.0],
                        [0.037, -0.021],
                        [0.0, 0.0],
                        [0.067, 0.052],
                        [0.08, 0.348],
                        [0.797, 3.329],
                        [-4.337, 0.721],
                        [0.0, 0.0],
                        [0.025, -0.022]
                      ],
                      "o": [
                        [-0.238, 0.336],
                        [1.7, 1.873],
                        [-0.586, 0.888],
                        [-2.121, 2.612],
                        [-0.648, 0.446],
                        [0.0, 0.0],
                        [-0.037, 0.021],
                        [0.0, 0.0],
                        [-0.093, -0.019],
                        [-0.278, -0.222],
                        [-0.798, -3.317],
                        [3.874, 1.037],
                        [0.0, 0.0],
                        [-0.013, 0.023],
                        [0.119, -0.014]
                      ],
                      "v": [
                        [87.248, 12.43],
                        [87.891, 15.474],
                        [87.891, 15.474],
                        [84.274, 19.845],
                        [76.878, 26.67],
                        [73.132, 28.769],
                        [73.12, 28.768],
                        [73.021, 28.831],
                        [73.097, 28.766],
                        [72.857, 28.665],
                        [72.4, 26.755],
                        [69.992, 13.138],
                        [86.865, 12.496],
                        [86.954, 12.408],
                        [86.901, 12.487]
                      ],
                      "c": true
                    },
                    "a": 0
                  }
                },
                {
                  "ty": "fl",
                  "nm": "Fill 1",
                  "bm": 0,
                  "mn": "ADBE Vector Graphic - Fill",
                  "c": { "a": 0, "k": [0.0, 0.0, 0.0, 1.0] },
                  "o": { "a": 0, "k": 100.0 },
                  "r": 1
                },
                {
                  "ty": "tr",
                  "o": { "a": 0, "k": 100.0 },
                  "r": { "a": 0, "k": 0.0 },
                  "p": { "a": 0, "k": [0.0, 0.0] },
                  "a": { "a": 0, "k": [0.0, 0.0] },
                  "s": { "a": 0, "k": [100.0, 100.0] },
                  "nm": "Transform",
                  "sk": { "a": 0, "k": 0.0 },
                  "sa": { "a": 0, "k": 0.0 }
                }
              ]
            },
            {
              "ty": "gr",
              "nm": "Group 7",
              "bm": 0,
              "mn": "ADBE Vector Group",
              "it": [
                {
                  "ty": "sh",
                  "nm": "Path 1",
                  "mn": "ADBE Vector Shape - Group",
                  "ind": 0,
                  "ks": {
                    "k": {
                      "i": [
                        [0.0, 0.0],
                        [0.0, 0.0],
                        [0.0, 0.0],
                        [0.0, 0.0],
                        [-4.196, 0.72],
                        [-1.133, 0.315],
                        [-0.411, 0.134]
                      ],
                      "o": [
                        [0.0, 0.0],
                        [0.0, 0.0],
                        [0.0, 0.0],
                        [3.989, 1.07],
                        [1.171, -0.194],
                        [0.422, -0.121],
                        [0.0, 0.0]
                      ],
                      "v": [
                        [93.458, 41.926],
                        [76.982, 45.879],
                        [72.349, 26.555],
                        [69.996, 13.144],
                        [82.529, 13.576],
                        [85.996, 12.812],
                        [87.252, 12.436]
                      ],
                      "c": true
                    },
                    "a": 0
                  }
                },
                {
                  "ty": "st",
                  "nm": "Stroke 1",
                  "bm": 0,
                  "mn": "ADBE Vector Graphic - Stroke",
                  "lc": 2,
                  "lj": 2,
                  "o": { "a": 0, "k": 100.0 },
                  "w": { "a": 0, "k": 0.684 },
                  "c": { "a": 0, "k": [0.0, 0.0, 0.0, 1.0] }
                },
                {
                  "ty": "fl",
                  "nm": "Fill 1",
                  "bm": 0,
                  "mn": "ADBE Vector Graphic - Fill",
                  "c": { "a": 0, "k": [1.0, 1.0, 1.0, 1.0] },
                  "o": { "a": 0, "k": 100.0 },
                  "r": 1
                },
                {
                  "ty": "tr",
                  "o": { "a": 0, "k": 100.0 },
                  "r": { "a": 0, "k": 0.0 },
                  "p": { "a": 0, "k": [0.0, 0.0] },
                  "a": { "a": 0, "k": [0.0, 0.0] },
                  "s": { "a": 0, "k": [100.0, 100.0] },
                  "nm": "Transform",
                  "sk": { "a": 0, "k": 0.0 },
                  "sa": { "a": 0, "k": 0.0 }
                }
              ]
            },
            {
              "ty": "gr",
              "nm": "Group 8",
              "bm": 0,
              "mn": "ADBE Vector Group",
              "it": [
                {
                  "ty": "sh",
                  "nm": "Path 1",
                  "mn": "ADBE Vector Shape - Group",
                  "ind": 0,
                  "ks": {
                    "k": {
                      "i": [
                        [1.775, -5.926],
                        [-6.331, -8.719],
                        [-16.928, 11.354],
                        [1.109, -0.235],
                        [1.21, -0.645],
                        [2.286, -2.147]
                      ],
                      "o": [
                        [-3.092, 10.322],
                        [-5.014, -19.757],
                        [-0.932, 0.625],
                        [-1.345, 0.286],
                        [-2.768, 1.475],
                        [-4.502, 4.23]
                      ],
                      "v": [
                        [48.591, 60.074],
                        [53.822, 90.833],
                        [74.343, 37.252],
                        [69.783, 37.381],
                        [65.916, 39.053],
                        [58.3, 44.527]
                      ],
                      "c": true
                    },
                    "a": 0
                  }
                },
                {
                  "ty": "fl",
                  "nm": "Fill 1",
                  "bm": 0,
                  "mn": "ADBE Vector Graphic - Fill",
                  "c": { "a": 0, "k": [0.0, 0.0, 0.0, 1.0] },
                  "o": { "a": 0, "k": 100.0 },
                  "r": 1
                },
                {
                  "ty": "tr",
                  "o": { "a": 0, "k": 100.0 },
                  "r": { "a": 0, "k": 0.0 },
                  "p": { "a": 0, "k": [0.0, 0.0] },
                  "a": { "a": 0, "k": [0.0, 0.0] },
                  "s": { "a": 0, "k": [100.0, 100.0] },
                  "nm": "Transform",
                  "sk": { "a": 0, "k": 0.0 },
                  "sa": { "a": 0, "k": 0.0 }
                }
              ]
            },
            {
              "ty": "gr",
              "nm": "Group 9",
              "bm": 0,
              "mn": "ADBE Vector Group",
              "it": [
                {
                  "ty": "sh",
                  "nm": "Path 1",
                  "mn": "ADBE Vector Shape - Group",
                  "ind": 0,
                  "ks": {
                    "k": {
                      "i": [
                        [1.929, -3.8],
                        [0.541, -0.929],
                        [2.965, -3.082],
                        [2.377, -1.647],
                        [2.765, -0.965],
                        [3.541, 0.318],
                        [2.061, 0.919],
                        [1.861, 2.995],
                        [-0.193, 1.238],
                        [-0.74, 1.279],
                        [1.837, 7.26],
                        [-2.287, 3.011],
                        [-1.933, 0.835],
                        [-11.502, -3.861],
                        [-0.614, -1.298],
                        [-1.374, -1.264],
                        [-0.801, -2.672]
                      ],
                      "o": [
                        [-0.494, 0.965],
                        [-2.153, 3.682],
                        [-2.0, 2.082],
                        [-2.412, 1.682],
                        [-3.376, 1.188],
                        [-2.235, -0.212],
                        [-3.217, -1.435],
                        [-0.618, -0.995],
                        [0.216, -1.382],
                        [3.74, -6.463],
                        [-0.836, -3.297],
                        [1.274, -1.677],
                        [11.024, -4.762],
                        [-0.677, 1.08],
                        [0.818, 1.728],
                        [2.077, 1.911],
                        [1.294, 4.317]
                      ],
                      "v": [
                        [77.007, 69.661],
                        [75.466, 72.496],
                        [67.76, 82.696],
                        [61.196, 88.343],
                        [53.419, 92.378],
                        [42.843, 93.754],
                        [36.359, 92.083],
                        [28.473, 85.245],
                        [26.585, 80.83],
                        [29.741, 76.195],
                        [32.858, 54.536],
                        [32.386, 43.336],
                        [37.546, 39.818],
                        [73.632, 37.619],
                        [73.683, 42.355],
                        [77.513, 46.649],
                        [81.607, 54.155]
                      ],
                      "c": true
                    },
                    "a": 0
                  }
                },
                {
                  "ty": "st",
                  "nm": "Stroke 1",
                  "bm": 0,
                  "mn": "ADBE Vector Graphic - Stroke",
                  "lc": 2,
                  "lj": 2,
                  "o": { "a": 0, "k": 100.0 },
                  "w": { "a": 0, "k": 0.684 },
                  "c": { "a": 0, "k": [0.0, 0.0, 0.0, 1.0] }
                },
                {
                  "ty": "fl",
                  "nm": "Fill 1",
                  "bm": 0,
                  "mn": "ADBE Vector Graphic - Fill",
                  "c": { "a": 0, "k": [0.92549020052, 0.92549020052, 0.92549020052, 1.0] },
                  "o": { "a": 0, "k": 100.0 },
                  "r": 1
                },
                {
                  "ty": "tr",
                  "o": { "a": 0, "k": 100.0 },
                  "r": { "a": 0, "k": 0.0 },
                  "p": { "a": 0, "k": [0.0, 0.0] },
                  "a": { "a": 0, "k": [0.0, 0.0] },
                  "s": { "a": 0, "k": [100.0, 100.0] },
                  "nm": "Transform",
                  "sk": { "a": 0, "k": 0.0 },
                  "sa": { "a": 0, "k": 0.0 }
                }
              ]
            },
            {
              "ty": "gr",
              "nm": "Group 10",
              "bm": 0,
              "mn": "ADBE Vector Group",
              "it": [
                {
                  "ty": "sh",
                  "nm": "Path 1",
                  "mn": "ADBE Vector Shape - Group",
                  "ind": 0,
                  "ks": {
                    "k": {
                      "i": [[0.0, 0.0]],
                      "o": [[0.0, 0.0]],
                      "v": [[139.996, 110.252]],
                      "c": false
                    },
                    "a": 0
                  }
                },
                {
                  "ty": "st",
                  "nm": "Stroke 1",
                  "bm": 0,
                  "mn": "ADBE Vector Graphic - Stroke",
                  "lc": 2,
                  "lj": 2,
                  "o": { "a": 0, "k": 100.0 },
                  "w": { "a": 0, "k": 0.684 },
                  "c": { "a": 0, "k": [0.0, 0.0, 0.0, 1.0] }
                },
                {
                  "ty": "fl",
                  "nm": "Fill 1",
                  "bm": 0,
                  "mn": "ADBE Vector Graphic - Fill",
                  "c": { "a": 0, "k": [1.0, 1.0, 1.0, 1.0] },
                  "o": { "a": 0, "k": 100.0 },
                  "r": 1
                },
                {
                  "ty": "tr",
                  "o": { "a": 0, "k": 100.0 },
                  "r": { "a": 0, "k": 0.0 },
                  "p": { "a": 0, "k": [0.0, 0.0] },
                  "a": { "a": 0, "k": [0.0, 0.0] },
                  "s": { "a": 0, "k": [100.0, 100.0] },
                  "nm": "Transform",
                  "sk": { "a": 0, "k": 0.0 },
                  "sa": { "a": 0, "k": 0.0 }
                }
              ]
            },
            {
              "ty": "tr",
              "o": { "a": 0, "k": 100.0 },
              "r": { "a": 0, "k": 0.0 },
              "p": { "a": 0, "k": [0.0, 0.0] },
              "a": { "a": 0, "k": [0.0, 0.0] },
              "s": { "a": 0, "k": [100.0, 100.0] },
              "nm": "Transform",
              "sk": { "a": 0, "k": 0.0 },
              "sa": { "a": 0, "k": 0.0 }
            }
          ]
        },
        {
          "ty": "gr",
          "nm": "Group 5",
          "bm": 0,
          "mn": "ADBE Vector Group",
          "it": [
            {
              "ty": "gr",
              "nm": "Group 1",
              "bm": 0,
              "mn": "ADBE Vector Group",
              "it": [
                {
                  "ty": "gr",
                  "nm": "Group 1",
                  "bm": 0,
                  "mn": "ADBE Vector Group",
                  "it": [
                    {
                      "ty": "sh",
                      "nm": "Path 1",
                      "mn": "ADBE Vector Shape - Group",
                      "ind": 0,
                      "ks": {
                        "k": {
                          "i": [[0.0, 0.0]],
                          "o": [[0.0, 0.0]],
                          "v": [[142.157, 129.087]],
                          "c": false
                        },
                        "a": 0
                      }
                    },
                    {
                      "ty": "st",
                      "nm": "Stroke 1",
                      "bm": 0,
                      "mn": "ADBE Vector Graphic - Stroke",
                      "lc": 2,
                      "lj": 2,
                      "o": { "a": 0, "k": 100.0 },
                      "w": { "a": 0, "k": 0.684 },
                      "c": { "a": 0, "k": [0.0, 0.0, 0.0, 1.0] }
                    },
                    {
                      "ty": "fl",
                      "nm": "Fill 1",
                      "bm": 0,
                      "mn": "ADBE Vector Graphic - Fill",
                      "c": { "a": 0, "k": [1.0, 1.0, 1.0, 1.0] },
                      "o": { "a": 0, "k": 100.0 },
                      "r": 1
                    },
                    {
                      "ty": "tr",
                      "o": { "a": 0, "k": 100.0 },
                      "r": { "a": 0, "k": 0.0 },
                      "p": { "a": 0, "k": [0.0, 0.0] },
                      "a": { "a": 0, "k": [0.0, 0.0] },
                      "s": { "a": 0, "k": [100.0, 100.0] },
                      "nm": "Transform",
                      "sk": { "a": 0, "k": 0.0 },
                      "sa": { "a": 0, "k": 0.0 }
                    }
                  ]
                },
                {
                  "ty": "gr",
                  "nm": "Group 2",
                  "bm": 0,
                  "mn": "ADBE Vector Group",
                  "it": [
                    {
                      "ty": "sh",
                      "nm": "Path 1",
                      "mn": "ADBE Vector Shape - Group",
                      "ind": 0,
                      "ks": {
                        "k": {
                          "i": [
                            [0.0, 0.0],
                            [0.232, -0.951],
                            [0.011, -0.204],
                            [-2.428, 2.578],
                            [-0.411, 1.228],
                            [-1.182, 3.947],
                            [-0.057, 0.184],
                            [-0.66, 2.19],
                            [-0.195, 0.525],
                            [-0.008, 0.013],
                            [-0.19, 0.456],
                            [-0.002, 0.01],
                            [-0.29, 0.807],
                            [-0.879, 1.996],
                            [-1.742, 4.211],
                            [-2.181, 5.507],
                            [-0.784, 2.138],
                            [-0.18, 1.15],
                            [0.0, 0.0],
                            [0.0, 0.0],
                            [1.252, -1.837],
                            [1.231, -4.581],
                            [0.489, -0.891],
                            [4.75, -1.514],
                            [0.945, -4.382],
                            [-0.843, -0.797],
                            [-0.94, 0.42],
                            [-0.708, 0.748]
                          ],
                          "o": [
                            [-0.396, 0.808],
                            [-0.054, 0.215],
                            [-0.176, 3.495],
                            [0.875, -0.92],
                            [1.291, -3.851],
                            [0.053, -0.19],
                            [0.651, -2.126],
                            [0.161, -0.528],
                            [0.002, -0.01],
                            [0.174, -0.455],
                            [0.002, -0.01],
                            [0.324, -0.804],
                            [0.742, -2.064],
                            [1.836, -4.171],
                            [2.265, -5.473],
                            [0.838, -2.117],
                            [0.398, -1.085],
                            [0.518, -3.312],
                            [0.0, 0.0],
                            [0.0, 0.0],
                            [-1.124, 1.649],
                            [-0.264, 0.982],
                            [-2.422, 4.412],
                            [-4.22, 1.345],
                            [-0.245, 1.134],
                            [0.748, 0.707],
                            [0.94, -0.42],
                            [0.0, 0.0]
                          ],
                          "v": [
                            [143.529, 145.82],
                            [142.334, 148.584],
                            [142.232, 149.207],
                            [147.333, 151.544],
                            [148.958, 148.132],
                            [152.279, 136.417],
                            [152.44, 135.864],
                            [154.424, 129.129],
                            [154.958, 127.561],
                            [154.97, 127.529],
                            [155.512, 126.169],
                            [155.524, 126.137],
                            [156.469, 123.72],
                            [159.48, 117.922],
                            [164.746, 105.296],
                            [171.443, 88.837],
                            [173.898, 82.463],
                            [174.994, 79.08],
                            [130.912, 51.266],
                            [120.926, 70.684],
                            [146.543, 86.459],
                            [138.124, 115.141],
                            [137.326, 117.084],
                            [126.515, 125.715],
                            [117.898, 134.94],
                            [118.475, 138.214],
                            [121.372, 138.509],
                            [123.752, 136.574]
                          ],
                          "c": false
                        },
                        "a": 0
                      }
                    },
                    {
                      "ty": "st",
                      "nm": "Stroke 1",
                      "bm": 0,
                      "mn": "ADBE Vector Graphic - Stroke",
                      "lc": 2,
                      "lj": 2,
                      "o": { "a": 0, "k": 100.0 },
                      "w": { "a": 0, "k": 0.684 },
                      "c": { "a": 0, "k": [0.0, 0.0, 0.0, 1.0] }
                    },
                    {
                      "ty": "fl",
                      "nm": "Fill 1",
                      "bm": 0,
                      "mn": "ADBE Vector Graphic - Fill",
                      "c": { "a": 0, "k": [1.0, 1.0, 1.0, 1.0] },
                      "o": { "a": 0, "k": 100.0 },
                      "r": 1
                    },
                    {
                      "ty": "tr",
                      "o": { "a": 0, "k": 100.0 },
                      "r": { "a": 0, "k": 0.0 },
                      "p": { "a": 0, "k": [0.0, 0.0] },
                      "a": { "a": 0, "k": [0.0, 0.0] },
                      "s": { "a": 0, "k": [100.0, 100.0] },
                      "nm": "Transform",
                      "sk": { "a": 0, "k": 0.0 },
                      "sa": { "a": 0, "k": 0.0 }
                    }
                  ]
                },
                {
                  "ty": "gr",
                  "nm": "Group 3",
                  "bm": 0,
                  "mn": "ADBE Vector Group",
                  "it": [
                    {
                      "ty": "sh",
                      "nm": "Path 1",
                      "mn": "ADBE Vector Shape - Group",
                      "ind": 0,
                      "ks": {
                        "k": {
                          "i": [
                            [0.0, 0.0],
                            [0.081, -0.355],
                            [0.008, -0.013],
                            [-0.042, -0.68],
                            [-0.86, -0.675],
                            [-1.168, 0.743],
                            [-0.443, 1.281],
                            [-0.239, 0.586],
                            [0.0, 0.0],
                            [-0.448, 1.013]
                          ],
                          "o": [
                            [-0.075, 0.351],
                            [-0.002, 0.01],
                            [-0.151, 0.662],
                            [0.057, 1.057],
                            [1.062, 0.827],
                            [1.168, -0.742],
                            [0.203, -0.579],
                            [-0.004, -0.006],
                            [0.429, -1.042],
                            [0.0, 0.0]
                          ],
                          "v": [
                            [135.547, 147.562],
                            [135.303, 148.611],
                            [135.29, 148.643],
                            [135.055, 150.647],
                            [136.257, 153.473],
                            [139.774, 153.644],
                            [141.658, 150.332],
                            [142.334, 148.584],
                            [142.336, 148.575],
                            [143.692, 145.479]
                          ],
                          "c": false
                        },
                        "a": 0
                      }
                    },
                    {
                      "ty": "st",
                      "nm": "Stroke 1",
                      "bm": 0,
                      "mn": "ADBE Vector Graphic - Stroke",
                      "lc": 2,
                      "lj": 2,
                      "o": { "a": 0, "k": 100.0 },
                      "w": { "a": 0, "k": 0.684 },
                      "c": { "a": 0, "k": [0.0, 0.0, 0.0, 1.0] }
                    },
                    {
                      "ty": "fl",
                      "nm": "Fill 1",
                      "bm": 0,
                      "mn": "ADBE Vector Graphic - Fill",
                      "c": { "a": 0, "k": [1.0, 1.0, 1.0, 1.0] },
                      "o": { "a": 0, "k": 100.0 },
                      "r": 1
                    },
                    {
                      "ty": "tr",
                      "o": { "a": 0, "k": 100.0 },
                      "r": { "a": 0, "k": 0.0 },
                      "p": { "a": 0, "k": [0.0, 0.0] },
                      "a": { "a": 0, "k": [0.0, 0.0] },
                      "s": { "a": 0, "k": [100.0, 100.0] },
                      "nm": "Transform",
                      "sk": { "a": 0, "k": 0.0 },
                      "sa": { "a": 0, "k": 0.0 }
                    }
                  ]
                },
                {
                  "ty": "gr",
                  "nm": "Group 4",
                  "bm": 0,
                  "mn": "ADBE Vector Group",
                  "it": [
                    {
                      "ty": "sh",
                      "nm": "Path 1",
                      "mn": "ADBE Vector Shape - Group",
                      "ind": 0,
                      "ks": {
                        "k": {
                          "i": [
                            [0.0, 0.0],
                            [0.24, -0.808],
                            [0.211, -0.618],
                            [0.008, -0.013],
                            [0.476, -0.759],
                            [1.27, -0.371],
                            [0.792, 1.063],
                            [0.067, 0.147],
                            [-0.129, 0.788],
                            [-0.413, 0.859]
                          ],
                          "o": [
                            [-0.316, 0.79],
                            [-0.191, 0.637],
                            [-0.002, 0.01],
                            [-0.289, 0.847],
                            [-0.699, 1.122],
                            [-1.27, 0.371],
                            [-0.097, -0.128],
                            [-0.359, -0.702],
                            [0.154, -0.943],
                            [0.0, 0.0]
                          ],
                          "v": [
                            [136.679, 144.32],
                            [135.883, 146.726],
                            [135.303, 148.611],
                            [135.29, 148.643],
                            [134.178, 151.068],
                            [131.185, 153.532],
                            [127.609, 152.495],
                            [127.365, 152.082],
                            [127.068, 149.755],
                            [127.996, 146.214]
                          ],
                          "c": false
                        },
                        "a": 0
                      }
                    },
                    {
                      "ty": "st",
                      "nm": "Stroke 1",
                      "bm": 0,
                      "mn": "ADBE Vector Graphic - Stroke",
                      "lc": 2,
                      "lj": 2,
                      "o": { "a": 0, "k": 100.0 },
                      "w": { "a": 0, "k": 0.684 },
                      "c": { "a": 0, "k": [0.0, 0.0, 0.0, 1.0] }
                    },
                    {
                      "ty": "fl",
                      "nm": "Fill 1",
                      "bm": 0,
                      "mn": "ADBE Vector Graphic - Fill",
                      "c": { "a": 0, "k": [1.0, 1.0, 1.0, 1.0] },
                      "o": { "a": 0, "k": 100.0 },
                      "r": 1
                    },
                    {
                      "ty": "tr",
                      "o": { "a": 0, "k": 100.0 },
                      "r": { "a": 0, "k": 0.0 },
                      "p": { "a": 0, "k": [0.0, 0.0] },
                      "a": { "a": 0, "k": [0.0, 0.0] },
                      "s": { "a": 0, "k": [100.0, 100.0] },
                      "nm": "Transform",
                      "sk": { "a": 0, "k": 0.0 },
                      "sa": { "a": 0, "k": 0.0 }
                    }
                  ]
                },
                {
                  "ty": "gr",
                  "nm": "Group 5",
                  "bm": 0,
                  "mn": "ADBE Vector Group",
                  "it": [
                    {
                      "ty": "sh",
                      "nm": "Path 1",
                      "mn": "ADBE Vector Shape - Group",
                      "ind": 0,
                      "ks": {
                        "k": {
                          "i": [
                            [0.0, 0.0],
                            [1.0, -1.785],
                            [0.961, -1.628],
                            [-1.082, -2.104],
                            [-0.755, -0.388],
                            [-1.371, 0.47],
                            [-0.611, 1.315],
                            [0.057, -0.522]
                          ],
                          "o": [
                            [-1.234, 1.641],
                            [-0.924, 1.65],
                            [-1.022, 1.733],
                            [0.388, 0.755],
                            [1.29, 0.663],
                            [1.371, -0.47],
                            [-0.057, 0.522],
                            [0.0, 0.0]
                          ],
                          "v": [
                            [125.8, 133.589],
                            [122.653, 138.914],
                            [119.828, 143.833],
                            [117.647, 149.901],
                            [119.463, 151.626],
                            [123.685, 151.931],
                            [126.83, 149.099],
                            [126.659, 150.665]
                          ],
                          "c": false
                        },
                        "a": 0
                      }
                    },
                    {
                      "ty": "st",
                      "nm": "Stroke 1",
                      "bm": 0,
                      "mn": "ADBE Vector Graphic - Stroke",
                      "lc": 2,
                      "lj": 2,
                      "o": { "a": 0, "k": 100.0 },
                      "w": { "a": 0, "k": 0.684 },
                      "c": { "a": 0, "k": [0.0, 0.0, 0.0, 1.0] }
                    },
                    {
                      "ty": "fl",
                      "nm": "Fill 1",
                      "bm": 0,
                      "mn": "ADBE Vector Graphic - Fill",
                      "c": { "a": 0, "k": [1.0, 1.0, 1.0, 1.0] },
                      "o": { "a": 0, "k": 100.0 },
                      "r": 1
                    },
                    {
                      "ty": "tr",
                      "o": { "a": 0, "k": 100.0 },
                      "r": { "a": 0, "k": 0.0 },
                      "p": { "a": 0, "k": [0.0, 0.0] },
                      "a": { "a": 0, "k": [0.0, 0.0] },
                      "s": { "a": 0, "k": [100.0, 100.0] },
                      "nm": "Transform",
                      "sk": { "a": 0, "k": 0.0 },
                      "sa": { "a": 0, "k": 0.0 }
                    }
                  ]
                },
                {
                  "ty": "tr",
                  "o": { "a": 0, "k": 100.0 },
                  "r": { "a": 0, "k": 0.0 },
                  "p": { "a": 0, "k": [0.0, 0.0] },
                  "a": { "a": 0, "k": [0.0, 0.0] },
                  "s": { "a": 0, "k": [100.0, 100.0] },
                  "nm": "Transform",
                  "sk": { "a": 0, "k": 0.0 },
                  "sa": { "a": 0, "k": 0.0 }
                }
              ]
            },
            {
              "ty": "gr",
              "nm": "Group 2",
              "bm": 0,
              "mn": "ADBE Vector Group",
              "it": [
                {
                  "ty": "gr",
                  "nm": "Group 1",
                  "bm": 0,
                  "mn": "ADBE Vector Group",
                  "it": [
                    {
                      "ty": "sh",
                      "nm": "Path 1",
                      "mn": "ADBE Vector Shape - Group",
                      "ind": 0,
                      "ks": {
                        "k": {
                          "i": [[0.0, 0.0]],
                          "o": [[0.0, 0.0]],
                          "v": [[142.157, 129.087]],
                          "c": true
                        },
                        "a": 0
                      }
                    },
                    {
                      "ty": "fl",
                      "nm": "Fill 1",
                      "bm": 0,
                      "mn": "ADBE Vector Graphic - Fill",
                      "c": { "a": 0, "k": [1.0, 1.0, 1.0, 1.0] },
                      "o": { "a": 0, "k": 100.0 },
                      "r": 1
                    },
                    {
                      "ty": "tr",
                      "o": { "a": 0, "k": 100.0 },
                      "r": { "a": 0, "k": 0.0 },
                      "p": { "a": 0, "k": [0.0, 0.0] },
                      "a": { "a": 0, "k": [0.0, 0.0] },
                      "s": { "a": 0, "k": [100.0, 100.0] },
                      "nm": "Transform",
                      "sk": { "a": 0, "k": 0.0 },
                      "sa": { "a": 0, "k": 0.0 }
                    }
                  ]
                },
                {
                  "ty": "gr",
                  "nm": "Group 2",
                  "bm": 0,
                  "mn": "ADBE Vector Group",
                  "it": [
                    {
                      "ty": "sh",
                      "nm": "Path 1",
                      "mn": "ADBE Vector Shape - Group",
                      "ind": 0,
                      "ks": {
                        "k": {
                          "i": [
                            [0.51, -3.31],
                            [0.4, -1.08],
                            [0.83, -2.12],
                            [2.26, -5.48],
                            [1.84, -4.17],
                            [0.74, -2.06],
                            [0.32, -0.81],
                            [0.01, -0.01],
                            [0.18, -0.45],
                            [0.0, -0.01],
                            [0.16, -0.53],
                            [0.65, -2.12],
                            [0.05, -0.19],
                            [1.29, -3.85],
                            [0.87, -0.92],
                            [-0.17, 3.49],
                            [-0.06, 0.21],
                            [0.2, -0.58],
                            [1.16, -0.75],
                            [1.06, 0.83],
                            [0.05, 1.06],
                            [-0.15, 0.67],
                            [0.48, -0.76],
                            [1.27, -0.37],
                            [0.79, 1.06],
                            [0.06, 0.15],
                            [-0.13, 0.78],
                            [0.1, 0.18],
                            [0.0, 0.0],
                            [0.04, -0.07],
                            [1.21, -0.42],
                            [1.28, 0.66],
                            [0.39, 0.76],
                            [-1.02, 1.74],
                            [-0.92, 1.65],
                            [-0.42, 0.75],
                            [0.0, 0.0],
                            [0.94, -0.42],
                            [0.75, 0.7],
                            [-0.24, 1.14],
                            [-4.22, 1.34],
                            [-2.42, 4.41],
                            [-0.27, 0.98],
                            [-1.13, 1.65],
                            [0.0, 0.0],
                            [0.0, 0.0]
                          ],
                          "o": [
                            [-0.18, 1.15],
                            [-0.78, 2.14],
                            [-2.19, 5.51],
                            [-1.74, 4.21],
                            [-0.88, 2.0],
                            [-0.29, 0.81],
                            [-0.01, 0.01],
                            [-0.19, 0.46],
                            [-0.01, 0.01],
                            [-0.2, 0.53],
                            [-0.66, 2.19],
                            [-0.05, 0.19],
                            [-1.18, 3.94],
                            [-0.41, 1.23],
                            [-2.43, 2.57],
                            [0.02, -0.21],
                            [-0.24, 0.58],
                            [-0.44, 1.28],
                            [-1.17, 0.74],
                            [-0.86, -0.67],
                            [-0.04, -0.68],
                            [-0.29, 0.85],
                            [-0.7, 1.12],
                            [-1.27, 0.38],
                            [-0.1, -0.13],
                            [-0.36, -0.7],
                            [-0.02, 0.25],
                            [0.0, 0.0],
                            [-0.1, -0.1],
                            [-0.65, 1.1],
                            [-1.37, 0.47],
                            [-0.76, -0.39],
                            [-1.08, -2.1],
                            [0.96, -1.62],
                            [0.42, -0.74],
                            [0.0, 0.0],
                            [-0.7, 0.74],
                            [-0.94, 0.42],
                            [-0.85, -0.8],
                            [0.95, -4.38],
                            [4.75, -1.52],
                            [0.49, -0.9],
                            [1.23, -4.58],
                            [1.25, -1.84],
                            [0.0, 0.0],
                            [0.0, 0.0]
                          ],
                          "v": [
                            [174.998, 79.079],
                            [173.898, 82.459],
                            [171.448, 88.839],
                            [164.748, 105.299],
                            [159.478, 117.919],
                            [156.468, 123.719],
                            [155.528, 126.139],
                            [155.508, 126.169],
                            [154.968, 127.529],
                            [154.958, 127.559],
                            [154.428, 129.129],
                            [152.438, 135.859],
                            [152.278, 136.419],
                            [148.958, 148.129],
                            [147.338, 151.549],
                            [142.228, 149.209],
                            [142.338, 148.589],
                            [141.658, 150.329],
                            [139.778, 153.649],
                            [136.258, 153.469],
                            [135.058, 150.649],
                            [135.288, 148.639],
                            [134.178, 151.069],
                            [131.188, 153.529],
                            [127.608, 152.499],
                            [127.368, 152.079],
                            [127.068, 149.759],
                            [126.848, 149.669],
                            [126.838, 149.659],
                            [126.598, 149.539],
                            [123.688, 151.929],
                            [119.468, 151.629],
                            [117.648, 149.899],
                            [119.828, 143.829],
                            [122.648, 138.909],
                            [123.888, 136.649],
                            [123.748, 136.579],
                            [121.368, 138.509],
                            [118.478, 138.219],
                            [117.898, 134.939],
                            [126.518, 125.719],
                            [137.328, 117.089],
                            [138.128, 115.139],
                            [146.548, 86.459],
                            [120.928, 70.689],
                            [130.908, 51.269]
                          ],
                          "c": true
                        },
                        "a": 0
                      }
                    },
                    {
                      "ty": "fl",
                      "nm": "Fill 1",
                      "bm": 0,
                      "mn": "ADBE Vector Graphic - Fill",
                      "c": { "a": 0, "k": [1.0, 1.0, 1.0, 1.0] },
                      "o": { "a": 0, "k": 100.0 },
                      "r": 1
                    },
                    {
                      "ty": "tr",
                      "o": { "a": 0, "k": 100.0 },
                      "r": { "a": 0, "k": 0.0 },
                      "p": { "a": 0, "k": [0.0, 0.0] },
                      "a": { "a": 0, "k": [0.0, 0.0] },
                      "s": { "a": 0, "k": [100.0, 100.0] },
                      "nm": "Transform",
                      "sk": { "a": 0, "k": 0.0 },
                      "sa": { "a": 0, "k": 0.0 }
                    }
                  ]
                },
                {
                  "ty": "tr",
                  "o": { "a": 0, "k": 100.0 },
                  "r": { "a": 0, "k": 0.0 },
                  "p": { "a": 0, "k": [0.0, 0.0] },
                  "a": { "a": 0, "k": [0.0, 0.0] },
                  "s": { "a": 0, "k": [100.0, 100.0] },
                  "nm": "Transform",
                  "sk": { "a": 0, "k": 0.0 },
                  "sa": { "a": 0, "k": 0.0 }
                }
              ]
            },
            {
              "ty": "tr",
              "o": { "a": 0, "k": 100.0 },
              "r": {
                "a": 1,
                "k": [
                  {
                    "i": { "x": [0.667], "y": [1] },
                    "o": { "x": [0.333], "y": [0] },
                    "t": 32,
                    "s": [2.0]
                  },
                  {
                    "i": { "x": [0.667], "y": [1] },
                    "o": { "x": [0.333], "y": [0] },
                    "t": 43,
                    "s": [-15.0]
                  },
                  {
                    "i": { "x": [0.667], "y": [1] },
                    "o": { "x": [0.333], "y": [0] },
                    "t": 53,
                    "s": [2.0]
                  },
                  {
                    "i": { "x": [0.667], "y": [1] },
                    "o": { "x": [0.333], "y": [0] },
                    "t": 64,
                    "s": [-15.0]
                  },
                  {
                    "i": { "x": [0.667], "y": [1] },
                    "o": { "x": [0.333], "y": [0] },
                    "t": 74,
                    "s": [2.0]
                  },
                  {
                    "i": { "x": [0.833], "y": [1] },
                    "o": { "x": [0.167], "y": [0] },
                    "t": 85,
                    "s": [-15.0]
                  },
                  { "t": 95, "s": [2.0] }
                ]
              },
              "p": { "a": 0, "k": [131.5, 52.0] },
              "a": { "a": 0, "k": [131.5, 52.0] },
              "s": { "a": 0, "k": [100.0, 100.0] },
              "nm": "Transform",
              "sk": { "a": 0, "k": 0.0 },
              "sa": { "a": 0, "k": 0.0 }
            }
          ]
        },
        {
          "ty": "gr",
          "nm": "Group 7",
          "bm": 0,
          "mn": "ADBE Vector Group",
          "it": [
            {
              "ty": "gr",
              "nm": "Group 1",
              "bm": 0,
              "mn": "ADBE Vector Group",
              "it": [
                {
                  "ty": "gr",
                  "nm": "Group 1",
                  "bm": 0,
                  "mn": "ADBE Vector Group",
                  "it": [
                    {
                      "ty": "sh",
                      "nm": "Path 1",
                      "mn": "ADBE Vector Shape - Group",
                      "ind": 0,
                      "ks": {
                        "k": {
                          "i": [
                            [0.0, -1.794],
                            [2.15, 0.0],
                            [0.0, 1.794],
                            [-2.15, 0.0]
                          ],
                          "o": [
                            [0.0, 1.794],
                            [-2.15, 0.0],
                            [0.0, -1.794],
                            [2.15, 0.0]
                          ],
                          "v": [
                            [-111.926, -5.505],
                            [-115.82, -2.256],
                            [-119.713, -5.505],
                            [-115.82, -8.754]
                          ],
                          "c": true
                        },
                        "a": 0
                      }
                    },
                    {
                      "ty": "fl",
                      "nm": "Fill 1",
                      "bm": 0,
                      "mn": "ADBE Vector Graphic - Fill",
                      "c": { "a": 0, "k": [0.0, 0.0, 0.0, 1.0] },
                      "o": { "a": 0, "k": 100.0 },
                      "r": 1
                    },
                    {
                      "ty": "tr",
                      "o": { "a": 0, "k": 100.0 },
                      "r": { "a": 0, "k": 0.0 },
                      "p": { "a": 0, "k": [0.0, 0.0] },
                      "a": { "a": 0, "k": [0.0, 0.0] },
                      "s": { "a": 0, "k": [100.0, 100.0] },
                      "nm": "Transform",
                      "sk": { "a": 0, "k": 0.0 },
                      "sa": { "a": 0, "k": 0.0 }
                    }
                  ]
                },
                {
                  "ty": "gr",
                  "nm": "Group 2",
                  "bm": 0,
                  "mn": "ADBE Vector Group",
                  "it": [
                    {
                      "ty": "sh",
                      "nm": "Path 1",
                      "mn": "ADBE Vector Shape - Group",
                      "ind": 0,
                      "ks": {
                        "k": {
                          "i": [
                            [0.0, 0.0],
                            [0.0, 0.0],
                            [-1.308, -0.608],
                            [0.0, 0.0],
                            [-0.95, 0.492],
                            [0.0, 0.0],
                            [2.318, 1.011],
                            [0.0, 0.0],
                            [0.0, 0.0],
                            [0.9, -0.415]
                          ],
                          "o": [
                            [0.0, 0.0],
                            [-1.31, 0.604],
                            [0.0, 0.0],
                            [0.974, 0.452],
                            [0.0, 0.0],
                            [2.232, -1.157],
                            [0.0, 0.0],
                            [0.0, 0.0],
                            [-0.91, -0.397],
                            [0.0, 0.0]
                          ],
                          "v": [
                            [-90.011, -52.82],
                            [-141.263, -29.17],
                            [-141.267, -26.279],
                            [-68.379, 7.578],
                            [-65.292, 7.514],
                            [20.615, -37.021],
                            [20.412, -42.115],
                            [-19.211, -59.397],
                            [-46.835, -71.445],
                            [-49.711, -71.416]
                          ],
                          "c": true
                        },
                        "a": 0
                      }
                    },
                    {
                      "ty": "st",
                      "nm": "Stroke 1",
                      "bm": 0,
                      "mn": "ADBE Vector Graphic - Stroke",
                      "lc": 2,
                      "lj": 2,
                      "o": { "a": 0, "k": 100.0 },
                      "w": { "a": 0, "k": 0.684 },
                      "c": { "a": 0, "k": [0.0, 0.0, 0.0, 1.0] }
                    },
                    {
                      "ty": "fl",
                      "nm": "Fill 1",
                      "bm": 0,
                      "mn": "ADBE Vector Graphic - Fill",
                      "c": { "a": 0, "k": [1.0, 1.0, 1.0, 1.0] },
                      "o": { "a": 0, "k": 100.0 },
                      "r": 1
                    },
                    {
                      "ty": "tr",
                      "o": { "a": 0, "k": 100.0 },
                      "r": { "a": 0, "k": 0.0 },
                      "p": { "a": 0, "k": [0.0, 0.0] },
                      "a": { "a": 0, "k": [0.0, 0.0] },
                      "s": { "a": 0, "k": [100.0, 100.0] },
                      "nm": "Transform",
                      "sk": { "a": 0, "k": 0.0 },
                      "sa": { "a": 0, "k": 0.0 }
                    }
                  ]
                },
                {
                  "ty": "gr",
                  "nm": "Group 3",
                  "bm": 0,
                  "mn": "ADBE Vector Group",
                  "it": [
                    {
                      "ty": "sh",
                      "nm": "Path 1",
                      "mn": "ADBE Vector Shape - Group",
                      "ind": 0,
                      "ks": {
                        "k": {
                          "i": [
                            [0.0, 0.0],
                            [0.0, 0.0],
                            [-1.744, -0.754],
                            [0.0, 0.0],
                            [-1.266, 0.611],
                            [0.0, 0.0],
                            [3.092, 1.254],
                            [0.0, 0.0],
                            [0.0, 0.0],
                            [1.201, -0.515]
                          ],
                          "o": [
                            [0.0, 0.0],
                            [-1.747, 0.75],
                            [0.0, 0.0],
                            [1.299, 0.561],
                            [0.0, 0.0],
                            [2.977, -1.435],
                            [0.0, 0.0],
                            [0.0, 0.0],
                            [-1.214, -0.493],
                            [0.0, 0.0]
                          ],
                          "v": [
                            [-104.267, -55.663],
                            [-172.621, -26.329],
                            [-172.627, -22.743],
                            [-75.417, 19.252],
                            [-71.3, 19.172],
                            [43.274, -36.067],
                            [43.004, -42.384],
                            [-9.842, -63.821],
                            [-46.683, -78.765],
                            [-50.52, -78.729]
                          ],
                          "c": true
                        },
                        "a": 0
                      }
                    },
                    {
                      "ty": "st",
                      "nm": "Stroke 1",
                      "bm": 0,
                      "mn": "ADBE Vector Graphic - Stroke",
                      "lc": 2,
                      "lj": 2,
                      "o": { "a": 0, "k": 100.0 },
                      "w": { "a": 0, "k": 0.684 },
                      "c": { "a": 0, "k": [0.0, 0.0, 0.0, 1.0] }
                    },
                    {
                      "ty": "fl",
                      "nm": "Fill 1",
                      "bm": 0,
                      "mn": "ADBE Vector Graphic - Fill",
                      "c": { "a": 0, "k": [1.0, 1.0, 1.0, 1.0] },
                      "o": { "a": 0, "k": 100.0 },
                      "r": 1
                    },
                    {
                      "ty": "tr",
                      "o": { "a": 0, "k": 100.0 },
                      "r": { "a": 0, "k": 0.0 },
                      "p": { "a": 0, "k": [0.0, 0.0] },
                      "a": { "a": 0, "k": [0.0, 0.0] },
                      "s": { "a": 0, "k": [100.0, 100.0] },
                      "nm": "Transform",
                      "sk": { "a": 0, "k": 0.0 },
                      "sa": { "a": 0, "k": 0.0 }
                    }
                  ]
                },
                {
                  "ty": "gr",
                  "nm": "Group 4",
                  "bm": 0,
                  "mn": "ADBE Vector Group",
                  "it": [
                    {
                      "ty": "sh",
                      "nm": "Path 1",
                      "mn": "ADBE Vector Shape - Group",
                      "ind": 0,
                      "ks": {
                        "k": {
                          "i": [
                            [0.804, 1.941],
                            [-0.033, 1.172],
                            [-0.406, 0.279],
                            [-0.452, -0.137],
                            [-0.406, -0.217],
                            [-3.675, 1.577],
                            [-3.635, 1.56],
                            [-9.185, 3.942],
                            [-9.926, 4.26],
                            [-8.492, 3.645],
                            [-4.884, 2.096],
                            [-0.368, 0.0],
                            [-1.214, -0.493],
                            [-0.434, -0.176],
                            [-3.621, -1.469],
                            [-6.087, -2.469],
                            [-7.086, -2.874],
                            [-6.618, -2.685],
                            [-2.675, -1.085],
                            [-2.03, 1.428],
                            [-0.68, 0.627],
                            [-0.955, -0.284],
                            [-0.198, -0.819],
                            [3.9, -1.818],
                            [2.192, -1.057],
                            [3.959, -1.909],
                            [5.185, -2.5],
                            [5.87, -2.83],
                            [6.015, -2.9],
                            [5.62, -2.709],
                            [4.684, -2.258],
                            [3.207, -1.546],
                            [1.191, -0.574],
                            [1.299, 0.561],
                            [2.968, 1.282],
                            [7.209, 3.114],
                            [8.924, 3.855],
                            [8.112, 3.505],
                            [4.155, 1.892]
                          ],
                          "o": [
                            [-0.471, -1.137],
                            [0.012, -0.439],
                            [0.371, -0.256],
                            [0.452, 0.137],
                            [4.005, 2.139],
                            [3.635, -1.56],
                            [9.185, -3.942],
                            [9.926, -4.26],
                            [8.492, -3.645],
                            [4.884, -2.096],
                            [0.316, -0.135],
                            [1.201, -0.515],
                            [0.434, 0.176],
                            [3.621, 1.469],
                            [6.087, 2.469],
                            [7.086, 2.874],
                            [6.618, 2.685],
                            [2.675, 1.085],
                            [2.015, 0.817],
                            [0.775, -0.545],
                            [0.68, -0.627],
                            [0.944, 0.281],
                            [0.857, 3.544],
                            [-2.211, 1.03],
                            [-3.959, 1.909],
                            [-5.185, 2.5],
                            [-5.87, 2.83],
                            [-6.015, 2.9],
                            [-5.62, 2.709],
                            [-4.684, 2.258],
                            [-3.207, 1.546],
                            [-1.191, 0.574],
                            [-1.266, 0.611],
                            [-2.968, -1.282],
                            [-7.209, -3.114],
                            [-8.924, -3.855],
                            [-8.112, -3.505],
                            [-4.202, -1.815],
                            [-2.145, -0.977]
                          ],
                          "v": [
                            [-174.332, -18.678],
                            [-174.997, -22.196],
                            [-174.502, -23.402],
                            [-173.129, -23.518],
                            [-171.884, -22.913],
                            [-160.436, -24.246],
                            [-149.533, -28.925],
                            [-121.979, -40.75],
                            [-92.201, -53.529],
                            [-66.723, -64.463],
                            [-52.071, -70.751],
                            [-50.699, -71.339],
                            [-46.863, -71.375],
                            [-45.561, -70.847],
                            [-34.699, -66.441],
                            [-16.437, -59.034],
                            [4.821, -50.41],
                            [24.675, -42.357],
                            [32.7, -39.102],
                            [40.675, -37.335],
                            [42.614, -39.283],
                            [45.297, -40.122],
                            [46.87, -38.12],
                            [42.294, -28.291],
                            [35.714, -25.119],
                            [23.836, -19.393],
                            [8.281, -11.893],
                            [-9.33, -3.402],
                            [-27.375, 5.298],
                            [-44.234, 13.426],
                            [-58.285, 20.201],
                            [-67.907, 24.84],
                            [-71.479, 26.562],
                            [-75.596, 26.641],
                            [-84.5, 22.795],
                            [-106.126, 13.453],
                            [-132.897, 1.888],
                            [-157.235, -8.626],
                            [-169.868, -14.029]
                          ],
                          "c": true
                        },
                        "a": 0
                      }
                    },
                    {
                      "ty": "fl",
                      "nm": "Fill 1",
                      "bm": 0,
                      "mn": "ADBE Vector Graphic - Fill",
                      "c": { "a": 0, "k": [0.0, 0.0, 0.0, 1.0] },
                      "o": { "a": 0, "k": 100.0 },
                      "r": 1
                    },
                    {
                      "ty": "tr",
                      "o": { "a": 0, "k": 100.0 },
                      "r": { "a": 0, "k": 0.0 },
                      "p": { "a": 0, "k": [0.0, 0.0] },
                      "a": { "a": 0, "k": [0.0, 0.0] },
                      "s": { "a": 0, "k": [100.0, 100.0] },
                      "nm": "Transform",
                      "sk": { "a": 0, "k": 0.0 },
                      "sa": { "a": 0, "k": 0.0 }
                    }
                  ]
                },
                {
                  "ty": "tr",
                  "o": { "a": 0, "k": 100.0 },
                  "r": {
                    "a": 1,
                    "k": [
                      {
                        "i": { "x": [0.667], "y": [1] },
                        "o": { "x": [0.333], "y": [0] },
                        "t": 13,
                        "s": [0.0]
                      },
                      {
                        "i": { "x": [0.667], "y": [1] },
                        "o": { "x": [0.333], "y": [0] },
                        "t": 20.272,
                        "s": [10.0]
                      },
                      {
                        "i": { "x": [0.667], "y": [1] },
                        "o": { "x": [0.333], "y": [0] },
                        "t": 26.637,
                        "s": [-10.0]
                      },
                      { "t": 33, "s": [0.0] }
                    ],
                    "x": "var $bm_rt;\nvar fx = effect('\u015dlosilo pli pura 2');\nvar doAnticipation = fx(1).value;\nvar doInterpolation = fx(2).value;\nvar doFollowThrough = fx(3).value;\nvar damping = $bm_div(fx(15).value, 10);\nvar elasticity = $bm_div(fx(13).value, 10);\nvar bounce = fx(17).value;\nvar anticipationDuration = fx(5).value;\nvar anticipationQuantity = $bm_div(fx(6).value, 100);\nvar slowIn = $bm_div(fx(9).value, 100);\nvar slowOut = $bm_div(fx(10).value, 100);\nvar spatialMode = fx(21).value;\nvar spatialDoInterpolation = fx(20).value;\nvar moBlurPrecision = fx(32).value;\nvar elasticityRandom = fx(14).value;\nvar dampingRandom = fx(16).value;\nvar softBody = fx(28).value;\nvar flexibility = $bm_div(fx(29).value, 100);\nvar doOverlap = fx(23).value;\nvar overlapDuration = fx(24).value;\nvar overlapRandom = fx(25).value;\nvar threshold = $bm_div($bm_div(1, moBlurPrecision), 1000);\nvar zeroValue;\nif ($bm_isInstanceOfArray(value)) {\n    if (value.length == 2)\n        zeroValue = [\n            0,\n            0\n        ];\n    else if (value.length == 3)\n        zeroValue = [\n            0,\n            0,\n            0\n        ];\n    else if (value.length == 4)\n        zeroValue = [\n            0,\n            0,\n            0,\n            0\n        ];\n} else\n    zeroValue = 0;\nvar isThisSpatial = isSpatial(thisProperty);\nvar isThisPosition = thisProperty === $bm_transform.position;\nvar simulate = false;\nif (isThisSpatial) {\n    doInterpolation = doInterpolation && spatialDoInterpolation;\n    if (isThisPosition && thisProperty.numKeys > 0) {\n        doOverlap = false;\n        simulate = false;\n    } else {\n        simulate = spatialMode == 2;\n        doOverlap = overlapDuration != 0 && doOverlap && simulate;\n    }\n} else {\n    doOverlap = false;\n}\nif (!doOverlap) {\n    overlapDuration = 0;\n}\nif (simulate && softBody && isThisSpatial && !isThisPosition && (doFollowThrough || doOverlap)) {\n    var distanceRatio = $bm_div(length(valueAtTime(0), $bm_transform.anchorPoint), $bm_div(thisLayer.width, 2));\n    distanceRatio = $bm_div($bm_sum(1, $bm_mul(distanceRatio, flexibility)), 2);\n    if (doFollowThrough) {\n        elasticity = $bm_div(elasticity, distanceRatio);\n        damping = $bm_div(damping, distanceRatio);\n    }\n    if (doOverlap) {\n        overlapDuration = $bm_mul(overlapDuration, distanceRatio);\n    }\n}\nseedRandom(0, true);\nif (doFollowThrough) {\n    if (elasticityRandom > 0)\n        elasticity = addNoise(elasticity, elasticityRandom);\n    if (dampingRandom > 0)\n        damping = addNoise(damping, dampingRandom);\n}\nif (doOverlap) {\n    if (doOverlap && overlapRandom > 0)\n        overlapDuration = addNoise(overlapDuration, overlapRandom);\n}\nvar result = value;\nfunction isSpatial(prop) {\n    if (!(prop.value instanceof Array))\n        return false;\n    if (prop.value.length != 2 && prop.value.length != 3)\n        return false;\n    try {\n        if (typeof prop.speed !== 'undefined')\n            return true;\n    } catch (e) {\n        return false;\n    }\n}\nfunction addNoise(val, quantity) {\n    var randomValue = random(0.9, 1.1);\n    var noiseValue = noise($bm_mul(valueAtTime(0), randomValue));\n    noiseValue = $bm_mul(noiseValue, $bm_div(quantity, 100));\n    return $bm_mul(val, $bm_sum(noiseValue, 1));\n}\nfunction isAfterLastKey() {\n    if (numKeys == 0)\n        return false;\n    var nKey = nearestKey(time);\n    return nKey.time <= time && nKey.index == numKeys;\n}\nfunction isStill(t, threshold) {\n    var d = $bm_sub(valueAtTime(t), valueAtTime($bm_sum(t, framesToTime(1))));\n    if ($bm_isInstanceOfArray(d)) {\n        for (var i = 0; i < d.length; i++) {\n            d[i] = Math.abs(d[i]);\n            if (d[i] >= threshold) {\n                return false;\n            }\n        }\n        return true;\n    } else {\n        d = Math.abs(d);\n        return d < threshold;\n    }\n}\nfunction bezierInterpolation(t, tMin, tMax, value1, value2, bezierPoints) {\n    if (arguments.length !== 5 && arguments.length !== 6)\n        return t;\n    var a = $bm_sub(value2, value1);\n    var b = $bm_sub(tMax, tMin);\n    if (b == 0)\n        return t;\n    var c = clamp($bm_div($bm_sub(t, tMin), b), 0, 1);\n    if (!(bezierPoints instanceof Array) || bezierPoints.length !== 4)\n        bezierPoints = [\n            0.33,\n            0,\n            0.66,\n            1\n        ];\n    return $bm_sum($bm_mul(a, h(c, bezierPoints)), value1);\n    function h(f, g) {\n        var x = $bm_mul(3, g[0]);\n        var j = $bm_sub($bm_mul(3, $bm_sub(g[2], g[0])), x);\n        var k = $bm_sub($bm_sub(1, x), j);\n        var l = $bm_mul(3, g[1]);\n        var m = $bm_sub($bm_mul(3, $bm_sub(g[3], g[1])), l);\n        var n = $bm_sub($bm_sub(1, l), m);\n        var d = f;\n        for (var i = 0; i < 5; i++) {\n            var z = $bm_sub($bm_mul(d, $bm_sum(x, $bm_mul(d, $bm_sum(j, $bm_mul(d, k))))), f);\n            if (Math.abs(z) < 0.001)\n                break;\n            d = $bm_sub(d, $bm_div(z, $bm_sum(x, $bm_mul(d, $bm_sum($bm_mul(2, j), $bm_mul($bm_mul(3, k), d))))));\n        }\n        return $bm_mul(d, $bm_sum(l, $bm_mul(d, $bm_sum(m, $bm_mul(d, n)))));\n    }\n}\nfunction getPropWorldSpeed(t, prop) {\n    return length(getPropWorldVelocity(t, prop));\n}\nfunction getPrevKey(t) {\n    if (numKeys == 0)\n        return null;\n    var nKey = nearestKey(t);\n    if (nKey.time <= t)\n        return nKey;\n    if (nKey.index > 1)\n        return key($bm_sub(nKey.index, 1));\n    return null;\n}\nfunction getNextKey(t) {\n    if (numKeys == 0)\n        return null;\n    var nKey = nearestKey(t);\n    if (nKey.time >= t)\n        return nKey;\n    if (nKey.index < numKeys)\n        return key($bm_sum(nKey.index, 1));\n    return null;\n}\nfunction getPropWorldVelocity(t, prop) {\n    return $bm_mul($bm_sub(getPropWorldValue($bm_sum(t, 0.005), prop), getPropWorldValue($bm_sub(t, 0.005), prop)), 100);\n}\nfunction getLayerWorldPos(t, l) {\n    return l.toWorld(l.anchorPoint, t);\n}\nfunction getPropWorldValue(t, prop) {\n    if (isPosition(prop))\n        return getLayerWorldPos(t, thisLayer);\n    return thisLayer.toWorld(prop.valueAtTime(t), t);\n}\nfunction isPosition(prop) {\n    return prop === $bm_transform.position;\n}\nfunction isKeyTop(k, axis) {\n    var prevSpeed = velocityAtTime($bm_sub(k.time, threshold));\n    var nextSpeed = velocityAtTime($bm_sum(k.time, threshold));\n    if ($bm_isInstanceOfArray(value)) {\n        prevSpeed = prevSpeed[axis];\n        nextSpeed = nextSpeed[axis];\n    }\n    if (Math.abs(prevSpeed) < 0.01 || Math.abs(nextSpeed) < 0.01)\n        return true;\n    return $bm_mul(prevSpeed, nextSpeed) < 0;\n}\nfunction anticipate() {\n    var anticipation = zeroValue;\n    if (isAfterLastKey())\n        return anticipation;\n    if (numKeys < 2)\n        return anticipation;\n    var nextKey = getNextKey(time);\n    var aKey = nextKey;\n    if (!isStill(aKey.time - 0.1, 0.1)) {\n        aKey = getPrevKey(time);\n        if (!isStill(aKey.time - 0.1, 0.1))\n            return anticipation;\n    }\n    if (aKey.index == numKeys)\n        return anticipation;\n    var anticipationMiddle = aKey.time;\n    var anticipationStart = $bm_sub(anticipationMiddle, anticipationDuration);\n    var anticipationEnd = key(aKey.index + 1).time;\n    var startValue = anticipation;\n    var midValue = $bm_mul($bm_sum($bm_neg(valueAtTime($bm_sum(anticipationMiddle, anticipationDuration))), aKey.value), anticipationQuantity);\n    var endValue = anticipation;\n    if (time < anticipationStart) {\n        return anticipation;\n    } else if (time < anticipationMiddle) {\n        if ($bm_isInstanceOfArray(value)) {\n            for (var i = 0; i < value.length; i++) {\n                anticipation[i] = bezierInterpolation(time, anticipationStart, anticipationMiddle, startValue[i], midValue[i], [\n                    slowOut,\n                    0,\n                    slowIn,\n                    1\n                ]);\n            }\n            return anticipation;\n        } else {\n            return bezierInterpolation(time, anticipationStart, anticipationMiddle, startValue, midValue, [\n                slowOut,\n                0,\n                slowIn,\n                1\n            ]);\n        }\n    } else if (time <= anticipationEnd) {\n        if ($bm_isInstanceOfArray(value)) {\n            for (var i = 0; i < value.length; i++) {\n                anticipation[i] = bezierInterpolation(time, anticipationMiddle, anticipationEnd, midValue[i], endValue[i], [\n                    slowOut,\n                    0,\n                    slowIn,\n                    1\n                ]);\n            }\n            return anticipation;\n        } else {\n            return bezierInterpolation(time, anticipationMiddle, anticipationEnd, midValue, endValue, [\n                slowOut,\n                0,\n                slowIn,\n                1\n            ]);\n        }\n    } else {\n        return anticipation;\n    }\n}\nfunction followThroughAtTime(t) {\n    var fThrough = zeroValue;\n    if (elasticity == 0)\n        return fThrough;\n    var propSpeed;\n    if (!simulate) {\n        if (numKeys < 2)\n            return fThrough;\n        if (nearestKey(t).index == 1)\n            return fThrough;\n        propSpeed = length(velocityAtTime(t));\n        if (propSpeed >= threshold)\n            return fThrough;\n    } else {\n        propSpeed = getPropWorldSpeed(t, thisProperty);\n        if (propSpeed >= threshold)\n            return fThrough;\n    }\n    var fThroughStart = 0;\n    var fThroughTime = 0;\n    if (simulate) {\n        var speedI = getPropWorldSpeed(t, thisProperty);\n        var i = t;\n        while (speedI < threshold && i > 0) {\n            i = $bm_sub(i, $bm_div(thisComp.frameDuration, moBlurPrecision));\n            speedI = getPropWorldSpeed(i, thisProperty);\n        }\n        fThroughStart = i;\n    } else {\n        var fThroughKey = getPrevKey(t);\n        fThroughStart = fThroughKey.time;\n    }\n    if (fThroughStart == 0)\n        return fThrough;\n    fThroughTime = $bm_sub(t, fThroughStart);\n    if (simulate)\n        fThrough = $bm_div(getPropWorldVelocity($bm_sub(fThroughStart, thisComp.frameDuration), thisProperty), 2);\n    else\n        fThrough = $bm_div(velocityAtTime($bm_sub(fThroughStart, thisComp.frameDuration)), 2);\n    if (bounce) {\n        var cycleDamp = Math.exp($bm_mul($bm_mul(fThroughTime, damping), 0.1));\n        var damp = $bm_div(Math.exp($bm_mul(fThroughTime, damping)), $bm_div(elasticity, 2));\n        var cycleDuration = $bm_div(1, $bm_mul(elasticity, 2));\n        cycleDuration = Math.round(timeToFrames(cycleDuration));\n        cycleDuration = framesToTime(cycleDuration);\n        var midDuration = $bm_div(cycleDuration, 2);\n        var maxValue = $bm_mul(fThrough, midDuration);\n        var cycvarime = fThroughTime;\n        var numEndCycles = 1;\n        while (cycvarime > cycleDuration) {\n            cycvarime = $bm_sub(cycvarime, cycleDuration);\n            cycleDuration = $bm_div(cycleDuration, cycleDamp);\n            cycleDuration = Math.round(timeToFrames(cycleDuration));\n            if (cycleDuration < 2) {\n                cycleDuration = 2;\n                numEndCycles++;\n            }\n            cycleDuration = framesToTime(cycleDuration);\n            midDuration = $bm_div(cycleDuration, 2);\n            maxValue = $bm_div($bm_mul(fThrough, midDuration), damp);\n            if (numEndCycles > 100 / damping && maxValue < threshold)\n                return zeroValue;\n        }\n        if (cycvarime < midDuration)\n            fThrough = bezierInterpolation(cycvarime, 0, midDuration, 0, maxValue, [\n                0,\n                0.1,\n                slowIn,\n                1\n            ]);\n        else\n            fThrough = bezierInterpolation(cycvarime, midDuration, cycleDuration, maxValue, 0, [\n                $bm_sub(1, slowIn),\n                0,\n                1,\n                0.9\n            ]);\n    } else {\n        var damp = Math.exp($bm_mul(fThroughTime, damping));\n        var sinus = $bm_mul($bm_mul($bm_mul(elasticity, fThroughTime), 2), Math.PI);\n        sinus = Math.sin(sinus);\n        sinus = $bm_mul($bm_div(0.3, elasticity), sinus);\n        sinus = $bm_div(sinus, damp);\n        if (Math.abs(sinus) < $bm_div(threshold, 100))\n            return 0;\n        fThrough = $bm_mul(fThrough, sinus);\n        if (threshold > 0) {\n            fThrough = $bm_mul(fThrough, $bm_sub(1, $bm_div(propSpeed, threshold)));\n        }\n    }\n    if (bounce) {\n        var prevValue = valueAtTime($bm_sub(fThroughStart, thisComp.frameDuration));\n        var startValue = valueAtTime(fThroughStart);\n        if ($bm_isInstanceOfArray(value)) {\n            for (var i = 0; i < prevValue.length; i++) {\n                if (prevValue[i] > startValue[i])\n                    fThrough[i] = Math.abs(fThrough[i]);\n                if (prevValue[i] < startValue[i])\n                    fThrough[i] = $bm_neg(Math.abs(fThrough[i]));\n            }\n        } else {\n            if (prevValue > startValue)\n                fThrough = Math.abs(fThrough);\n            if (prevValue < startValue)\n                fThrough = $bm_neg(Math.abs(fThrough));\n        }\n    }\n    if (simulate) {\n        if (!isThisPosition) {\n            fThrough = $bm_sum(fThrough, getLayerWorldPos(time, thisLayer));\n            fThrough = $bm_sub(thisLayer.fromWorld(fThrough), thisLayer.anchorPoint);\n        } else if (thisLayer.hasParent) {\n            fThrough = $bm_sum(fThrough, getLayerWorldPos(time, thisLayer.parent));\n            fThrough = $bm_sub(thisLayer.parent.fromWorld(fThrough), thisLayer.parent.anchorPoint);\n        }\n    }\n    return fThrough;\n}\nfunction followThrough() {\n    var propSpeed = length(velocity);\n    if (propSpeed < threshold)\n        return followThroughAtTime($bm_sub(time, overlapDuration));\n    var fThrough = zeroValue;\n    var t = time;\n    while (t > 0) {\n        t = $bm_sub(t, thisComp.frameDuration);\n        if (simulate)\n            propSpeed = getPropWorldSpeed($bm_sub(t, overlapDuration), thisProperty);\n        else\n            propSpeed = length(velocityAtTime(t));\n        if (propSpeed < threshold) {\n            fThrough = followThroughAtTime($bm_sub(t, overlapDuration));\n            break;\n        }\n    }\n    return linear(time, t, $bm_sum(t, $bm_mul(anticipationDuration, 2)), fThrough, zeroValue);\n}\nfunction smartSmooth(axis) {\n    var startKey = nearestKey(time);\n    var endKey = startKey;\n    if (time == startKey.time)\n        return 0;\n    if (time < startKey.time && startKey.index == 1)\n        return 0;\n    if (time > startKey.time && startKey.index == numKeys)\n        return 0;\n    if (time < startKey.time)\n        startKey = key($bm_sub(startKey.index, 1));\n    if (time > startKey.time)\n        endKey = key($bm_sum(startKey.index, 1));\n    var sI = 0.66;\n    var sO = 0.33;\n    var sIV = 1;\n    var sOV = 0;\n    var sVal = startKey.value;\n    var eVal = endKey.value;\n    if ($bm_isInstanceOfArray(value)) {\n        sVal = sVal[axis];\n        eVal = eVal[axis];\n    }\n    var sTime = startKey.time;\n    var eTime = endKey.time;\n    if (isKeyTop(startKey, axis))\n        sO = slowOut;\n    else {\n        var prevKey = key($bm_sub(startKey.index, 1));\n        var pVal = prevKey.value;\n        if ($bm_isInstanceOfArray(value))\n            pVal = pVal[axis];\n        sOV = $bm_div($bm_sub(sVal, pVal), $bm_sub(eVal, pVal));\n    }\n    if (isKeyTop(endKey, axis)) {\n        sI = slowIn;\n        if (endKey.index != numKeys) {\n            var nextKey = key($bm_sum(endKey.index, 1));\n            var nVal = nextKey.value;\n            if ($bm_isInstanceOfArray(value))\n                nVal = nVal[axis];\n            if (Math.abs(nVal - eVal) < 0.01 && doFollowThrough)\n                sI = 1;\n        }\n    } else {\n        var nextKey = key($bm_sum(endKey.index, 1));\n        var nVal = nextKey.value;\n        if ($bm_isInstanceOfArray(value))\n            nVal = nVal[axis];\n        sIV = $bm_div($bm_sub(eVal, sVal), $bm_sub(nVal, sVal));\n    }\n    if (endKey.index == numKeys && doFollowThrough) {\n        sI = 1;\n    }\n    var val = value;\n    if ($bm_isInstanceOfArray(value))\n        val = val[axis];\n    return $bm_sub(bezierInterpolation(time, sTime, eTime, sVal, eVal, [\n        sO,\n        sOV,\n        sI,\n        sIV\n    ]), val);\n}\nfunction overlap() {\n    var ol = zeroValue;\n    if (isThisPosition && !hasParent)\n        return zeroValue;\n    ol = $bm_sub(getPropWorldValue($bm_sub(time, overlapDuration), thisProperty), getPropWorldValue(time, thisProperty));\n    var motionRatio = $bm_div($bm_div(length(zeroValue, ol), thisLayer.width), 2);\n    if (isThisPosition) {\n        var originalDistance = length(valueAtTime(0));\n        motionRatio = $bm_div(length(zeroValue, ol), thisComp.width);\n    }\n    ol = $bm_sum(ol, getPropWorldValue(time, thisProperty));\n    ol = $bm_sum(ol, $bm_mul($bm_mul($bm_sub(getPropWorldValue($bm_sub(time, overlapDuration), thisLayer.anchorPoint), ol), motionRatio), flexibility));\n    ol = thisLayer.fromWorld(ol);\n    if (!isThisPosition)\n        ol = $bm_sub(ol, value);\n    else {\n        ol = linear(flexibility, 0, 100, $bm_div(ol, 2), 0);\n        var prevParentWorldPos = getLayerWorldPos($bm_sub(time, overlapDuration), parent);\n        ol = $bm_sum(ol, $bm_mul($bm_mul($bm_mul(thisLayer.fromWorld(prevParentWorldPos), motionRatio), flexibility), 5));\n    }\n    return ol;\n}\nvar okToGo = false;\nif (simulate && fx.enabled)\n    okToGo = true;\nelse if (numKeys > 1 && fx.enabled)\n    okToGo = true;\nif (okToGo) {\n    var smartSmoothResult = zeroValue;\n    if (doInterpolation) {\n        if ($bm_isInstanceOfArray(value)) {\n            if (value.length == 2)\n                smartSmoothResult = [\n                    smartSmooth(0),\n                    smartSmooth(1)\n                ];\n            else if (value.length == 3)\n                smartSmoothResult = [\n                    smartSmooth(0),\n                    smartSmooth(1),\n                    smartSmooth(2)\n                ];\n            else if (value.length == 4)\n                smartSmoothResult = [\n                    smartSmooth(0),\n                    smartSmooth(1),\n                    smartSmooth(2),\n                    smartSmooth(3)\n                ];\n        } else {\n            smartSmoothResult = smartSmooth(0);\n        }\n    }\n    if (doAnticipation)\n        result = $bm_sum(result, anticipate());\n    result = $bm_sum(result, smartSmoothResult);\n    if (doFollowThrough)\n        result = $bm_sum(result, followThrough());\n    if (doOverlap)\n        result = $bm_sum(result, overlap());\n}\n$bm_rt = result;"
                  },
                  "p": { "a": 0, "k": [-29.987, -6.064] },
                  "a": { "a": 0, "k": [-29.987, -6.064] },
                  "s": { "a": 0, "k": [100.0, 100.0] },
                  "nm": "Transform",
                  "sk": { "a": 0, "k": 0.0 },
                  "sa": { "a": 0, "k": 0.0 }
                }
              ]
            },
            {
              "ty": "gr",
              "nm": "Group 4",
              "bm": 0,
              "mn": "ADBE Vector Group",
              "it": [
                {
                  "ty": "gr",
                  "nm": "Group 1",
                  "bm": 0,
                  "mn": "ADBE Vector Group",
                  "it": [
                    {
                      "ty": "sh",
                      "nm": "Path 1",
                      "mn": "ADBE Vector Shape - Group",
                      "ind": 0,
                      "ks": {
                        "k": {
                          "i": [
                            [1.492, -1.881],
                            [0.0, 0.0],
                            [-1.586, -0.25],
                            [0.0, 0.0],
                            [0.426, -2.728],
                            [0.0, 0.0],
                            [2.837, 0.662],
                            [0.0, 0.0],
                            [0.0, 0.0],
                            [0.669, 1.309],
                            [0.0, 0.0],
                            [0.0, 0.0],
                            [0.014, 0.037],
                            [3.083, 1.123],
                            [3.192, -0.759],
                            [1.654, 0.364],
                            [-0.337, 1.66],
                            [-1.065, 0.596],
                            [-4.983, 0.534],
                            [-5.524, 0.592],
                            [-2.793, -2.655]
                          ],
                          "o": [
                            [0.0, 0.0],
                            [0.723, 1.434],
                            [0.0, 0.0],
                            [2.728, 0.426],
                            [0.0, 0.0],
                            [-0.452, 2.874],
                            [0.0, 0.0],
                            [0.0, 0.0],
                            [-1.431, -0.337],
                            [0.0, 0.0],
                            [0.0, 0.0],
                            [-0.02, -0.031],
                            [-1.143, -3.076],
                            [-3.083, -1.123],
                            [-1.648, 0.392],
                            [-1.654, -0.364],
                            [0.243, -1.196],
                            [4.486, -2.509],
                            [5.524, -0.592],
                            [3.522, -0.378],
                            [1.74, 1.654]
                          ],
                          "v": [
                            [-5.435, 3.774],
                            [17.519, 49.023],
                            [21.206, 51.701],
                            [73.159, 59.756],
                            [77.326, 65.46],
                            [75.155, 79.525],
                            [69.076, 83.623],
                            [15.155, 71.078],
                            [1.517, 67.901],
                            [-1.802, 65.299],
                            [-7.087, 54.886],
                            [-27.75, 14.136],
                            [-27.798, 14.03],
                            [-33.844, 5.957],
                            [-43.545, 6.023],
                            [-48.554, 6.529],
                            [-51.408, 2.946],
                            [-49.012, 0.331],
                            [-34.324, -2.353],
                            [-17.752, -4.129],
                            [-6.545, -2.137]
                          ],
                          "c": true
                        },
                        "a": 0
                      }
                    },
                    {
                      "ty": "st",
                      "nm": "Stroke 1",
                      "bm": 0,
                      "mn": "ADBE Vector Graphic - Stroke",
                      "lc": 2,
                      "lj": 2,
                      "o": { "a": 0, "k": 100.0 },
                      "w": { "a": 0, "k": 0.684 },
                      "c": { "a": 0, "k": [0.0, 0.0, 0.0, 1.0] }
                    },
                    {
                      "ty": "fl",
                      "nm": "Fill 1",
                      "bm": 0,
                      "mn": "ADBE Vector Graphic - Fill",
                      "c": { "a": 0, "k": [1.0, 1.0, 1.0, 1.0] },
                      "o": { "a": 0, "k": 100.0 },
                      "r": 1
                    },
                    {
                      "ty": "tr",
                      "o": { "a": 0, "k": 100.0 },
                      "r": { "a": 0, "k": 0.0 },
                      "p": { "a": 0, "k": [0.0, 0.0] },
                      "a": { "a": 0, "k": [0.0, 0.0] },
                      "s": { "a": 0, "k": [100.0, 100.0] },
                      "nm": "Transform",
                      "sk": { "a": 0, "k": 0.0 },
                      "sa": { "a": 0, "k": 0.0 }
                    }
                  ]
                },
                {
                  "ty": "tr",
                  "o": { "a": 0, "k": 100.0 },
                  "r": { "a": 0, "k": 0.0 },
                  "p": { "a": 0, "k": [0.0, 0.0] },
                  "a": { "a": 0, "k": [0.0, 0.0] },
                  "s": { "a": 0, "k": [100.0, 100.0] },
                  "nm": "Transform",
                  "sk": { "a": 0, "k": 0.0 },
                  "sa": { "a": 0, "k": 0.0 }
                }
              ]
            },
            {
              "ty": "tr",
              "o": { "a": 0, "k": 100.0 },
              "r": {
                "a": 1,
                "k": [
                  {
                    "i": { "x": [0.667], "y": [1] },
                    "o": { "x": [0.333], "y": [0] },
                    "t": 0,
                    "s": [0.0]
                  },
                  {
                    "i": { "x": [0.667], "y": [1] },
                    "o": { "x": [0.333], "y": [0] },
                    "t": 12,
                    "s": [-15.0]
                  },
                  { "t": 17.28, "s": [0.0] }
                ],
                "x": "var $bm_rt;\nvar fx = effect('\u015dlosilo pli pura');\nvar doAnticipation = fx(1).value;\nvar doInterpolation = fx(2).value;\nvar doFollowThrough = fx(3).value;\nvar damping = $bm_div(fx(15).value, 10);\nvar elasticity = $bm_div(fx(13).value, 10);\nvar bounce = fx(17).value;\nvar anticipationDuration = fx(5).value;\nvar anticipationQuantity = $bm_div(fx(6).value, 100);\nvar slowIn = $bm_div(fx(9).value, 100);\nvar slowOut = $bm_div(fx(10).value, 100);\nvar spatialMode = fx(21).value;\nvar spatialDoInterpolation = fx(20).value;\nvar moBlurPrecision = fx(32).value;\nvar elasticityRandom = fx(14).value;\nvar dampingRandom = fx(16).value;\nvar softBody = fx(28).value;\nvar flexibility = $bm_div(fx(29).value, 100);\nvar doOverlap = fx(23).value;\nvar overlapDuration = fx(24).value;\nvar overlapRandom = fx(25).value;\nvar threshold = $bm_div($bm_div(1, moBlurPrecision), 1000);\nvar zeroValue;\nif ($bm_isInstanceOfArray(value)) {\n    if (value.length == 2)\n        zeroValue = [\n            0,\n            0\n        ];\n    else if (value.length == 3)\n        zeroValue = [\n            0,\n            0,\n            0\n        ];\n    else if (value.length == 4)\n        zeroValue = [\n            0,\n            0,\n            0,\n            0\n        ];\n} else\n    zeroValue = 0;\nvar isThisSpatial = isSpatial(thisProperty);\nvar isThisPosition = thisProperty === $bm_transform.position;\nvar simulate = false;\nif (isThisSpatial) {\n    doInterpolation = doInterpolation && spatialDoInterpolation;\n    if (isThisPosition && thisProperty.numKeys > 0) {\n        doOverlap = false;\n        simulate = false;\n    } else {\n        simulate = spatialMode == 2;\n        doOverlap = overlapDuration != 0 && doOverlap && simulate;\n    }\n} else {\n    doOverlap = false;\n}\nif (!doOverlap) {\n    overlapDuration = 0;\n}\nif (simulate && softBody && isThisSpatial && !isThisPosition && (doFollowThrough || doOverlap)) {\n    var distanceRatio = $bm_div(length(valueAtTime(0), $bm_transform.anchorPoint), $bm_div(thisLayer.width, 2));\n    distanceRatio = $bm_div($bm_sum(1, $bm_mul(distanceRatio, flexibility)), 2);\n    if (doFollowThrough) {\n        elasticity = $bm_div(elasticity, distanceRatio);\n        damping = $bm_div(damping, distanceRatio);\n    }\n    if (doOverlap) {\n        overlapDuration = $bm_mul(overlapDuration, distanceRatio);\n    }\n}\nseedRandom(0, true);\nif (doFollowThrough) {\n    if (elasticityRandom > 0)\n        elasticity = addNoise(elasticity, elasticityRandom);\n    if (dampingRandom > 0)\n        damping = addNoise(damping, dampingRandom);\n}\nif (doOverlap) {\n    if (doOverlap && overlapRandom > 0)\n        overlapDuration = addNoise(overlapDuration, overlapRandom);\n}\nvar result = value;\nfunction isSpatial(prop) {\n    if (!(prop.value instanceof Array))\n        return false;\n    if (prop.value.length != 2 && prop.value.length != 3)\n        return false;\n    try {\n        if (typeof prop.speed !== 'undefined')\n            return true;\n    } catch (e) {\n        return false;\n    }\n}\nfunction addNoise(val, quantity) {\n    var randomValue = random(0.9, 1.1);\n    var noiseValue = noise($bm_mul(valueAtTime(0), randomValue));\n    noiseValue = $bm_mul(noiseValue, $bm_div(quantity, 100));\n    return $bm_mul(val, $bm_sum(noiseValue, 1));\n}\nfunction isAfterLastKey() {\n    if (numKeys == 0)\n        return false;\n    var nKey = nearestKey(time);\n    return nKey.time <= time && nKey.index == numKeys;\n}\nfunction isStill(t, threshold) {\n    var d = $bm_sub(valueAtTime(t), valueAtTime($bm_sum(t, framesToTime(1))));\n    if ($bm_isInstanceOfArray(d)) {\n        for (var i = 0; i < d.length; i++) {\n            d[i] = Math.abs(d[i]);\n            if (d[i] >= threshold) {\n                return false;\n            }\n        }\n        return true;\n    } else {\n        d = Math.abs(d);\n        return d < threshold;\n    }\n}\nfunction bezierInterpolation(t, tMin, tMax, value1, value2, bezierPoints) {\n    if (arguments.length !== 5 && arguments.length !== 6)\n        return t;\n    var a = $bm_sub(value2, value1);\n    var b = $bm_sub(tMax, tMin);\n    if (b == 0)\n        return t;\n    var c = clamp($bm_div($bm_sub(t, tMin), b), 0, 1);\n    if (!(bezierPoints instanceof Array) || bezierPoints.length !== 4)\n        bezierPoints = [\n            0.33,\n            0,\n            0.66,\n            1\n        ];\n    return $bm_sum($bm_mul(a, h(c, bezierPoints)), value1);\n    function h(f, g) {\n        var x = $bm_mul(3, g[0]);\n        var j = $bm_sub($bm_mul(3, $bm_sub(g[2], g[0])), x);\n        var k = $bm_sub($bm_sub(1, x), j);\n        var l = $bm_mul(3, g[1]);\n        var m = $bm_sub($bm_mul(3, $bm_sub(g[3], g[1])), l);\n        var n = $bm_sub($bm_sub(1, l), m);\n        var d = f;\n        for (var i = 0; i < 5; i++) {\n            var z = $bm_sub($bm_mul(d, $bm_sum(x, $bm_mul(d, $bm_sum(j, $bm_mul(d, k))))), f);\n            if (Math.abs(z) < 0.001)\n                break;\n            d = $bm_sub(d, $bm_div(z, $bm_sum(x, $bm_mul(d, $bm_sum($bm_mul(2, j), $bm_mul($bm_mul(3, k), d))))));\n        }\n        return $bm_mul(d, $bm_sum(l, $bm_mul(d, $bm_sum(m, $bm_mul(d, n)))));\n    }\n}\nfunction getPropWorldSpeed(t, prop) {\n    return length(getPropWorldVelocity(t, prop));\n}\nfunction getPrevKey(t) {\n    if (numKeys == 0)\n        return null;\n    var nKey = nearestKey(t);\n    if (nKey.time <= t)\n        return nKey;\n    if (nKey.index > 1)\n        return key($bm_sub(nKey.index, 1));\n    return null;\n}\nfunction getNextKey(t) {\n    if (numKeys == 0)\n        return null;\n    var nKey = nearestKey(t);\n    if (nKey.time >= t)\n        return nKey;\n    if (nKey.index < numKeys)\n        return key($bm_sum(nKey.index, 1));\n    return null;\n}\nfunction getPropWorldVelocity(t, prop) {\n    return $bm_mul($bm_sub(getPropWorldValue($bm_sum(t, 0.005), prop), getPropWorldValue($bm_sub(t, 0.005), prop)), 100);\n}\nfunction getLayerWorldPos(t, l) {\n    return l.toWorld(l.anchorPoint, t);\n}\nfunction getPropWorldValue(t, prop) {\n    if (isPosition(prop))\n        return getLayerWorldPos(t, thisLayer);\n    return thisLayer.toWorld(prop.valueAtTime(t), t);\n}\nfunction isPosition(prop) {\n    return prop === $bm_transform.position;\n}\nfunction isKeyTop(k, axis) {\n    var prevSpeed = velocityAtTime($bm_sub(k.time, threshold));\n    var nextSpeed = velocityAtTime($bm_sum(k.time, threshold));\n    if ($bm_isInstanceOfArray(value)) {\n        prevSpeed = prevSpeed[axis];\n        nextSpeed = nextSpeed[axis];\n    }\n    if (Math.abs(prevSpeed) < 0.01 || Math.abs(nextSpeed) < 0.01)\n        return true;\n    return $bm_mul(prevSpeed, nextSpeed) < 0;\n}\nfunction anticipate() {\n    var anticipation = zeroValue;\n    if (isAfterLastKey())\n        return anticipation;\n    if (numKeys < 2)\n        return anticipation;\n    var nextKey = getNextKey(time);\n    var aKey = nextKey;\n    if (!isStill(aKey.time - 0.1, 0.1)) {\n        aKey = getPrevKey(time);\n        if (!isStill(aKey.time - 0.1, 0.1))\n            return anticipation;\n    }\n    if (aKey.index == numKeys)\n        return anticipation;\n    var anticipationMiddle = aKey.time;\n    var anticipationStart = $bm_sub(anticipationMiddle, anticipationDuration);\n    var anticipationEnd = key(aKey.index + 1).time;\n    var startValue = anticipation;\n    var midValue = $bm_mul($bm_sum($bm_neg(valueAtTime($bm_sum(anticipationMiddle, anticipationDuration))), aKey.value), anticipationQuantity);\n    var endValue = anticipation;\n    if (time < anticipationStart) {\n        return anticipation;\n    } else if (time < anticipationMiddle) {\n        if ($bm_isInstanceOfArray(value)) {\n            for (var i = 0; i < value.length; i++) {\n                anticipation[i] = bezierInterpolation(time, anticipationStart, anticipationMiddle, startValue[i], midValue[i], [\n                    slowOut,\n                    0,\n                    slowIn,\n                    1\n                ]);\n            }\n            return anticipation;\n        } else {\n            return bezierInterpolation(time, anticipationStart, anticipationMiddle, startValue, midValue, [\n                slowOut,\n                0,\n                slowIn,\n                1\n            ]);\n        }\n    } else if (time <= anticipationEnd) {\n        if ($bm_isInstanceOfArray(value)) {\n            for (var i = 0; i < value.length; i++) {\n                anticipation[i] = bezierInterpolation(time, anticipationMiddle, anticipationEnd, midValue[i], endValue[i], [\n                    slowOut,\n                    0,\n                    slowIn,\n                    1\n                ]);\n            }\n            return anticipation;\n        } else {\n            return bezierInterpolation(time, anticipationMiddle, anticipationEnd, midValue, endValue, [\n                slowOut,\n                0,\n                slowIn,\n                1\n            ]);\n        }\n    } else {\n        return anticipation;\n    }\n}\nfunction followThroughAtTime(t) {\n    var fThrough = zeroValue;\n    if (elasticity == 0)\n        return fThrough;\n    var propSpeed;\n    if (!simulate) {\n        if (numKeys < 2)\n            return fThrough;\n        if (nearestKey(t).index == 1)\n            return fThrough;\n        propSpeed = length(velocityAtTime(t));\n        if (propSpeed >= threshold)\n            return fThrough;\n    } else {\n        propSpeed = getPropWorldSpeed(t, thisProperty);\n        if (propSpeed >= threshold)\n            return fThrough;\n    }\n    var fThroughStart = 0;\n    var fThroughTime = 0;\n    if (simulate) {\n        var speedI = getPropWorldSpeed(t, thisProperty);\n        var i = t;\n        while (speedI < threshold && i > 0) {\n            i = $bm_sub(i, $bm_div(thisComp.frameDuration, moBlurPrecision));\n            speedI = getPropWorldSpeed(i, thisProperty);\n        }\n        fThroughStart = i;\n    } else {\n        var fThroughKey = getPrevKey(t);\n        fThroughStart = fThroughKey.time;\n    }\n    if (fThroughStart == 0)\n        return fThrough;\n    fThroughTime = $bm_sub(t, fThroughStart);\n    if (simulate)\n        fThrough = $bm_div(getPropWorldVelocity($bm_sub(fThroughStart, thisComp.frameDuration), thisProperty), 2);\n    else\n        fThrough = $bm_div(velocityAtTime($bm_sub(fThroughStart, thisComp.frameDuration)), 2);\n    if (bounce) {\n        var cycleDamp = Math.exp($bm_mul($bm_mul(fThroughTime, damping), 0.1));\n        var damp = $bm_div(Math.exp($bm_mul(fThroughTime, damping)), $bm_div(elasticity, 2));\n        var cycleDuration = $bm_div(1, $bm_mul(elasticity, 2));\n        cycleDuration = Math.round(timeToFrames(cycleDuration));\n        cycleDuration = framesToTime(cycleDuration);\n        var midDuration = $bm_div(cycleDuration, 2);\n        var maxValue = $bm_mul(fThrough, midDuration);\n        var cycvarime = fThroughTime;\n        var numEndCycles = 1;\n        while (cycvarime > cycleDuration) {\n            cycvarime = $bm_sub(cycvarime, cycleDuration);\n            cycleDuration = $bm_div(cycleDuration, cycleDamp);\n            cycleDuration = Math.round(timeToFrames(cycleDuration));\n            if (cycleDuration < 2) {\n                cycleDuration = 2;\n                numEndCycles++;\n            }\n            cycleDuration = framesToTime(cycleDuration);\n            midDuration = $bm_div(cycleDuration, 2);\n            maxValue = $bm_div($bm_mul(fThrough, midDuration), damp);\n            if (numEndCycles > 100 / damping && maxValue < threshold)\n                return zeroValue;\n        }\n        if (cycvarime < midDuration)\n            fThrough = bezierInterpolation(cycvarime, 0, midDuration, 0, maxValue, [\n                0,\n                0.1,\n                slowIn,\n                1\n            ]);\n        else\n            fThrough = bezierInterpolation(cycvarime, midDuration, cycleDuration, maxValue, 0, [\n                $bm_sub(1, slowIn),\n                0,\n                1,\n                0.9\n            ]);\n    } else {\n        var damp = Math.exp($bm_mul(fThroughTime, damping));\n        var sinus = $bm_mul($bm_mul($bm_mul(elasticity, fThroughTime), 2), Math.PI);\n        sinus = Math.sin(sinus);\n        sinus = $bm_mul($bm_div(0.3, elasticity), sinus);\n        sinus = $bm_div(sinus, damp);\n        if (Math.abs(sinus) < $bm_div(threshold, 100))\n            return 0;\n        fThrough = $bm_mul(fThrough, sinus);\n        if (threshold > 0) {\n            fThrough = $bm_mul(fThrough, $bm_sub(1, $bm_div(propSpeed, threshold)));\n        }\n    }\n    if (bounce) {\n        var prevValue = valueAtTime($bm_sub(fThroughStart, thisComp.frameDuration));\n        var startValue = valueAtTime(fThroughStart);\n        if ($bm_isInstanceOfArray(value)) {\n            for (var i = 0; i < prevValue.length; i++) {\n                if (prevValue[i] > startValue[i])\n                    fThrough[i] = Math.abs(fThrough[i]);\n                if (prevValue[i] < startValue[i])\n                    fThrough[i] = $bm_neg(Math.abs(fThrough[i]));\n            }\n        } else {\n            if (prevValue > startValue)\n                fThrough = Math.abs(fThrough);\n            if (prevValue < startValue)\n                fThrough = $bm_neg(Math.abs(fThrough));\n        }\n    }\n    if (simulate) {\n        if (!isThisPosition) {\n            fThrough = $bm_sum(fThrough, getLayerWorldPos(time, thisLayer));\n            fThrough = $bm_sub(thisLayer.fromWorld(fThrough), thisLayer.anchorPoint);\n        } else if (thisLayer.hasParent) {\n            fThrough = $bm_sum(fThrough, getLayerWorldPos(time, thisLayer.parent));\n            fThrough = $bm_sub(thisLayer.parent.fromWorld(fThrough), thisLayer.parent.anchorPoint);\n        }\n    }\n    return fThrough;\n}\nfunction followThrough() {\n    var propSpeed = length(velocity);\n    if (propSpeed < threshold)\n        return followThroughAtTime($bm_sub(time, overlapDuration));\n    var fThrough = zeroValue;\n    var t = time;\n    while (t > 0) {\n        t = $bm_sub(t, thisComp.frameDuration);\n        if (simulate)\n            propSpeed = getPropWorldSpeed($bm_sub(t, overlapDuration), thisProperty);\n        else\n            propSpeed = length(velocityAtTime(t));\n        if (propSpeed < threshold) {\n            fThrough = followThroughAtTime($bm_sub(t, overlapDuration));\n            break;\n        }\n    }\n    return linear(time, t, $bm_sum(t, $bm_mul(anticipationDuration, 2)), fThrough, zeroValue);\n}\nfunction smartSmooth(axis) {\n    var startKey = nearestKey(time);\n    var endKey = startKey;\n    if (time == startKey.time)\n        return 0;\n    if (time < startKey.time && startKey.index == 1)\n        return 0;\n    if (time > startKey.time && startKey.index == numKeys)\n        return 0;\n    if (time < startKey.time)\n        startKey = key($bm_sub(startKey.index, 1));\n    if (time > startKey.time)\n        endKey = key($bm_sum(startKey.index, 1));\n    var sI = 0.66;\n    var sO = 0.33;\n    var sIV = 1;\n    var sOV = 0;\n    var sVal = startKey.value;\n    var eVal = endKey.value;\n    if ($bm_isInstanceOfArray(value)) {\n        sVal = sVal[axis];\n        eVal = eVal[axis];\n    }\n    var sTime = startKey.time;\n    var eTime = endKey.time;\n    if (isKeyTop(startKey, axis))\n        sO = slowOut;\n    else {\n        var prevKey = key($bm_sub(startKey.index, 1));\n        var pVal = prevKey.value;\n        if ($bm_isInstanceOfArray(value))\n            pVal = pVal[axis];\n        sOV = $bm_div($bm_sub(sVal, pVal), $bm_sub(eVal, pVal));\n    }\n    if (isKeyTop(endKey, axis)) {\n        sI = slowIn;\n        if (endKey.index != numKeys) {\n            var nextKey = key($bm_sum(endKey.index, 1));\n            var nVal = nextKey.value;\n            if ($bm_isInstanceOfArray(value))\n                nVal = nVal[axis];\n            if (Math.abs(nVal - eVal) < 0.01 && doFollowThrough)\n                sI = 1;\n        }\n    } else {\n        var nextKey = key($bm_sum(endKey.index, 1));\n        var nVal = nextKey.value;\n        if ($bm_isInstanceOfArray(value))\n            nVal = nVal[axis];\n        sIV = $bm_div($bm_sub(eVal, sVal), $bm_sub(nVal, sVal));\n    }\n    if (endKey.index == numKeys && doFollowThrough) {\n        sI = 1;\n    }\n    var val = value;\n    if ($bm_isInstanceOfArray(value))\n        val = val[axis];\n    return $bm_sub(bezierInterpolation(time, sTime, eTime, sVal, eVal, [\n        sO,\n        sOV,\n        sI,\n        sIV\n    ]), val);\n}\nfunction overlap() {\n    var ol = zeroValue;\n    if (isThisPosition && !hasParent)\n        return zeroValue;\n    ol = $bm_sub(getPropWorldValue($bm_sub(time, overlapDuration), thisProperty), getPropWorldValue(time, thisProperty));\n    var motionRatio = $bm_div($bm_div(length(zeroValue, ol), thisLayer.width), 2);\n    if (isThisPosition) {\n        var originalDistance = length(valueAtTime(0));\n        motionRatio = $bm_div(length(zeroValue, ol), thisComp.width);\n    }\n    ol = $bm_sum(ol, getPropWorldValue(time, thisProperty));\n    ol = $bm_sum(ol, $bm_mul($bm_mul($bm_sub(getPropWorldValue($bm_sub(time, overlapDuration), thisLayer.anchorPoint), ol), motionRatio), flexibility));\n    ol = thisLayer.fromWorld(ol);\n    if (!isThisPosition)\n        ol = $bm_sub(ol, value);\n    else {\n        ol = linear(flexibility, 0, 100, $bm_div(ol, 2), 0);\n        var prevParentWorldPos = getLayerWorldPos($bm_sub(time, overlapDuration), parent);\n        ol = $bm_sum(ol, $bm_mul($bm_mul($bm_mul(thisLayer.fromWorld(prevParentWorldPos), motionRatio), flexibility), 5));\n    }\n    return ol;\n}\nvar okToGo = false;\nif (simulate && fx.enabled)\n    okToGo = true;\nelse if (numKeys > 1 && fx.enabled)\n    okToGo = true;\nif (okToGo) {\n    var smartSmoothResult = zeroValue;\n    if (doInterpolation) {\n        if ($bm_isInstanceOfArray(value)) {\n            if (value.length == 2)\n                smartSmoothResult = [\n                    smartSmooth(0),\n                    smartSmooth(1)\n                ];\n            else if (value.length == 3)\n                smartSmoothResult = [\n                    smartSmooth(0),\n                    smartSmooth(1),\n                    smartSmooth(2)\n                ];\n            else if (value.length == 4)\n                smartSmoothResult = [\n                    smartSmooth(0),\n                    smartSmooth(1),\n                    smartSmooth(2),\n                    smartSmooth(3)\n                ];\n        } else {\n            smartSmoothResult = smartSmooth(0);\n        }\n    }\n    if (doAnticipation)\n        result = $bm_sum(result, anticipate());\n    result = $bm_sum(result, smartSmoothResult);\n    if (doFollowThrough)\n        result = $bm_sum(result, followThrough());\n    if (doOverlap)\n        result = $bm_sum(result, overlap());\n}\n$bm_rt = result;"
              },
              "p": { "a": 0, "k": [34.193, 62.315] },
              "a": { "a": 0, "k": [34.193, 62.315] },
              "s": { "a": 0, "k": [100.0, 100.0] },
              "nm": "Transform",
              "sk": { "a": 0, "k": 0.0 },
              "sa": { "a": 0, "k": 0.0 }
            }
          ]
        }
      ],
      "ip": 0,
      "op": 250,
      "st": 0.0,
      "ef": [
        {
          "ty": 5,
          "ix": 1,
          "nm": "\u015dlosilo pli pura",
          "mn": "Pseudo/Duik Kleaner v3.2",
          "ef": [
            {
              "ix": 1,
              "mn": "Pseudo/Duik Kleaner v3.2-0001",
              "nm": "Anticipation",
              "ty": 7,
              "v": { "a": 0, "k": 0.0 }
            },
            {
              "ix": 2,
              "mn": "Pseudo/Duik Kleaner v3.2-0002",
              "nm": "Smart Interpolation",
              "ty": 7,
              "v": { "a": 0, "k": 0.0 }
            },
            {
              "ix": 3,
              "mn": "Pseudo/Duik Kleaner v3.2-0003",
              "nm": "Follow Through",
              "ty": 7,
              "v": { "a": 0, "k": 1.0 }
            },
            {
              "ix": 4,
              "mn": "Pseudo/Duik Kleaner v3.2-0004",
              "nm": "Anticipation",
              "ty": 6,
              "v": 0
            },
            {
              "ix": 5,
              "mn": "Pseudo/Duik Kleaner v3.2-0005",
              "nm": "Duration (s)",
              "ty": 0,
              "v": { "a": 0, "k": 0.3 }
            },
            {
              "ix": 6,
              "mn": "Pseudo/Duik Kleaner v3.2-0006",
              "nm": "Amplitude",
              "ty": 0,
              "v": { "a": 0, "k": 50.0 }
            },
            { "ix": 7, "mn": "Pseudo/Duik Kleaner v3.2-0007", "nm": "", "ty": 6, "v": 0 },
            {
              "ix": 8,
              "mn": "Pseudo/Duik Kleaner v3.2-0008",
              "nm": "Interpolation",
              "ty": 6,
              "v": 0
            },
            {
              "ix": 9,
              "mn": "Pseudo/Duik Kleaner v3.2-0009",
              "nm": "Slow In",
              "ty": 0,
              "v": { "a": 0, "k": 60.0 }
            },
            {
              "ix": 10,
              "mn": "Pseudo/Duik Kleaner v3.2-0010",
              "nm": "Slow Out",
              "ty": 0,
              "v": { "a": 0, "k": 25.0 }
            },
            { "ix": 11, "mn": "Pseudo/Duik Kleaner v3.2-0011", "nm": "", "ty": 6, "v": 0 },
            {
              "ix": 12,
              "mn": "Pseudo/Duik Kleaner v3.2-0012",
              "nm": "Follow Through",
              "ty": 6,
              "v": 0
            },
            {
              "ix": 13,
              "mn": "Pseudo/Duik Kleaner v3.2-0013",
              "nm": "Elasticity",
              "ty": 0,
              "v": { "a": 0, "k": 10.0 }
            },
            {
              "ix": 14,
              "mn": "Pseudo/Duik Kleaner v3.2-0014",
              "nm": "Elasticity random",
              "ty": 0,
              "v": { "a": 0, "k": 0.0 }
            },
            {
              "ix": 15,
              "mn": "Pseudo/Duik Kleaner v3.2-0015",
              "nm": "Damping",
              "ty": 0,
              "v": { "a": 0, "k": 50.0 }
            },
            {
              "ix": 16,
              "mn": "Pseudo/Duik Kleaner v3.2-0016",
              "nm": "Damping random",
              "ty": 0,
              "v": { "a": 0, "k": 0.0 }
            },
            {
              "ix": 17,
              "mn": "Pseudo/Duik Kleaner v3.2-0017",
              "nm": "Bounce",
              "ty": 7,
              "v": { "a": 0, "k": 0.0 }
            },
            { "ix": 18, "mn": "Pseudo/Duik Kleaner v3.2-0018", "nm": "", "ty": 6, "v": 0 },
            {
              "ix": 19,
              "mn": "Pseudo/Duik Kleaner v3.2-0019",
              "nm": "Spatial Options",
              "ty": 6,
              "v": 0
            },
            {
              "ix": 20,
              "mn": "Pseudo/Duik Kleaner v3.2-0020",
              "nm": "Smart Interpolation",
              "ty": 7,
              "v": { "a": 0, "k": 0.0 }
            },
            {
              "ix": 21,
              "mn": "Pseudo/Duik Kleaner v3.2-0021",
              "nm": "Mode",
              "ty": 7,
              "v": { "a": 0, "k": 1.0 }
            },
            {
              "ix": 22,
              "mn": "Pseudo/Duik Kleaner v3.2-0022",
              "nm": "Overlap (simulation)",
              "ty": 6,
              "v": 0
            },
            {
              "ix": 23,
              "mn": "Pseudo/Duik Kleaner v3.2-0023",
              "nm": "Overlap",
              "ty": 7,
              "v": { "a": 0, "k": 1.0 }
            },
            {
              "ix": 24,
              "mn": "Pseudo/Duik Kleaner v3.2-0024",
              "nm": "Delay (s)",
              "ty": 0,
              "v": { "a": 0, "k": 0.05 }
            },
            {
              "ix": 25,
              "mn": "Pseudo/Duik Kleaner v3.2-0025",
              "nm": "Overlap random",
              "ty": 0,
              "v": { "a": 0, "k": 0.0 }
            },
            { "ix": 26, "mn": "Pseudo/Duik Kleaner v3.2-0026", "nm": "", "ty": 6, "v": 0 },
            {
              "ix": 27,
              "mn": "Pseudo/Duik Kleaner v3.2-0027",
              "nm": "Soft Body (simulation)",
              "ty": 6,
              "v": 0
            },
            {
              "ix": 28,
              "mn": "Pseudo/Duik Kleaner v3.2-0028",
              "nm": "Soft Body",
              "ty": 7,
              "v": { "a": 0, "k": 1.0 }
            },
            {
              "ix": 29,
              "mn": "Pseudo/Duik Kleaner v3.2-0029",
              "nm": "Soft-Body Flexibility",
              "ty": 0,
              "v": { "a": 0, "k": 100.0 }
            },
            { "ix": 30, "mn": "Pseudo/Duik Kleaner v3.2-0030", "nm": "", "ty": 6, "v": 0 },
            { "ix": 31, "mn": "Pseudo/Duik Kleaner v3.2-0031", "nm": "", "ty": 6, "v": 0 },
            {
              "ix": 32,
              "mn": "Pseudo/Duik Kleaner v3.2-0032",
              "nm": "Precision",
              "ty": 0,
              "v": { "a": 0, "k": 1.0 }
            }
          ],
          "en": 1
        },
        {
          "ty": 5,
          "ix": 2,
          "nm": "\u015dlosilo pli pura 2",
          "mn": "Pseudo/Duik Kleaner v3.2",
          "ef": [
            {
              "ix": 1,
              "mn": "Pseudo/Duik Kleaner v3.2-0001",
              "nm": "Anticipation",
              "ty": 7,
              "v": { "a": 0, "k": 0.0 }
            },
            {
              "ix": 2,
              "mn": "Pseudo/Duik Kleaner v3.2-0002",
              "nm": "Smart Interpolation",
              "ty": 7,
              "v": { "a": 0, "k": 0.0 }
            },
            {
              "ix": 3,
              "mn": "Pseudo/Duik Kleaner v3.2-0003",
              "nm": "Follow Through",
              "ty": 7,
              "v": { "a": 0, "k": 1.0 }
            },
            {
              "ix": 4,
              "mn": "Pseudo/Duik Kleaner v3.2-0004",
              "nm": "Anticipation",
              "ty": 6,
              "v": 0
            },
            {
              "ix": 5,
              "mn": "Pseudo/Duik Kleaner v3.2-0005",
              "nm": "Duration (s)",
              "ty": 0,
              "v": { "a": 0, "k": 0.3 }
            },
            {
              "ix": 6,
              "mn": "Pseudo/Duik Kleaner v3.2-0006",
              "nm": "Amplitude",
              "ty": 0,
              "v": { "a": 0, "k": 50.0 }
            },
            { "ix": 7, "mn": "Pseudo/Duik Kleaner v3.2-0007", "nm": "", "ty": 6, "v": 0 },
            {
              "ix": 8,
              "mn": "Pseudo/Duik Kleaner v3.2-0008",
              "nm": "Interpolation",
              "ty": 6,
              "v": 0
            },
            {
              "ix": 9,
              "mn": "Pseudo/Duik Kleaner v3.2-0009",
              "nm": "Slow In",
              "ty": 0,
              "v": { "a": 0, "k": 60.0 }
            },
            {
              "ix": 10,
              "mn": "Pseudo/Duik Kleaner v3.2-0010",
              "nm": "Slow Out",
              "ty": 0,
              "v": { "a": 0, "k": 25.0 }
            },
            { "ix": 11, "mn": "Pseudo/Duik Kleaner v3.2-0011", "nm": "", "ty": 6, "v": 0 },
            {
              "ix": 12,
              "mn": "Pseudo/Duik Kleaner v3.2-0012",
              "nm": "Follow Through",
              "ty": 6,
              "v": 0
            },
            {
              "ix": 13,
              "mn": "Pseudo/Duik Kleaner v3.2-0013",
              "nm": "Elasticity",
              "ty": 0,
              "v": { "a": 0, "k": 10.0 }
            },
            {
              "ix": 14,
              "mn": "Pseudo/Duik Kleaner v3.2-0014",
              "nm": "Elasticity random",
              "ty": 0,
              "v": { "a": 0, "k": 0.0 }
            },
            {
              "ix": 15,
              "mn": "Pseudo/Duik Kleaner v3.2-0015",
              "nm": "Damping",
              "ty": 0,
              "v": { "a": 0, "k": 50.0 }
            },
            {
              "ix": 16,
              "mn": "Pseudo/Duik Kleaner v3.2-0016",
              "nm": "Damping random",
              "ty": 0,
              "v": { "a": 0, "k": 0.0 }
            },
            {
              "ix": 17,
              "mn": "Pseudo/Duik Kleaner v3.2-0017",
              "nm": "Bounce",
              "ty": 7,
              "v": { "a": 0, "k": 0.0 }
            },
            { "ix": 18, "mn": "Pseudo/Duik Kleaner v3.2-0018", "nm": "", "ty": 6, "v": 0 },
            {
              "ix": 19,
              "mn": "Pseudo/Duik Kleaner v3.2-0019",
              "nm": "Spatial Options",
              "ty": 6,
              "v": 0
            },
            {
              "ix": 20,
              "mn": "Pseudo/Duik Kleaner v3.2-0020",
              "nm": "Smart Interpolation",
              "ty": 7,
              "v": { "a": 0, "k": 0.0 }
            },
            {
              "ix": 21,
              "mn": "Pseudo/Duik Kleaner v3.2-0021",
              "nm": "Mode",
              "ty": 7,
              "v": { "a": 0, "k": 1.0 }
            },
            {
              "ix": 22,
              "mn": "Pseudo/Duik Kleaner v3.2-0022",
              "nm": "Overlap (simulation)",
              "ty": 6,
              "v": 0
            },
            {
              "ix": 23,
              "mn": "Pseudo/Duik Kleaner v3.2-0023",
              "nm": "Overlap",
              "ty": 7,
              "v": { "a": 0, "k": 1.0 }
            },
            {
              "ix": 24,
              "mn": "Pseudo/Duik Kleaner v3.2-0024",
              "nm": "Delay (s)",
              "ty": 0,
              "v": { "a": 0, "k": 0.05 }
            },
            {
              "ix": 25,
              "mn": "Pseudo/Duik Kleaner v3.2-0025",
              "nm": "Overlap random",
              "ty": 0,
              "v": { "a": 0, "k": 0.0 }
            },
            { "ix": 26, "mn": "Pseudo/Duik Kleaner v3.2-0026", "nm": "", "ty": 6, "v": 0 },
            {
              "ix": 27,
              "mn": "Pseudo/Duik Kleaner v3.2-0027",
              "nm": "Soft Body (simulation)",
              "ty": 6,
              "v": 0
            },
            {
              "ix": 28,
              "mn": "Pseudo/Duik Kleaner v3.2-0028",
              "nm": "Soft Body",
              "ty": 7,
              "v": { "a": 0, "k": 1.0 }
            },
            {
              "ix": 29,
              "mn": "Pseudo/Duik Kleaner v3.2-0029",
              "nm": "Soft-Body Flexibility",
              "ty": 0,
              "v": { "a": 0, "k": 100.0 }
            },
            { "ix": 30, "mn": "Pseudo/Duik Kleaner v3.2-0030", "nm": "", "ty": 6, "v": 0 },
            { "ix": 31, "mn": "Pseudo/Duik Kleaner v3.2-0031", "nm": "", "ty": 6, "v": 0 },
            {
              "ix": 32,
              "mn": "Pseudo/Duik Kleaner v3.2-0032",
              "nm": "Precision",
              "ty": 0,
              "v": { "a": 0, "k": 1.0 }
            }
          ],
          "en": 1
        },
        {
          "ty": 5,
          "ix": 3,
          "nm": "\u015dlosilo pli pura 3",
          "mn": "Pseudo/Duik Kleaner v3.2",
          "ef": [
            {
              "ix": 1,
              "mn": "Pseudo/Duik Kleaner v3.2-0001",
              "nm": "Anticipation",
              "ty": 7,
              "v": { "a": 0, "k": 0.0 }
            },
            {
              "ix": 2,
              "mn": "Pseudo/Duik Kleaner v3.2-0002",
              "nm": "Smart Interpolation",
              "ty": 7,
              "v": { "a": 0, "k": 0.0 }
            },
            {
              "ix": 3,
              "mn": "Pseudo/Duik Kleaner v3.2-0003",
              "nm": "Follow Through",
              "ty": 7,
              "v": { "a": 0, "k": 1.0 }
            },
            {
              "ix": 4,
              "mn": "Pseudo/Duik Kleaner v3.2-0004",
              "nm": "Anticipation",
              "ty": 6,
              "v": 0
            },
            {
              "ix": 5,
              "mn": "Pseudo/Duik Kleaner v3.2-0005",
              "nm": "Duration (s)",
              "ty": 0,
              "v": { "a": 0, "k": 0.3 }
            },
            {
              "ix": 6,
              "mn": "Pseudo/Duik Kleaner v3.2-0006",
              "nm": "Amplitude",
              "ty": 0,
              "v": { "a": 0, "k": 50.0 }
            },
            { "ix": 7, "mn": "Pseudo/Duik Kleaner v3.2-0007", "nm": "", "ty": 6, "v": 0 },
            {
              "ix": 8,
              "mn": "Pseudo/Duik Kleaner v3.2-0008",
              "nm": "Interpolation",
              "ty": 6,
              "v": 0
            },
            {
              "ix": 9,
              "mn": "Pseudo/Duik Kleaner v3.2-0009",
              "nm": "Slow In",
              "ty": 0,
              "v": { "a": 0, "k": 60.0 }
            },
            {
              "ix": 10,
              "mn": "Pseudo/Duik Kleaner v3.2-0010",
              "nm": "Slow Out",
              "ty": 0,
              "v": { "a": 0, "k": 25.0 }
            },
            { "ix": 11, "mn": "Pseudo/Duik Kleaner v3.2-0011", "nm": "", "ty": 6, "v": 0 },
            {
              "ix": 12,
              "mn": "Pseudo/Duik Kleaner v3.2-0012",
              "nm": "Follow Through",
              "ty": 6,
              "v": 0
            },
            {
              "ix": 13,
              "mn": "Pseudo/Duik Kleaner v3.2-0013",
              "nm": "Elasticity",
              "ty": 0,
              "v": { "a": 0, "k": 10.0 }
            },
            {
              "ix": 14,
              "mn": "Pseudo/Duik Kleaner v3.2-0014",
              "nm": "Elasticity random",
              "ty": 0,
              "v": { "a": 0, "k": 0.0 }
            },
            {
              "ix": 15,
              "mn": "Pseudo/Duik Kleaner v3.2-0015",
              "nm": "Damping",
              "ty": 0,
              "v": { "a": 0, "k": 50.0 }
            },
            {
              "ix": 16,
              "mn": "Pseudo/Duik Kleaner v3.2-0016",
              "nm": "Damping random",
              "ty": 0,
              "v": { "a": 0, "k": 0.0 }
            },
            {
              "ix": 17,
              "mn": "Pseudo/Duik Kleaner v3.2-0017",
              "nm": "Bounce",
              "ty": 7,
              "v": { "a": 0, "k": 0.0 }
            },
            { "ix": 18, "mn": "Pseudo/Duik Kleaner v3.2-0018", "nm": "", "ty": 6, "v": 0 },
            {
              "ix": 19,
              "mn": "Pseudo/Duik Kleaner v3.2-0019",
              "nm": "Spatial Options",
              "ty": 6,
              "v": 0
            },
            {
              "ix": 20,
              "mn": "Pseudo/Duik Kleaner v3.2-0020",
              "nm": "Smart Interpolation",
              "ty": 7,
              "v": { "a": 0, "k": 0.0 }
            },
            {
              "ix": 21,
              "mn": "Pseudo/Duik Kleaner v3.2-0021",
              "nm": "Mode",
              "ty": 7,
              "v": { "a": 0, "k": 1.0 }
            },
            {
              "ix": 22,
              "mn": "Pseudo/Duik Kleaner v3.2-0022",
              "nm": "Overlap (simulation)",
              "ty": 6,
              "v": 0
            },
            {
              "ix": 23,
              "mn": "Pseudo/Duik Kleaner v3.2-0023",
              "nm": "Overlap",
              "ty": 7,
              "v": { "a": 0, "k": 1.0 }
            },
            {
              "ix": 24,
              "mn": "Pseudo/Duik Kleaner v3.2-0024",
              "nm": "Delay (s)",
              "ty": 0,
              "v": { "a": 0, "k": 0.05 }
            },
            {
              "ix": 25,
              "mn": "Pseudo/Duik Kleaner v3.2-0025",
              "nm": "Overlap random",
              "ty": 0,
              "v": { "a": 0, "k": 0.0 }
            },
            { "ix": 26, "mn": "Pseudo/Duik Kleaner v3.2-0026", "nm": "", "ty": 6, "v": 0 },
            {
              "ix": 27,
              "mn": "Pseudo/Duik Kleaner v3.2-0027",
              "nm": "Soft Body (simulation)",
              "ty": 6,
              "v": 0
            },
            {
              "ix": 28,
              "mn": "Pseudo/Duik Kleaner v3.2-0028",
              "nm": "Soft Body",
              "ty": 7,
              "v": { "a": 0, "k": 1.0 }
            },
            {
              "ix": 29,
              "mn": "Pseudo/Duik Kleaner v3.2-0029",
              "nm": "Soft-Body Flexibility",
              "ty": 0,
              "v": { "a": 0, "k": 100.0 }
            },
            { "ix": 30, "mn": "Pseudo/Duik Kleaner v3.2-0030", "nm": "", "ty": 6, "v": 0 },
            { "ix": 31, "mn": "Pseudo/Duik Kleaner v3.2-0031", "nm": "", "ty": 6, "v": 0 },
            {
              "ix": 32,
              "mn": "Pseudo/Duik Kleaner v3.2-0032",
              "nm": "Precision",
              "ty": 0,
              "v": { "a": 0, "k": 1.0 }
            }
          ],
          "en": 1
        },
        {
          "ty": 5,
          "ix": 4,
          "nm": "\u015dlosilo pli pura 4",
          "mn": "Pseudo/Duik Kleaner v3.2",
          "ef": [
            {
              "ix": 1,
              "mn": "Pseudo/Duik Kleaner v3.2-0001",
              "nm": "Anticipation",
              "ty": 7,
              "v": { "a": 0, "k": 0.0 }
            },
            {
              "ix": 2,
              "mn": "Pseudo/Duik Kleaner v3.2-0002",
              "nm": "Smart Interpolation",
              "ty": 7,
              "v": { "a": 0, "k": 0.0 }
            },
            {
              "ix": 3,
              "mn": "Pseudo/Duik Kleaner v3.2-0003",
              "nm": "Follow Through",
              "ty": 7,
              "v": { "a": 0, "k": 1.0 }
            },
            {
              "ix": 4,
              "mn": "Pseudo/Duik Kleaner v3.2-0004",
              "nm": "Anticipation",
              "ty": 6,
              "v": 0
            },
            {
              "ix": 5,
              "mn": "Pseudo/Duik Kleaner v3.2-0005",
              "nm": "Duration (s)",
              "ty": 0,
              "v": { "a": 0, "k": 0.3 }
            },
            {
              "ix": 6,
              "mn": "Pseudo/Duik Kleaner v3.2-0006",
              "nm": "Amplitude",
              "ty": 0,
              "v": { "a": 0, "k": 50.0 }
            },
            { "ix": 7, "mn": "Pseudo/Duik Kleaner v3.2-0007", "nm": "", "ty": 6, "v": 0 },
            {
              "ix": 8,
              "mn": "Pseudo/Duik Kleaner v3.2-0008",
              "nm": "Interpolation",
              "ty": 6,
              "v": 0
            },
            {
              "ix": 9,
              "mn": "Pseudo/Duik Kleaner v3.2-0009",
              "nm": "Slow In",
              "ty": 0,
              "v": { "a": 0, "k": 60.0 }
            },
            {
              "ix": 10,
              "mn": "Pseudo/Duik Kleaner v3.2-0010",
              "nm": "Slow Out",
              "ty": 0,
              "v": { "a": 0, "k": 25.0 }
            },
            { "ix": 11, "mn": "Pseudo/Duik Kleaner v3.2-0011", "nm": "", "ty": 6, "v": 0 },
            {
              "ix": 12,
              "mn": "Pseudo/Duik Kleaner v3.2-0012",
              "nm": "Follow Through",
              "ty": 6,
              "v": 0
            },
            {
              "ix": 13,
              "mn": "Pseudo/Duik Kleaner v3.2-0013",
              "nm": "Elasticity",
              "ty": 0,
              "v": { "a": 0, "k": 10.0 }
            },
            {
              "ix": 14,
              "mn": "Pseudo/Duik Kleaner v3.2-0014",
              "nm": "Elasticity random",
              "ty": 0,
              "v": { "a": 0, "k": 0.0 }
            },
            {
              "ix": 15,
              "mn": "Pseudo/Duik Kleaner v3.2-0015",
              "nm": "Damping",
              "ty": 0,
              "v": { "a": 0, "k": 50.0 }
            },
            {
              "ix": 16,
              "mn": "Pseudo/Duik Kleaner v3.2-0016",
              "nm": "Damping random",
              "ty": 0,
              "v": { "a": 0, "k": 0.0 }
            },
            {
              "ix": 17,
              "mn": "Pseudo/Duik Kleaner v3.2-0017",
              "nm": "Bounce",
              "ty": 7,
              "v": { "a": 0, "k": 0.0 }
            },
            { "ix": 18, "mn": "Pseudo/Duik Kleaner v3.2-0018", "nm": "", "ty": 6, "v": 0 },
            {
              "ix": 19,
              "mn": "Pseudo/Duik Kleaner v3.2-0019",
              "nm": "Spatial Options",
              "ty": 6,
              "v": 0
            },
            {
              "ix": 20,
              "mn": "Pseudo/Duik Kleaner v3.2-0020",
              "nm": "Smart Interpolation",
              "ty": 7,
              "v": { "a": 0, "k": 0.0 }
            },
            {
              "ix": 21,
              "mn": "Pseudo/Duik Kleaner v3.2-0021",
              "nm": "Mode",
              "ty": 7,
              "v": { "a": 0, "k": 1.0 }
            },
            {
              "ix": 22,
              "mn": "Pseudo/Duik Kleaner v3.2-0022",
              "nm": "Overlap (simulation)",
              "ty": 6,
              "v": 0
            },
            {
              "ix": 23,
              "mn": "Pseudo/Duik Kleaner v3.2-0023",
              "nm": "Overlap",
              "ty": 7,
              "v": { "a": 0, "k": 1.0 }
            },
            {
              "ix": 24,
              "mn": "Pseudo/Duik Kleaner v3.2-0024",
              "nm": "Delay (s)",
              "ty": 0,
              "v": { "a": 0, "k": 0.05 }
            },
            {
              "ix": 25,
              "mn": "Pseudo/Duik Kleaner v3.2-0025",
              "nm": "Overlap random",
              "ty": 0,
              "v": { "a": 0, "k": 0.0 }
            },
            { "ix": 26, "mn": "Pseudo/Duik Kleaner v3.2-0026", "nm": "", "ty": 6, "v": 0 },
            {
              "ix": 27,
              "mn": "Pseudo/Duik Kleaner v3.2-0027",
              "nm": "Soft Body (simulation)",
              "ty": 6,
              "v": 0
            },
            {
              "ix": 28,
              "mn": "Pseudo/Duik Kleaner v3.2-0028",
              "nm": "Soft Body",
              "ty": 7,
              "v": { "a": 0, "k": 1.0 }
            },
            {
              "ix": 29,
              "mn": "Pseudo/Duik Kleaner v3.2-0029",
              "nm": "Soft-Body Flexibility",
              "ty": 0,
              "v": { "a": 0, "k": 100.0 }
            },
            { "ix": 30, "mn": "Pseudo/Duik Kleaner v3.2-0030", "nm": "", "ty": 6, "v": 0 },
            { "ix": 31, "mn": "Pseudo/Duik Kleaner v3.2-0031", "nm": "", "ty": 6, "v": 0 },
            {
              "ix": 32,
              "mn": "Pseudo/Duik Kleaner v3.2-0032",
              "nm": "Precision",
              "ty": 0,
              "v": { "a": 0, "k": 1.0 }
            }
          ],
          "en": 1
        },
        {
          "ty": 5,
          "ix": 5,
          "nm": "\u015dlosilo pli pura 5",
          "mn": "Pseudo/Duik Kleaner v3.2",
          "ef": [
            {
              "ix": 1,
              "mn": "Pseudo/Duik Kleaner v3.2-0001",
              "nm": "Anticipation",
              "ty": 7,
              "v": { "a": 0, "k": 0.0 }
            },
            {
              "ix": 2,
              "mn": "Pseudo/Duik Kleaner v3.2-0002",
              "nm": "Smart Interpolation",
              "ty": 7,
              "v": { "a": 0, "k": 0.0 }
            },
            {
              "ix": 3,
              "mn": "Pseudo/Duik Kleaner v3.2-0003",
              "nm": "Follow Through",
              "ty": 7,
              "v": { "a": 0, "k": 1.0 }
            },
            {
              "ix": 4,
              "mn": "Pseudo/Duik Kleaner v3.2-0004",
              "nm": "Anticipation",
              "ty": 6,
              "v": 0
            },
            {
              "ix": 5,
              "mn": "Pseudo/Duik Kleaner v3.2-0005",
              "nm": "Duration (s)",
              "ty": 0,
              "v": { "a": 0, "k": 0.3 }
            },
            {
              "ix": 6,
              "mn": "Pseudo/Duik Kleaner v3.2-0006",
              "nm": "Amplitude",
              "ty": 0,
              "v": { "a": 0, "k": 50.0 }
            },
            { "ix": 7, "mn": "Pseudo/Duik Kleaner v3.2-0007", "nm": "", "ty": 6, "v": 0 },
            {
              "ix": 8,
              "mn": "Pseudo/Duik Kleaner v3.2-0008",
              "nm": "Interpolation",
              "ty": 6,
              "v": 0
            },
            {
              "ix": 9,
              "mn": "Pseudo/Duik Kleaner v3.2-0009",
              "nm": "Slow In",
              "ty": 0,
              "v": { "a": 0, "k": 60.0 }
            },
            {
              "ix": 10,
              "mn": "Pseudo/Duik Kleaner v3.2-0010",
              "nm": "Slow Out",
              "ty": 0,
              "v": { "a": 0, "k": 25.0 }
            },
            { "ix": 11, "mn": "Pseudo/Duik Kleaner v3.2-0011", "nm": "", "ty": 6, "v": 0 },
            {
              "ix": 12,
              "mn": "Pseudo/Duik Kleaner v3.2-0012",
              "nm": "Follow Through",
              "ty": 6,
              "v": 0
            },
            {
              "ix": 13,
              "mn": "Pseudo/Duik Kleaner v3.2-0013",
              "nm": "Elasticity",
              "ty": 0,
              "v": { "a": 0, "k": 10.0 }
            },
            {
              "ix": 14,
              "mn": "Pseudo/Duik Kleaner v3.2-0014",
              "nm": "Elasticity random",
              "ty": 0,
              "v": { "a": 0, "k": 0.0 }
            },
            {
              "ix": 15,
              "mn": "Pseudo/Duik Kleaner v3.2-0015",
              "nm": "Damping",
              "ty": 0,
              "v": { "a": 0, "k": 50.0 }
            },
            {
              "ix": 16,
              "mn": "Pseudo/Duik Kleaner v3.2-0016",
              "nm": "Damping random",
              "ty": 0,
              "v": { "a": 0, "k": 0.0 }
            },
            {
              "ix": 17,
              "mn": "Pseudo/Duik Kleaner v3.2-0017",
              "nm": "Bounce",
              "ty": 7,
              "v": { "a": 0, "k": 0.0 }
            },
            { "ix": 18, "mn": "Pseudo/Duik Kleaner v3.2-0018", "nm": "", "ty": 6, "v": 0 },
            {
              "ix": 19,
              "mn": "Pseudo/Duik Kleaner v3.2-0019",
              "nm": "Spatial Options",
              "ty": 6,
              "v": 0
            },
            {
              "ix": 20,
              "mn": "Pseudo/Duik Kleaner v3.2-0020",
              "nm": "Smart Interpolation",
              "ty": 7,
              "v": { "a": 0, "k": 0.0 }
            },
            {
              "ix": 21,
              "mn": "Pseudo/Duik Kleaner v3.2-0021",
              "nm": "Mode",
              "ty": 7,
              "v": { "a": 0, "k": 1.0 }
            },
            {
              "ix": 22,
              "mn": "Pseudo/Duik Kleaner v3.2-0022",
              "nm": "Overlap (simulation)",
              "ty": 6,
              "v": 0
            },
            {
              "ix": 23,
              "mn": "Pseudo/Duik Kleaner v3.2-0023",
              "nm": "Overlap",
              "ty": 7,
              "v": { "a": 0, "k": 1.0 }
            },
            {
              "ix": 24,
              "mn": "Pseudo/Duik Kleaner v3.2-0024",
              "nm": "Delay (s)",
              "ty": 0,
              "v": { "a": 0, "k": 0.05 }
            },
            {
              "ix": 25,
              "mn": "Pseudo/Duik Kleaner v3.2-0025",
              "nm": "Overlap random",
              "ty": 0,
              "v": { "a": 0, "k": 0.0 }
            },
            { "ix": 26, "mn": "Pseudo/Duik Kleaner v3.2-0026", "nm": "", "ty": 6, "v": 0 },
            {
              "ix": 27,
              "mn": "Pseudo/Duik Kleaner v3.2-0027",
              "nm": "Soft Body (simulation)",
              "ty": 6,
              "v": 0
            },
            {
              "ix": 28,
              "mn": "Pseudo/Duik Kleaner v3.2-0028",
              "nm": "Soft Body",
              "ty": 7,
              "v": { "a": 0, "k": 1.0 }
            },
            {
              "ix": 29,
              "mn": "Pseudo/Duik Kleaner v3.2-0029",
              "nm": "Soft-Body Flexibility",
              "ty": 0,
              "v": { "a": 0, "k": 100.0 }
            },
            { "ix": 30, "mn": "Pseudo/Duik Kleaner v3.2-0030", "nm": "", "ty": 6, "v": 0 },
            { "ix": 31, "mn": "Pseudo/Duik Kleaner v3.2-0031", "nm": "", "ty": 6, "v": 0 },
            {
              "ix": 32,
              "mn": "Pseudo/Duik Kleaner v3.2-0032",
              "nm": "Precision",
              "ty": 0,
              "v": { "a": 0, "k": 1.0 }
            }
          ],
          "en": 1
        },
        {
          "ty": 5,
          "ix": 6,
          "nm": "\u015dlosilo pli pura 6",
          "mn": "Pseudo/Duik Kleaner v3.2",
          "ef": [
            {
              "ix": 1,
              "mn": "Pseudo/Duik Kleaner v3.2-0001",
              "nm": "Anticipation",
              "ty": 7,
              "v": { "a": 0, "k": 0.0 }
            },
            {
              "ix": 2,
              "mn": "Pseudo/Duik Kleaner v3.2-0002",
              "nm": "Smart Interpolation",
              "ty": 7,
              "v": { "a": 0, "k": 0.0 }
            },
            {
              "ix": 3,
              "mn": "Pseudo/Duik Kleaner v3.2-0003",
              "nm": "Follow Through",
              "ty": 7,
              "v": { "a": 0, "k": 1.0 }
            },
            {
              "ix": 4,
              "mn": "Pseudo/Duik Kleaner v3.2-0004",
              "nm": "Anticipation",
              "ty": 6,
              "v": 0
            },
            {
              "ix": 5,
              "mn": "Pseudo/Duik Kleaner v3.2-0005",
              "nm": "Duration (s)",
              "ty": 0,
              "v": { "a": 0, "k": 0.3 }
            },
            {
              "ix": 6,
              "mn": "Pseudo/Duik Kleaner v3.2-0006",
              "nm": "Amplitude",
              "ty": 0,
              "v": { "a": 0, "k": 50.0 }
            },
            { "ix": 7, "mn": "Pseudo/Duik Kleaner v3.2-0007", "nm": "", "ty": 6, "v": 0 },
            {
              "ix": 8,
              "mn": "Pseudo/Duik Kleaner v3.2-0008",
              "nm": "Interpolation",
              "ty": 6,
              "v": 0
            },
            {
              "ix": 9,
              "mn": "Pseudo/Duik Kleaner v3.2-0009",
              "nm": "Slow In",
              "ty": 0,
              "v": { "a": 0, "k": 60.0 }
            },
            {
              "ix": 10,
              "mn": "Pseudo/Duik Kleaner v3.2-0010",
              "nm": "Slow Out",
              "ty": 0,
              "v": { "a": 0, "k": 25.0 }
            },
            { "ix": 11, "mn": "Pseudo/Duik Kleaner v3.2-0011", "nm": "", "ty": 6, "v": 0 },
            {
              "ix": 12,
              "mn": "Pseudo/Duik Kleaner v3.2-0012",
              "nm": "Follow Through",
              "ty": 6,
              "v": 0
            },
            {
              "ix": 13,
              "mn": "Pseudo/Duik Kleaner v3.2-0013",
              "nm": "Elasticity",
              "ty": 0,
              "v": { "a": 0, "k": 10.0 }
            },
            {
              "ix": 14,
              "mn": "Pseudo/Duik Kleaner v3.2-0014",
              "nm": "Elasticity random",
              "ty": 0,
              "v": { "a": 0, "k": 0.0 }
            },
            {
              "ix": 15,
              "mn": "Pseudo/Duik Kleaner v3.2-0015",
              "nm": "Damping",
              "ty": 0,
              "v": { "a": 0, "k": 50.0 }
            },
            {
              "ix": 16,
              "mn": "Pseudo/Duik Kleaner v3.2-0016",
              "nm": "Damping random",
              "ty": 0,
              "v": { "a": 0, "k": 0.0 }
            },
            {
              "ix": 17,
              "mn": "Pseudo/Duik Kleaner v3.2-0017",
              "nm": "Bounce",
              "ty": 7,
              "v": { "a": 0, "k": 0.0 }
            },
            { "ix": 18, "mn": "Pseudo/Duik Kleaner v3.2-0018", "nm": "", "ty": 6, "v": 0 },
            {
              "ix": 19,
              "mn": "Pseudo/Duik Kleaner v3.2-0019",
              "nm": "Spatial Options",
              "ty": 6,
              "v": 0
            },
            {
              "ix": 20,
              "mn": "Pseudo/Duik Kleaner v3.2-0020",
              "nm": "Smart Interpolation",
              "ty": 7,
              "v": { "a": 0, "k": 0.0 }
            },
            {
              "ix": 21,
              "mn": "Pseudo/Duik Kleaner v3.2-0021",
              "nm": "Mode",
              "ty": 7,
              "v": { "a": 0, "k": 1.0 }
            },
            {
              "ix": 22,
              "mn": "Pseudo/Duik Kleaner v3.2-0022",
              "nm": "Overlap (simulation)",
              "ty": 6,
              "v": 0
            },
            {
              "ix": 23,
              "mn": "Pseudo/Duik Kleaner v3.2-0023",
              "nm": "Overlap",
              "ty": 7,
              "v": { "a": 0, "k": 1.0 }
            },
            {
              "ix": 24,
              "mn": "Pseudo/Duik Kleaner v3.2-0024",
              "nm": "Delay (s)",
              "ty": 0,
              "v": { "a": 0, "k": 0.05 }
            },
            {
              "ix": 25,
              "mn": "Pseudo/Duik Kleaner v3.2-0025",
              "nm": "Overlap random",
              "ty": 0,
              "v": { "a": 0, "k": 0.0 }
            },
            { "ix": 26, "mn": "Pseudo/Duik Kleaner v3.2-0026", "nm": "", "ty": 6, "v": 0 },
            {
              "ix": 27,
              "mn": "Pseudo/Duik Kleaner v3.2-0027",
              "nm": "Soft Body (simulation)",
              "ty": 6,
              "v": 0
            },
            {
              "ix": 28,
              "mn": "Pseudo/Duik Kleaner v3.2-0028",
              "nm": "Soft Body",
              "ty": 7,
              "v": { "a": 0, "k": 1.0 }
            },
            {
              "ix": 29,
              "mn": "Pseudo/Duik Kleaner v3.2-0029",
              "nm": "Soft-Body Flexibility",
              "ty": 0,
              "v": { "a": 0, "k": 100.0 }
            },
            { "ix": 30, "mn": "Pseudo/Duik Kleaner v3.2-0030", "nm": "", "ty": 6, "v": 0 },
            { "ix": 31, "mn": "Pseudo/Duik Kleaner v3.2-0031", "nm": "", "ty": 6, "v": 0 },
            {
              "ix": 32,
              "mn": "Pseudo/Duik Kleaner v3.2-0032",
              "nm": "Precision",
              "ty": 0,
              "v": { "a": 0, "k": 1.0 }
            }
          ],
          "en": 1
        }
      ]
    }
  ],
  "markers": []
}
